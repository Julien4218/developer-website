{
  "/terms": [
    {
      "category_2": "Product definitions",
      "nodeid": 39646,
      "sections": [
        "License information",
        "General usage licenses",
        "Special services licenses",
        "Distributed licenses",
        "Referenced policies",
        "Product definitions",
        "Usage plans",
        "FAQ",
        "New Relic One pricing: Definitions",
        "For more help"
      ],
      "title": "New Relic One pricing: Definitions",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "License information",
      "external_id": "097fc095ef18942f3af1845237742340e36416b8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/product-definitions/new-relic-one-pricing-definitions",
      "published_at": "2020-09-13T17:42:52Z",
      "updated_at": "2020-09-10T14:58:10Z",
      "breadcrumb": "Contents / Licenses / License information / Product definitions",
      "document_type": "page",
      "popularity": 1,
      "info": "This document provides definitions of terminology you may see in New Relic contracts.",
      "body": "This document provides definitions of terminology you may see in the Terms or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment Term Commitment Term means the non-cancelable, committed Subscription Term for the Products. Customer Data Customer Data means the data, information, or content that Customer and its users send to an Account from the Software, the Customer Properties, or Third-Party Services. Customer Properties Customer Properties means Customer’s websites, infrastructure, networks, mobile applications, or other systems, as well as Customer accounts on Third-Party Services. Documentation Documentation means the New Relic technical guides and documentation made available from the dedicated ‘Documentation’ page of the New Relic website. GB Ingested A GB Ingested is a measurement of the volume of metrics, events, logs, traces, or other telemetry data sent to or generated by the Products for the benefit of the Customer, including from the Software, the Customer Properties, or Third-Party Services. In this context, a GB is defined as 1 billion bytes. Login Credentials Login Credentials means the username, email address, password, or other personal information that is provided by a Customer user in order to manage an Account. Monthly Provisioned User A Monthly Provisioned User is any user who can log into Customer’s Account(s) and access the New Relic One Product functionality as specified in an Order and the Documentation. Order Order means the purchasing order for access to the Service or related services that: (1) is either executed by the Parties or entered into by you via self-service, and references this Agreement, or (2) is entered into by you and a Channel Partner. Paid Terms of Service Paid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/paid. Product(s) Product(s) mean the purchase of the New Relic subscription products described in the applicable Order and any updates, corrections, bug fixes, modifications, improvements, related services, new features, and functionality (made generally available to New Relic’s customer base) thereto. Software Software means the distributed software, APIs, scripts, or other code proprietary to New Relic provided with the Products. Terms Terms means the underlying Customer-New Relic agreement and the Order. Third-Party Services Third-Party Services means any third party platform, add-on, service, or product not provided by New Relic and that a user integrates or enables for use with the Products, including third-party applications and plug-ins. Unpaid Terms of Service Unpaid Terms of Service means the legal terms and conditions located at: https://newrelic.com/termsandconditions/unpaid. Usage Plan Usage Plan refers to the Service or Product pricing, invoicing related information, and product-specific terms (e.g. concurrent user account sessions) contained within the Documentation. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 494.52942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "This document provides definitions of <em>terminology</em> you may see in New Relic contracts.",
        "body": "This document provides definitions of terminology you may see in the <em>Terms</em> or this site for New Relic One pricing and billing: Account Account refers to the online account or subaccounts that New Relic provides for customers to manage their use of the Products. Commitment <em>Term</em> Commitment <em>Term</em> means"
      },
      "id": "5f23b039196a67030b94f5c4"
    },
    {
      "image": "",
      "url": "https://opensource.newrelic.com/cla/",
      "sections": [
        "NEW RELIC, INC.",
        "INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT",
        "Definitions."
      ],
      "published_at": "2020-09-16T01:45:30Z",
      "title": "New Relic Open Source Contributor License Agreement",
      "updated_at": "2020-09-02T02:08:45Z",
      "type": "opensource",
      "external_id": "478151b2a97835e82c3cd1eaa49610793dc56783",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "New Relic Open Source External Projects Highlighted Projects New Relic Projects Menu External Projects Highlighted Projects New Relic Projects NEW RELIC, INC. INDIVIDUAL CONTRIBUTOR LICENSE AGREEMENT Thank you for your interest in contributing to the open source projects of New Relic, Inc. (“New Relic”). In order to clarify the intellectual property license granted with Contributions from any person or entity, New Relic must have a Contributor License Agreement (\"Agreement\") on file that has been signed by each Contributor, indicating agreement to the license terms below. This Agreement is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following terms and conditions for Your present and future Contributions submitted to New Relic. Except for the licenses granted herein to New Relic and recipients of software distributed by New Relic, You reserve all right, title, and interest in and to Your Contributions. Definitions. \"You\" (or \"Your\") shall mean the copyright owner or legal entity authorized by the copyright owner that is entering into this Agreement with New Relic. For legal entities, the entity making a Contribution and all other entities that control, are controlled by, or are under common control with that entity are considered to be a single Contributor. For the purposes of this definition, \"control\" means (i) the power, direct or indirect, to cause the direction or management of such entity, whether by contract or otherwise, or (ii) ownership of fifty percent (50%) or more of the outstanding shares, or (iii) beneficial ownership of such entity. \"Contribution\" shall mean any original work of authorship, including any modifications or additions to an existing work, that is intentionally submitted by You to New Relic for inclusion in, or documentation of, any of the products managed or maintained by New Relic (the \"Work\"). For the purposes of this definition, \"submitted\" means any form of electronic, verbal, or written communication sent to New Relic or its representatives, including but not limited to communication on electronic mailing lists, source code control systems, and issue tracking systems that are managed by, or on behalf of, New Relic for the purpose of discussing and improving the Work, but excluding communication that is conspicuously marked or otherwise designated in writing by You as \"Not a Contribution.\" Grant of Copyright License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable copyright license to reproduce, prepare derivative works of, publicly display, publicly perform, sublicense, and distribute Your Contributions and such derivative works. Grant of Patent License. Subject to the terms and conditions of this Agreement, You hereby grant to New Relic and to recipients of software distributed by New Relic a perpetual, worldwide, non-exclusive, no-charge, royalty-free, transferable, irrevocable (except as stated in this section) patent license to make, have made, use, offer to sell, sell, import, and otherwise transfer the Work, where such license applies only to those patent claims licensable by You that are necessarily infringed by Your Contributions alone or by combination of Your Contribution(s) with the Work to which such Contribution(s) was submitted. If any entity institutes patent litigation against You or any other entity (including a cross-claim or counterclaim in a lawsuit) alleging that Your Contribution, or the Work to which You have contributed, constitutes direct or contributory patent infringement, then any patent licenses granted to that entity under this Agreement for that Contribution or Work shall terminate as of the date such litigation is filed. You represent that You are legally entitled to grant the above licenses. If Your employer(s) has rights to intellectual property that You create that includes Your Contributions, You represent that You have received permission to make Contributions on behalf of that employer, that Your employer has waived such rights for Your Contributions to New Relic, or that Your employer has executed a separate Agreement with New Relic. You represent that each of Your Contributions is Your original creation (see section 7 for submissions on behalf of others). You represent that Your Contribution submissions include complete details of any third-party license or other restriction (including, but not limited to, related patents and trademarks) of which You are personally aware and which are associated with any part of Your Contributions. You are not expected to provide support for Your Contributions, except to the extent You desire to provide support. You may provide support for free, for a fee, or not at all. Unless required by applicable law or agreed to in writing, You provide Your Contributions on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied, including, without limitation, any warranties or conditions of TITLE, NON- INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A PARTICULAR PURPOSE. Should You wish to submit work that is not Your original creation, You may submit it to New Relic separately from any Contribution, identifying the complete details of its source and of any license or other restriction (including, but not limited to, related patents, trademarks, and license agreements) of which You are personally aware, and conspicuously marking the work as \"Submitted on behalf of a third-party: [named here] \". You agree to notify New Relic of any facts or circumstances of which You become aware that would make these representations inaccurate in any respect. New Relic Open Source Standards External Projects Highlighted Projects New Relic Projects Edit this page Create an issue Copyright © 2020 New Relic Inc.Version 1.9.2",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 413.65546,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is for your protection as a Contributor as well as the protection of New Relic; it does not change your rights to use your own Contributions for any other purpose. You accept and agree to the following <em>terms</em> and <em>conditions</em> for Your present and future Contributions submitted to New Relic. Except"
      },
      "id": "5f31822264441fcbe056a984"
    },
    {
      "category_2": "Developer Edition",
      "nodeid": 39641,
      "sections": [
        "Product or service licenses",
        "New Relic One",
        "APM",
        "Browser",
        "Developer Edition",
        "Infrastructure",
        "Insights",
        "Logs",
        "Mobile",
        "Synthetics",
        "Mobile apps",
        "Plugins",
        "Miscellaneous",
        "Developer Program Resources",
        "For more help"
      ],
      "title": "Developer Program Resources",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "Product or service licenses",
      "external_id": "98308cfffa652e4c25967e1be5b848b9c28ca410",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-developer-edition/developer-program-resources",
      "published_at": "2020-09-13T17:42:51Z",
      "updated_at": "2020-08-08T19:17:02Z",
      "breadcrumb": "Contents / Licenses / Product or service licenses / Developer Edition",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic Developer edition policy",
      "body": "As a customer, you are eligible to participate in New Relic’s Developer Program. Additional information and resources are available at New Relic’s Developer Program site. By downloading, accessing, or using the developer resources (including the CLI), you agree that usage of the developer resources is pursuant to the New Relic Developers Terms and Conditions and that you have the authority to bind your organization. Such terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not use these developer resources. If your use of the New Relic developer resources are covered under a separate agreement, the above does not apply to you. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 359.13794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " is pursuant to the New Relic Developers <em>Terms</em> and <em>Conditions</em> and that you have the authority to bind your organization. Such <em>terms</em> do not have to be signed in order to be binding. If you do not agree to these <em>terms</em> and <em>conditions</em>, your sole remedy is to not use these developer resources. If your"
      },
      "id": "5f338507e7b9d2f670c9de83"
    },
    {
      "category_2": "New Relic One",
      "nodeid": 39366,
      "sections": [
        "Product or service licenses",
        "New Relic One",
        "APM",
        "Browser",
        "Developer Edition",
        "Infrastructure",
        "Insights",
        "Logs",
        "Mobile",
        "Synthetics",
        "Mobile apps",
        "Plugins",
        "Miscellaneous",
        "Preview access for New Relic One",
        "For more help"
      ],
      "title": "Preview access for New Relic One",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "Product or service licenses",
      "external_id": "eae3865081d3bd8ad2dd8b6eaf0fe0147355360c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/product-or-service-licenses/new-relic-one/preview-access-new-relic-one",
      "published_at": "2020-09-13T17:29:56Z",
      "updated_at": "2020-07-31T04:41:27Z",
      "breadcrumb": "Contents / Licenses / Product or service licenses / New Relic One",
      "document_type": "page",
      "popularity": 1,
      "body": "As a customer with a paid subscription to New Relic products, you are eligible to participate in preview access of the New Relic One platform (e.g. Telemetry Data Platform, Full Stack Observability, and Applied Intelligence products) for the period beginning July 31, 2020 and ending December 31, 2020 (“Preview Access”). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE TERMS AND CONDITIONS IN LIEU OF ANY OTHER TERMS. These terms do not have to be signed in order to be binding. If you do not agree to these terms and conditions, your sole remedy is to not participate in Preview Access. New Relic reserves the right to terminate or restrict Preview Access, in whole or in part, at any time. Notwithstanding the foregoing and any other materials provided by New Relic, select customers are ineligible for the Preview Access. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 344.5481,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ", 2020 (“Preview Access”). BY DOWNLOADING, ACCESSING, INDICATING YOUR AGREEMENT TO, OR USING THE PREVIEW ACCESS PRODUCTS, YOU AGREE THAT YOUR PREVIEW ACCESS USAGE IS PURSUANT TO THESE SEPARATE <em>TERMS</em> AND <em>CONDITIONS</em> IN LIEU OF ANY OTHER <em>TERMS</em>. These <em>terms</em> do not have to be signed in order to be binding"
      },
      "id": "5f23a0f7e7b9d29da9c82305"
    },
    {
      "category_2": "FAQ",
      "nodeid": 39516,
      "sections": [
        "License information",
        "General usage licenses",
        "Special services licenses",
        "Distributed licenses",
        "Referenced policies",
        "Product definitions",
        "Usage plans",
        "FAQ",
        "New Relic One pricing plan: Frequently asked questions",
        "Frequently asked questions",
        "For more help"
      ],
      "title": "New Relic One pricing plan: Frequently asked questions",
      "category_0": "Licenses",
      "type": "docs",
      "category_1": "License information",
      "external_id": "6dedf2639c075dbb140ce0cbf69bef8ad15b16a8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/licenses/license-information/faq/new-relic-one-pricing-plan-frequently-asked-questions",
      "published_at": "2020-09-13T15:25:06Z",
      "updated_at": "2020-09-03T14:11:38Z",
      "breadcrumb": "Contents / Licenses / License information / FAQ",
      "document_type": "page",
      "popularity": 1,
      "body": "These are frequently asked questions about the New Relic One pricing plan. Frequently asked questions Q: Where can I find more information about New Relic One and related Products? A: For a high level description of user entitlements for Telemetry Data Platform, Full Stack Observability (Standard, Pro, and Enterprise; also referred to as full users), and AI, please visit our pricing page. Q: Is there a limit on the number of concurrent sessions or IP addresses that may be used with a user account? A: Yes. The current limits are described in Users and roles. Q: What terms govern my use of the Products? A: If a Customer has paid New Relic during a rolling 12-month period, then Customer’s usage of the Products is covered by the Paid Terms of Service. If a Customer has not paid New Relic during a 12-month period, then Customer’s usage of the Products is covered by the Unpaid Terms of Service. Q: How are the number of Monthly Provisioned Users (full users) calculated for each month? A: Please see Calculation details. Q: Can I mix and match New Relic One Standard, Pro, and Enterprise users in a billing account? A: No. You can only select one type of New Relic One User per billing account ID. Q: If I am an existing customer under the product-based pricing plan, I purchased extended retention, and I move to New Relic One-based pricing, will I lose my extended retention benefits? A: Unless otherwise stated in an Order, Customers that previously purchased extended retention for their products under the product-based pricing plan (i.e., New Relic Insights Pro and/or New Relic Logs) have access to that same level of extended retention under New Relic One-based pricing for its initial New Relic One term at no additional cost. Customers that did not previously purchase extended retention for their products under the original, product-based pricing plan have the default retention per the Documentation and may purchase extended retention. Q: Can Event extended retention, additional Synthetics Checks, or additional New Relic Edge data be added to my account? A: For additional retention for Events or Logs beyond the Standard Data Retention, contact your New Relic Account Executive. Note: Minimum requirement for Extended Retention is that the Customer must have a Annual Pool of Funds subscription which includes all of the following: Telemetry Data Platform, Full Stack Observability Pro or above. Telemetry Data Platform Pricing is affected. Q: What is included in New Relic's Free Tier of Products? A: Please see this page for a description of what's included. Customer’s use of the Free Tier shall be governed by the terms and conditions described in the Unpaid Terms of Service. If Customer’s usage exceeds the Free Tier, Customer is fully responsible for fees incurred in excess of the Free Tier as described in the “Pay As You Go” program and as described in the Paid Terms of Service. Q: How does the ‘Free Tier’ impact my PAYG or Annual Pool of Funds subscription? A: The Free Tier usage will be deducted automatically from the Monthly Product Usage for Pay As You Go or Annual Pool of Funds subscriptions. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 301.58627,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " Observability Pro or above. Telemetry Data Platform Pricing is affected. Q: What is included in New Relic&#x27;s Free Tier of Products? A: Please see this page for a description of what&#x27;s included. Customer’s use of the Free Tier shall be governed by the <em>terms</em> and <em>conditions</em> described in the Unpaid <em>Terms</em>"
      },
      "id": "5f33be9b196a67b12dfbd71d"
    }
  ],
  "/collect-data/get-started-nerdgraph-api-explorer": [
    {
      "category_2": "Examples",
      "nodeid": 39021,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "Use NerdGraph to manage license keys and personal API keys",
        "Feature description",
        "Create keys",
        "Update keys",
        "Delete keys",
        "Query keys",
        "For more help"
      ],
      "title": "Use NerdGraph to manage license keys and personal API keys",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "f4b228fbc3fdc408adc6d7e10a93edd0464b7762",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/use-nerdgraph-manage-license-keys-personal-api-keys",
      "published_at": "2020-09-13T16:04:19Z",
      "updated_at": "2020-08-24T01:18:58Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic NerdGraph (our GraphQL API) to create and manage your New Relic license keys, browser license keys, and personal API keys. ",
      "body": "This document contains tutorials on how to use NerdGraph to programmatically create and manage several types of New Relic keys. To build queries and see responses, use our GraphiQL explorer. For more information on our API keys, see API keys. Feature description NerdGraph's ApiAccess field can be used to programmatically create and manage the following types of keys: Personal API keys License keys, including: General license key used for APM Browser license key One common use case for this feature is the ability to create and manage license keys to let you rotate keys for security purposes. Note that you can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. General notes about this functionality: All mutations can accept multiple keys as arguments, and will return details about successful changes and errors. See examples below for details. All mutations (create, update and delete) will result in an NrAuditEvent that can be queried for auditing purposes. For details, see Audit events. Some notes about license keys: In the context of using NerdGraph, the license keys are referred to as ingest keys. This feature allows you to create up to 1,000 keys of each license key type, which allows for key rotation. You can't use this NerdGraph functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you've created. License keys created through NerdGraph can't be found in the New Relic UI. They're only queryable via the API. Some notes about personal API keys: In the context of using NerdGraph, personal API keys are referred to as user keys. User keys are displayed in various UI locations (for example: the User settings UI page). The examples below use license keys (ingest keys), but personal API keys (user keys) are queried in similar ways. We recommend you experiment with queries using the GraphiQL explorer. Create keys You can create multiple keys in a single mutation, for multiple accounts and key types. Note that the mutation can return successfully created keys as well as any errors encountered trying to create keys. Example of creating a key: mutation { apiAccessCreateKeys(keys: {ingest: {accountId: YOUR_ACCOUNT_ID, ingestType: BROWSER, name: \"Browser Key\", notes: \"A note.\"}}) { createdKeys { id key name accountId notes type ... on ApiAccessIngestKey { ingestType } } errors { message type ... on ApiAccessIngestKeyError { accountId errorType ingestType } } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Update keys The update mutation takes the key ID, not the key string, to identify keys. mutation { apiAccessUpdateKeys(keys: {ingest: {keyId: KEY_ID, name: \"Updated name\", notes: \"A new note!\"}}) { updatedKeys { id key type name notes } errors { message } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Delete keys The delete mutation takes the key ID, not the key string, to identify keys. Deleted keys will no longer grant access to New Relic systems and will no longer be returned by queries to the API access GraphQL API. mutation { apiAccessDeleteKeys(keys: {ingestKeyIds: INGEST_KEY_ID}) { deletedKeys { id } errors { message } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. Query keys You can access ingest and user keys by querying a single key or all keys, scoped to the actor. If querying for a single key, you must provide the key ID and type (INGEST or USER). Querying for multiple keys is done via a key search, which uses a mandatory types list and an optional scope to filter results. User keys belonging to other users will be obfuscated in the results. Single key example query: query { actor { apiAccess { key(id: INGEST_KEY_ID, keyType: INGEST) { key name type ... on ApiAccessIngestKey { ingestType } } } } } Key search example query: query { actor { apiAccess { keySearch(query: {types: INGEST, scope: {ingestTypes: BROWSER}}) { keys { name key type ... on ApiAccessIngestKey { ingestType } } } } } } Results will vary depending on your data. Use the GraphiQL explorer to experiment with mutations and queries. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.26155,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>NerdGraph</em> to manage license keys and personal API keys",
        "sections": "<em>NerdGraph</em>",
        "info": "Use New Relic <em>NerdGraph</em> (our GraphQL API) to create and manage your New Relic license keys, browser license keys, and personal API keys. ",
        "category_1": "<em>NerdGraph</em>",
        "body": ". Note that you can&#x27;t use this <em>NerdGraph</em> functionality to manage or delete your original license keys; you can only create additional license keys and manage the ones you&#x27;ve created. General notes about this functionality: All <em>mutations</em> can accept multiple keys as arguments, and will return details",
        "breadcrumb": "Contents &#x2F; APIs &#x2F; <em>NerdGraph</em> &#x2F; Examples"
      },
      "id": "5efe0487196a6710b1766452"
    },
    {
      "nodeid": 37751,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "NerdGraph API: Examples",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Queries",
        "Mutations",
        "For more help"
      ],
      "title": "NerdGraph API: Examples ",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "017d6c34d340b9bc035e91483d675915fa5252eb",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples",
      "published_at": "2020-09-13T16:51:57Z",
      "updated_at": "2020-08-11T04:59:00Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Alerts and Nerdgraph",
      "document_type": "page",
      "popularity": 1,
      "info": "Read about how you can manage alerts conditions, policies, and muting rules using NerdGraph.",
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer: For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.55856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> API: Examples ",
        "sections": "<em>Mutations</em>",
        "info": "Read about how you can manage alerts conditions, policies, and muting rules using <em>NerdGraph</em>.",
        "body": " Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and <em>mutations</em> is through the <em>NerdGraph</em> API explorer. <em>NerdGraph</em> API explorer Our <em>NerdGraph</em> API explorer is a GraphiQL editor where you can prototype queries and <em>mutations</em>. Here are some examples showing",
        "breadcrumb": "Contents &#x2F; Alerts and Applied intelligence &#x2F; New Relic Alerts &#x2F; Alerts and <em>Nerdgraph</em>"
      },
      "id": "5f2dbad864441fd15456a9eb"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-16T01:48:56Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.73624,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for <em>query</em> and mutation). For more information on this, see Data querying and <em>mutations</em>. Permissions for working with NerdStorage In order"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Collect data - any source",
        "Query data with NRQL"
      ],
      "published_at": "2020-09-16T01:52:27Z",
      "title": "Collect data",
      "updated_at": "2020-09-16T01:52:27Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Collect data Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data   Add custom attributes Use custom attributes for deeper analysis 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events 25 min Build queries with NerdGraph Try NerdGraph and build the queries you need 15 min Collect data - any source APIs, agents, OS emitters - get any data 10 min Query data with NRQL Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.81088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Build <em>queries</em> with <em>NerdGraph</em>",
        "body": " data   Add custom attributes Use custom attributes for deeper analysis 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events 25 min Build queries with <em>NerdGraph</em> Try <em>NerdGraph</em> and build the queries you need 15 min Collect data - any source APIs, agents, OS emitters - get any data 10 min <em>Query</em> data with NRQL <em>Query</em> default data, custom events, and attributes"
      },
      "id": "5efa997328ccbc768c307de2"
    },
    {
      "category_2": "Original data retention",
      "nodeid": 33906,
      "sections": [
        "Original accounts and billing",
        "Original product-based pricing",
        "Original users and roles",
        "Original data retention",
        "Original pricing plan usage",
        "Introduction to events-to-metrics service",
        "Why create metrics from event data?",
        "Available operations",
        "Mutations",
        "Queries",
        "Use the NerdGraph GraphiQL API tool",
        "For more help"
      ],
      "title": "Introduction to events-to-metrics service",
      "category_0": "New Relic accounts",
      "type": "docs",
      "category_1": "Original accounts and billing",
      "external_id": "f023c12943b72e382127b9cf67d25c059b01280a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/accounts/data-management/introduction-events-metrics-service",
      "published_at": "2020-09-14T02:49:10Z",
      "updated_at": "2020-08-30T16:32:01Z",
      "breadcrumb": "Contents / New Relic accounts / Original accounts and billing / Original data retention",
      "document_type": "page",
      "popularity": 1,
      "info": "An intro to New Relic's events-to-metrics feature, and a list of available functions. ",
      "body": "Original pricing plan This doc is for accounts on our original product-based pricing. If you're on our newer pricing plan, see New Relic One pricing plan. Not sure which you're on? See Overview of pricing plans. New Relic provides an events-to-metrics service that lets you generate metric-type data from your event-type data. Metrics are aggregates of your event data and are optimal for analyzing and monitoring trends over long time periods. This document explains: Reasons to use this feature Available operations How to use our NerdGraph API tool to perform operations Why create metrics from event data? Historically for New Relic, NRQL queries and the resulting charts were created only with event-type data. With the new events-to-metrics feature, you can create metrics from your event data and create queries and charts from those metrics. Using metrics allows for more efficient data storage, which in turn allows for faster, more efficient data queries and chart-builds. Here's an explanation of these two types of data: Events: Event data represents a record of a single event at a specific moment in time. For example, you may have an event for every request to the system. This data is ideal for in-depth troubleshooting and analysis. Metrics: These provide an aggregated view of your event data. Metrics are better for showing trends over longer time ranges. For example, you could aggregate the total number of requests per service to one metric and then examine this month-over-month. For more on how metrics and events are different, see Understand data types. Note that creating metrics from events will not delete events; this feature creates metrics from the event data without altering the events. More details on what makes metrics unique and better for longer-range querying/charting: Metrics are dimensional; you get to choose what metadata (like host name or app name) is attached to them. The data has already been pre-aggregated into longer-period time buckets. Common metric measurements, like average, sum, minimum, and maximum, are already calculated Data retention is 13 months. Metrics are queryable using the Metric event type. Start creating an events-to-metrics rule. Available operations To perform events-to-metrics operations, you'll use NerdGraph, which is our GraphQL-format API. Before performing any operation, we recommend reading Intro to NerdGraph and exploring your data with the GraphiQL API tool. The events-to-metrics feature’s operations fall under two basic request types: Mutations, which are operations that make changes to existing rules or settings (for example, creating a new events-to-metrics rule). Queries, for fetching existing data (for example, fetching existing events-to-metrics rules). All metrics-to-events operations are role-based. When performed via NerdGraph, they'll be made under the currently logged-in New Relic user. Mutations Mutation operations include: Create an events-to-metrics rule See Create metrics. Delete a rule This operation modifies production settings, so we recommend thoroughly reviewing your changes before you run the operation. To delete a rule, you need the rule ID and the New Relic account ID. Here's an example request: mutation { eventsToMetricsDeleteRule(deletes: {ruleId: \"12\", accountId: 123456}) { successes { id name nrql } failures { errors { description reason } submitted { ruleId accountId } } } } Let's look at some elements of this request: mutation: one of the basic API operation types. eventsToMetricsDeleteRule: The method being called to delete a rule. deletes takes two parameters: ruleId: The ID of the events-to-metrics rule. accountId: The New Relic account ID. In the successes and submitted blocks, you define the data returned by a success or failure. Available parameters for these blocks: id (ruleId for submitted), name, description, nrql, enabled, and accountId. Here's an example response for the above example request: { \"data\": { \"eventsToMetricsDeleteRule\": { \"failures\": [], \"successes\": [ { \"id\": \"12\", \"name\": \"Test Rule\", \"nrql\": \"select summary(duration) as 'server.responseTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } Enable/disable a rule This operation modifies production settings, so we recommend thoroughly reviewing your changes before you run the operation. To disable or enable an existing events-to-metrics rule, you use the same eventsToMetricsUpdateRule operation, with the only difference being whether enabled is set to true or false Here's an example request for enabling an existing events-to-metrics rule: mutation { eventsToMetricsUpdateRule(updates: {ruleId: \"12\", accountId: 123456, enabled: true}) { successes { id name nrql } failures { errors { description reason } submitted { ruleId accountId } } } } Let's go through some elements of this request: mutation: one of the basic API operation types. eventsToMetricsUpdateRule: The method being called to update an existing rule and either enable it or disable it. updates takes three required parameters: ruleId: The ID of the events-to-metrics rule. accountId: The New Relic account ID. enabled: To enable a disabled rule, set this to true. To disable a rule, set this to false. In the successes and submitted blocks, you define the data returned by a success or failure. Available parameters for these blocks: id (ruleId for submitted) name description nrql enabled accountId Queries Query operations include: List all rules for a New Relic account You can choose to list all rules in a New Relic account, or return a specific rule. Below is an example of listing of all rules for an account 123456: query { actor { account(id:123456) { eventsToMetrics{ allRules{ rules{ id name enabled nrql description } } } } } } Let's go through some elements of this request: query: one of the basic API operation types, used for querying but not making changes. actor: This specifies the current user. account(id: 123456): Specify the ID for the New Relic account to retrieve data from. eventsToMetrics: Scope the data to only events-to-metrics rules. allRules: Returns all rules for that account. rules: In the rules block, you can define what data you want returned. Available fields include: id name description nrql accountId enabled Here's an example response: { \"data\": { \"actor\": { \"account\": { \"eventsToMetrics\": { \"allRules\": { \"rules\": [ { \"description\": \"Metric for total time\", \"enabled\": true, \"id\": \"1\", \"name\": \"Total Time Tx\", \"nrql\": \"select summary(totalTime) as 'server.totalTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" }, { \"description\": \"Metric for duration\", \"enabled\": true, \"id\": \"2\", \"name\": \"Duration Rule\", \"nrql\": \"select summary(duration) as 'server.responseTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } } } } List rule by rule ID If you know the exact ID for a rule, then you can query for a specific rule. For example, you may have just created a rule and now want to list its contents to review it. Below is an example listing rule number 36 for New Relic account 123456: query { actor { account(id: 123456) { eventsToMetrics { rulesById(ruleIds: \"36\") { rules { id name enabled nrql description accountId } } } } } } For more detail about the elements in this query, see List all rules. Here's an example response: { \"data\": { \"actor\": { \"account\": { \"eventsToMetrics\": { \"rulesById\": { \"rules\": [ { \"accountId\": 123456, \"description\": \"Metric for total time\", \"enabled\": true, \"id\": \"36\", \"name\": \"Total Time Tx\", \"nrql\": \"select summary(totalTime) as 'server.totalTime' from Transaction where appName = 'Data Points Staging' facet name, appName, host\" } ] } } } } } } Use the NerdGraph GraphiQL API tool You can use our GraphiQL tool to explore the data structure, and to build and run the events-to-metrics operations. To use this tool: Once you have an operation's request created with the required parameters, go to the GraphiQL API tool and paste your query into the box on the left. Execute the operation by pressing Play. (Optionally, you can get the cURL format by selecting Copy as cURL.) Validate the response in the response box on the right side. If you'd like to verify a rule-creation operation was performed successfully, you can run a list query for that rule ID. Related reading: How to create metrics Tips for querying created metrics For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.0832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Mutations</em>",
        "body": " (for example, fetching existing events-to-metrics rules). All metrics-to-events operations are role-based. When performed via <em>NerdGraph</em>, they&#x27;ll be made under the currently logged-in New Relic user. <em>Mutations</em> Mutation operations include: Create an events-to-metrics rule See Create metrics. Delete"
      },
      "id": "5f198afc64441f212d21fd47"
    }
  ],
  "/collect-data/custom-events": [
    {
      "sections": [
        "Collect data from any source",
        "Agent APIs",
        "Telemetry SDK",
        "Trace API",
        "Metric API",
        "Event API",
        "Log API"
      ],
      "title": "Collect data from any source",
      "type": "developer",
      "tags": [
        "Agent API",
        "Telemetry SDK",
        "Trace API",
        "Metric API",
        "Event API"
      ],
      "external_id": "5bfb043fffe42ea4a78d5a90bf8e92aa8b8f8c33",
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/collect-data-from-any-source/",
      "published_at": "2020-09-16T01:52:27Z",
      "updated_at": "2020-08-14T01:45:09Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Open source emitters. APIs. New Relic agents. Get data from anywhere. ",
      "body": "Collect data from any source 15 min New Relic products report a lot of data “out of the box.” When you use products like APM, Browser, Mobile, Infrastructure monitoring, or an integration, by default you receive performance data. But you may want to bring data into New Relic that isn't collected by default. Maybe you want an API-based solution that doesn't require install of an agent. Maybe you want to bring telemetry data from another analysis service into New Relic. This page describes several ways to get data into New Relic. Step 1 of 6 Agent APIs If you use our APM, Browser, or Mobile agents to report data, you can use their associated APIs to report custom data. For example, if you monitor your application with the our APM Python agent, you can use the Python agent API to set up custom instrumentation. See the agent APIs. Step 2 of 6 Telemetry SDK Our Telemetry SDKs are language wrappers for our Trace API and Metric API (and eventually our Log API and Event API). These SDKs let you easily send metrics and trace data to New Relic without needing to install an agent. For customers, we offer open-source exporters and integrations that use the Telemetry SDKs to send metrics and trace data: Istio adaptor Prometheus OpenMetrics (for Docker | for Kubernetes) OpenCensus exporter (for Go | for Python) DropWizard exporter Micrometer exporter Want to build your own solution? See our Telemetry SDK docs. Step 3 of 6 Trace API Our Trace API lets you send distributed tracing data to New Relic and consolidate tracing data from multiple sources in one place. We accept trace data in two formats: Zipkin format New Relic format (if you don’t have Zipkin-format data, you’d use this) 1 curl -i -X POST https://trace-api.newrelic.com/trace/v1 \\ 2 -H \"Content-Type: application/json\" \\ 3 -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ 4 -H 'Data-Format: newrelic' \\ 5 -H 'Data-Format-Version: 1' \\ 6 -d '[ 7 { 8 \"common\": { 9 \"attributes\": { 10 \"service.name\": \"Test Service A\", 11 \"host\": \"host123.test.com\" 12 } 13 }, 14 \"spans\": [ 15 { 16 \"trace.id\": \"123456\", 17 \"id\": \"ABC\", 18 \"attributes\": { 19 \"duration.ms\": 12.53, 20 \"name\": \"/home\" 21 } 22 }, 23 { 24 \"trace.id\": \"123456\", 25 \"id\": \"DEF\", 26 \"attributes\": { 27 \"service.name\": \"Test Service A\", 28 \"host\": \"host456.test.com\", 29 \"duration.ms\": 2.97, 30 \"name\": \"/auth\", 31 \"parent.id\": \"ABC\" 32 } 33 } 34 ] 35 } 36 ]' Copy Step 4 of 6 Metric API You can use our Metric API to send metric data to New Relic from any source. 1 curl -i -X POST https://metric-api.newrelic.com/metric/v1 \\ 2 -H \"Content-Type: application/json\" \\ 3 -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ 4 -d '[ 5 { 6 \"metrics\": [ 7 { 8 \"name\": \"memory.heap\", 9 \"type\": \"gauge\", 10 \"value\": 2.3, 11 \"timestamp\": 1531414060739, 12 \"attributes\": { 13 \"host.name\": \"dev.server.com\" 14 } 15 } 16 ] 17 } 18 ]' Copy Step 5 of 6 Event API For sending arbitrary events to New Relic, you can use our Event API. We save these events as a new event type, which can then be queried via NRQL. (Eventually, the Telemetry SDKs will support the Event API.) 1 curl -i -X POST https://insights-collector.newrelic.com/v1/accounts/$ACCOUNT_ID/events \\ 2 -H \"Content-Type: application/json\" \\ 3 -H \"x-insert-key: $INSIGHTS_INSERT_API_KEY\" \\ 4 -d '[ 5 { 6 \"eventType\": \"LoginEvent\", 7 \"service\": \"login-service\", 8 \"customerId\": \"xyz\" 9 } 10 ]' Copy Step 6 of 6 Log API If our existing logging integrations don’t meet your needs, you can use our Log API to send any arbitrary log data to New Relic. (Eventually, the Telemetry SDKs will support the Log API.) 1 curl -i -X POST https://log-api.newrelic.com/log/v1 \\ 2 -H \"Content-Type: application/json\" \\ 3 -H \"Api-Key: $INSIGHTS_INSERT_API_KEY\" \\ 4 -d '[ 5 \"logs\": [ 6 { 7 \"timestamp\": 1593538496000, 8 \"message\": \"User xyz logged in\", 9 \"service\": \"login-service\", 10 \"hostname\": \"login.example.com\" 11 } 12 ] 13 ]' Copy",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.7388,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> <em>APIs</em>",
        "info": "Open source emitters. <em>APIs</em>. New Relic <em>agents</em>. Get data from anywhere. ",
        "tags": "<em>Agent</em> <em>API</em>",
        "body": " agents to report data, you can use their associated <em>APIs</em> to report <em>custom</em> data. For example, if you monitor your application with the our APM Python <em>agent</em>, you can use the Python <em>agent</em> <em>API</em> to set up <em>custom</em> instrumentation. See the <em>agent</em> <em>APIs</em>. Step 2 of 6 Telemetry SDK Our Telemetry SDKs are language"
      },
      "id": "5efa997128ccbc3c9a307dfd"
    },
    {
      "category_2": "Custom events",
      "nodeid": 6256,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "APM: Report custom events",
        "Data considerations",
        "Record a custom event",
        "Timestamps",
        "Limits and restricted characters",
        "Reserved words",
        "For more help"
      ],
      "title": "APM: Report custom events",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/event-data-sources/custom-events/apm-report-custom-events",
      "external_id": "0c3f09d0d0e04ad50bedcdf7088eed7c171001d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/event-data-sources/custom-events/apm-report-custom-events",
      "published_at": "2020-09-13T23:57:08Z",
      "updated_at": "2020-08-27T19:32:42Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic APM: how to report custom events and attributes.",
      "body": "If you have APM, you can report custom event data, which is then available for querying in New Relic. Related documentation: Add custom attributes to existing events Send custom events using the Event API (without need for APM) Custom events sent with the agent APIs are not compatible with high security mode. Data considerations The New Relic agents sends event data to New Relic as part of its normal harvest cycle every 5 seconds for agent versions supporting real time streaming. Sending a lot of events can increase the memory overhead of the agent. New Relic enforces an upper limit of 10,000 custom events per minute. Additionally, posts greater than 1MB in size will not be recorded, regardless of the custom event limit. For more information, check out New Relic University’s tutorial Adding custom data with the APM agent API. Or, go directly to the full online course Custom data with APM. Record a custom event To record a custom event, follow the procedure for your New Relic language agent: C SDK To add a custom event to apps monitored by the C SDK, start a transaction and use the newrelic_create_custom_event and newrelic_record_custom_event functions. For more information, see the Guide to using the C SDK API. Go To add a custom event to apps monitored by the Go agent, use RecordCustomEvent. Java Custom event collection is enabled by default in Java agent version 3.13.0 or higher. To send custom events, call recordCustomEvent. For example: Map<String, Object> eventAttributes = new HashMap<String, Object>(); NewRelic.getAgent().getInsights().recordCustomEvent(\"MyCustomEvent\", eventAttributes); The first argument defines the name of your event type, and the second argument is a map with the attributes for your custom event. Event attributes must be strings or numbers. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. You can change the maximum number of events recorded by the Java agent via a configuration parameter in newrelic.yml. Specify the maximum number of events to record per minute as an integer. For example, if you want to send less than the default of 10000 events: custom_insights_events: max_samples_stored: 5000 To disable custom events entirely, add the following to your newrelic.yml:​ custom_insights_events: enabled: false For Java agent versions prior to 4.1.0, use the following YAML configuration: custom_insights_events.enabled: true custom_insights_events.max_samples_stored: 5000 .NET Custom event collection is enabled by default in .NET agent version 4.6.29.0 or higher. To send custom events, simply call RecordCustomEvent(). For example: var eventAttributes = new Dictionary<String, Object>(); NewRelic.Api.Agent.NewRelic.RecordCustomEvent('MyCustomEvent', eventAttributes); The first argument defines the name of your event type, and the second argument is an IEnumerable with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. You can turn off custom events entirely by setting customEvents.enabled to false in newrelic.config. Node.js Custom event collection is enabled by default in Node.js agent version 1.15.0 or higher. To send custom events, simply call the relevant API. For example: recordCustomEvent(eventType, attributes) Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. For restrictions on event type names, see Limits and restricted characters and Reserved words. To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.js. PHP Custom event collection is enabled by default in PHP agent version 4.18 or higher. To send custom events, simply call the relevant API function. For example: newrelic_record_custom_event(\"WidgetSale\", array(\"color\"=>\"red\", \"weight\"=>12.5)); The first argument defines the name of your event type, and the second argument is an array with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. By default, the maximum number of custom events recorded per minute is 10,000. This setting cannot be changed. To disable custom events entirely, add newrelic.custom_insights_events.enabled = false to your newrelic.ini and restart the agent. Python Custom event collection is enabled by default in Python agent version 2.60.0.46 or higher. To send custom events, simply call the relevant API. For example: newrelic.agent. record_custom_event (event_type, params, application=None) The event_type defines the name (or type) of the custom event. Attributes of the custom event should be passed in as a dictionary via the params keyword argument. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For limits and restrictions on event_type and params, see Limits and restricted characters and Reserved words If called outside of the context of a monitored web request or background task, the call will be ignored unless the application keyword argument is provided and an application object corresponding to the application against which the exception should be recorded is provided. A suitable application object can be obtained using the newrelic.agent.application() function. To disable custom events entirely, set custom_insights_events.enabled to False in your newrelic.ini configuration file. Ruby Custom event collection is enabled by default in Ruby agent version 3.9.8.273 or higher. To send custom events, simply call the relevant API. For example: ::NewRelic::Agent.record_custom_event('WidgetSale', color: 'red', weight: 12.5) The first argument defines the name of your event type, and the second argument is a hash with the attributes for your custom event. Ensure you limit the number of unique event type names that you create, and do not generate these names dynamically. For restrictions on event type names, see Limits and restricted characters and Reserved words. You can change the maximum number of events recorded by the Ruby agent via a configuration parameter in newrelic.yml: Add custom_insights_events.max_samples_stored: to your configuration file. Specify the maximum number of events to record per minute as an integer. For example, if you want to be able to send up to 5000 events per minute, add: custom_insights_events.max_samples_stored: 5000 To disable custom events entirely, add custom_insights_events.enabled: false to newrelic.yml. Timestamps You may not specify a timestamp on events that are collected and recorded via the agent. The agent will automatically assign a timestamp to events based on when they are recorded via the API. Limits and restricted characters See Custom event data requirements for size limits, data types, and naming syntax requirements. Reserved words Before creating custom attributes, review New Relic's list of reserved terms used by NRQL. Otherwise unexpected results may occur. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.61956,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM: Report <em>custom</em> <em>events</em>",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "New Relic APM: how to report <em>custom</em> <em>events</em> and attributes.",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;<em>event</em>-data-sources&#x2F;<em>custom</em>-<em>events</em>&#x2F;apm-report-<em>custom</em>-<em>events</em>",
        "body": "If you have APM, you can report <em>custom</em> <em>event</em> data, which is then available for querying in New Relic. Related documentation: Add <em>custom</em> attributes to existing <em>events</em> Send <em>custom</em> <em>events</em> using the <em>Event</em> <em>API</em> (without need for APM) <em>Custom</em> <em>events</em> sent with the <em>agent</em> <em>APIs</em> are not compatible with high",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "5f480a5a64441f578bfdcdb1"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13806,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Report custom event data",
        "Overview of reporting custom events and attributes",
        "Send custom events and attributes",
        "Extend data retention",
        "For more help"
      ],
      "title": "Report custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "external_id": "afb5f5a81ae06b22935d98c470ed9cabd7c9da6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/report-custom-event-data",
      "published_at": "2020-09-14T00:28:37Z",
      "updated_at": "2020-07-26T05:52:23Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the options for sending custom event data to New Relic. ",
      "body": "New Relic products report a variety of default event data to your account. This document will explain how to report your own custom events and attributes. Overview of reporting custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. Reporting custom events allows you to create more useful and customized queries and charts of your data, and is a key part of optimizing how New Relic works for you. Before beginning, it's important to know that reporting a large number of custom events and/or attributes can cause degraded query performance, or cause you to approach or pass data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile agent Use the mobile agent API to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn about how to extend how long events are retained in your account, see Event data retention. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 58.41201,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report <em>custom</em> <em>event</em> data",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "An overview of the options for sending <em>custom</em> <em>event</em> data to New Relic. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "body": " retention policy. Send <em>custom</em> <em>events</em> and attributes Methods for sending <em>custom</em> <em>events</em> and attributes include: Source How to send <em>custom</em> data APM <em>agent</em> Use APM <em>agent</em> <em>APIs</em> to report <em>custom</em> <em>events</em> and <em>custom</em> attributes. Browser <em>agent</em> Add <em>custom</em> attributes to the PageView <em>event</em> via the Browser <em>API</em> call",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "5e8e7f9de7b9d2aa122cf0f6"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13661,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Data requirements and limits for custom event data",
        "General requirements",
        "Reserved words",
        "Additional Browser PageAction requirements",
        "Additional Event API requirements",
        "Event type limits",
        "For more help"
      ],
      "title": "Data requirements and limits for custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "external_id": "f5beef0d09bb5918be3f8a1a3ece98c09947cd1e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/insights-custom-data-requirements-limits",
      "published_at": "2020-09-13T22:06:26Z",
      "updated_at": "2020-07-24T21:11:48Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic, general limits and requirements for reporting custom events and attributes. ",
      "body": "You can report custom events to New Relic in several ways, including the New Relic Event API, APM agent APIs, Browser agent APIs, and the Mobile SDK. This document contains general requirements and rules for inserting and using custom events and their associated attributes. Additional requirements may apply based on the method you use. General requirements How long custom data is retained depends on your Insights subscription and its associated data retention. When reporting custom events and attributes, follow these general requirements for supported data types, naming syntax, and size: Requirement Description Payload Total maximum size or length: 1 MB maximum per POST. We highly recommend using compression. The Event API has additional HTTP rate limits. Attribute data types Attribute values can be either a string or a numeric integer or float. If your attribute values contain date information, define it as an unformatted Unix timestamp (in seconds or milliseconds) by using the Insights data formatter. Attribute size Maximum name size: 255 bytes. Maximum attribute value size: Custom attributes sent by the agent: 255 bytes Attributes attached to custom events sent using the Event API: 4096 characters Charts may only display the first 255 characters of attribute values. For complete attribute values, use the JSON chart type or Query API. Maximum total attributes per event: 254. Exception: If you use an APM agent API, the max is 64. Maximum total attributes per event type: 48,000. Naming syntax Attribute names can be a combination of alphanumeric characters, colons (:), periods (.), and underscores (_). Event types (using the eventType attribute) can be a combination of alphanumeric characters, colons (:), and underscores (_). Do not use words reserved for use by NRQL. Null values The database does not store any data with a null value. Reserved words Avoid using the following reserved words as names for events and attributes. Otherwise, unexpected results may occur. This is not a complete list. In general, it's a good practice to avoid using MySQL-reserved words to avoid collision with future New Relic functionality. Keyword Description accountId This is a reserved attribute name. If it's included, it will be dropped during ingest. appId Value must be an integer. If it is not an integer, the attribute name and value will be dropped during ingest. eventType The event type as stored in New Relic. New Relic agents and scripts normally report this as eventType. Can be a combination of alphanumeric characters, colons (:), and underscores (_). Be sure to review the prohibited eventType values and eventType limits. Prohibited eventType values For your eventType value, avoid using: Metric, MetricRaw, and strings prefixed with Metric[0-9] (such as Metric2 or Metric1Minute). Public_ and strings prefixed with Public_. These event types are reserved for use by New Relic. Events passed in with these eventType values will be dropped. timestamp Must be a Unix epoch timestamp. You can define timestamps either in seconds or in milliseconds. It must be +/-1 day (24 hours) of the current time on the server. Log forwarding terms The following keys are reserved by the Infrastructure agent's log forwarding feature: entity.guid, hostname, plugin.type, fb.input. If used, they are dropped during ingest and a warning is added to the logs. NRQL syntax terms If you need to use NRQL syntax terms as attribute names, including dotted attributes, they must be enclosed in backticks; for example, `LIMIT` or `consumer.offset`. Otherwise, avoid using these reserved words: ago, and, as, auto, begin, begintime, compare, day, days, end, endtime, explain, facet, from, hour, hours, in, is, like, limit, minute, minutes, month, months, not, null, offset, or, raw, second, seconds, select, since, timeseries, until, week, weeks, where, with Additional Browser PageAction requirements For additional requirements for using New Relic Browser's custom PageAction event, see Insert custom data via New Relic Browser agent. Additional Event API requirements For more requirements and details for the Event API, see Event API. Event type limits The current limit for total number of eventType values is 250 per sub-account in a given 24-hour time period. If a user exceeds this limit, New Relic may filter or drop data. Event types include: Default events from New Relic agents Custom events from New Relic agents Custom events from Insights custom event inserter If you have a use case that requires to need to store more than 250 unique event types in a given 24-hour period, file a New Relic support ticket at support.newrelic.com. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 57.544926,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Data requirements and limits for <em>custom</em> <em>event</em> data",
        "sections": "<em>Custom</em> <em>events</em>",
        "info": "For New Relic, general limits and requirements for reporting <em>custom</em> <em>events</em> and attributes. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "<em>Custom</em> <em>events</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;insights&#x2F;insights-data-sources&#x2F;<em>custom</em>-data&#x2F;insights-<em>custom</em>-data-requirements-limits",
        "body": "You can report <em>custom</em> <em>events</em> to New Relic in several ways, including the New Relic <em>Event</em> <em>API</em>, APM <em>agent</em> <em>APIs</em>, Browser <em>agent</em> <em>APIs</em>, and the Mobile SDK. This document contains general requirements and rules for inserting and using <em>custom</em> <em>events</em> and their associated attributes. Additional requirements",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; <em>Custom</em> <em>events</em>"
      },
      "id": "59f4354f4bb81c2ea8b80d0a"
    },
    {
      "category_2": "Logs in context with agent APIs",
      "nodeid": 36921,
      "sections": [
        "Enable log management",
        "New Relic Logs",
        "Enable log monitoring",
        "Configure logs in context",
        "Logs in context for Go",
        "Logs in context for Java",
        "Logs in context for .NET",
        "Logs in context for Node.js",
        "Logs in context for PHP",
        "Logs in context for Python",
        "Logs in context for Ruby",
        "Logs in context with agent APIs",
        "Annotate logs for logs in context using APM agent APIs",
        "APM agent trace metadata and linking metadata APIs",
        "Resources for correctly annotating logs",
        "For more help"
      ],
      "title": "Annotate logs for logs in context using APM agent APIs",
      "category_0": "Log management",
      "type": "docs",
      "category_1": "Enable log management",
      "external_id": "9d737d9f02561f18b47103b62ce11ada3dfae106",
      "image": "",
      "url": "https://docs.newrelic.com/docs/logs/enable-log-management-new-relic/logs-context-agent-apis/annotate-logs-logs-context-using-apm-agent-apis",
      "published_at": "2020-09-14T02:28:01Z",
      "updated_at": "2020-08-15T03:15:39Z",
      "breadcrumb": "Contents / Log management / Enable log management / Logs in context with agent APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic's  log management: How to use APM agent APIs to manually set up your own logs in context solution. ",
      "body": "If you use log management and APM, you can configure logs in context to correlate log data with other New Relic features. If you use a logging framework not covered by our existing logs in context solutions, we provide a way for you to configure your logging libraries to achieve annotated logs necessary for logs in context. APM agent trace metadata and linking metadata APIs To get properly annotated logs for logs in context, use APM agent API calls (listed below). These APIs pass metadata required for linking log data to other New Relic data. This metadata is referred to as trace metadata and linking metadata. For tips on using these, see Resources for correct annotation. APM agent APIs: Go agent APIs: GetTraceMetadata GetLinkingMetadata Java agent APIs: getTraceMetadata getLinkingMetadata .NET agent APIs: TraceMetadata GetLinkingMetadata Node.js agent APIs: getTraceMetadata getLinkingMetadata PHP agent APIs: GetTraceMetadata GetLinkingMetadata Python agent API: get_linking_metadata Ruby agent APIs: linking_metadata current_trace_id current_span_id Resources for correctly annotating logs For more information on using the trace metadata and linking metadata APIs to annotate logs for logs in context, see the following resources: Review the APM agent specifications for getting properly formatted annotated logs for logs in context functionality, which include the required fields and properly formatted output. View the source code for our own logs in context extensions to see how we use these APIs: Go: Logrus extension Java: Log4j2 extension .NET: Serilog extension Node.js: Winston extension Python: see Python agent logging configuration PHP: Monolog extension Ruby: Logging extension For more help",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 57.024673,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Annotate logs for logs in context using APM <em>agent</em> <em>APIs</em>",
        "sections": "Logs in context with <em>agent</em> <em>APIs</em>",
        "info": "New Relic&#x27;s  log management: How to use APM <em>agent</em> <em>APIs</em> to manually set up your own logs in context solution. ",
        "category_2": "Logs in context with <em>agent</em> <em>APIs</em>",
        "body": " necessary for logs in context. APM <em>agent</em> trace metadata and linking metadata <em>APIs</em> To get properly annotated logs for logs in context, use APM <em>agent</em> <em>API</em> calls (listed below). These <em>APIs</em> pass metadata required for linking log data to other New Relic data. This metadata is referred to as trace metadata",
        "breadcrumb": "Contents &#x2F; Log management &#x2F; Enable log management &#x2F; Logs in context with <em>agent</em> <em>APIs</em>"
      },
      "id": "5f37535c196a67c8c055e5ff"
    }
  ],
  "/build-apps/add-query-mutate-data-nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-16T01:51:15Z",
      "title": "Build apps",
      "updated_at": "2020-09-16T01:51:15Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 404.85614,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em>",
        "body": " your account and <em>add</em> it to a dropdown menu in an application 45 min <em>Add</em>, <em>query</em>, and <em>mutate</em> <em>data</em> using <em>NerdStorage</em> <em>NerdStorage</em> is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min <em>Add</em> a time picker to your"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-16T01:48:56Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 155.12897,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>NerdStorage</em>",
        "sections": "Intro to <em>NerdStorage</em>",
        "info": "Intro to <em>NerdStorage</em> on New Relic One",
        "tags": "<em>nerdstorage</em>",
        "body": " document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of <em>data</em> associated with it. <em>Data</em> associated with a document: <em>NerdStorage</em> accepts any sort of <em>data</em> associated to a documentId. <em>Query</em> and mutation components that are provided work by serializing"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-09-16T01:48:57Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.76109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching <em>data</em> from your laptop while troubleshooting an issue, or adding New Relic into your CI&#x2F;CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "image": "https://opensource.newrelic.com/static/New_Relic_One_Catalog_Project-044e387f68b03896ff65f46edcffb1f3.png",
      "url": "https://opensource.newrelic.com/oss-category/",
      "sections": [
        "Categories",
        "Community Project",
        "Requirements",
        "Community Plus",
        "New Relic One Catalog",
        "Example Code",
        "New Relic Experimental",
        "Archived"
      ],
      "published_at": "2020-09-16T01:45:29Z",
      "title": "New Relic Open Source Categories",
      "updated_at": "2020-09-02T02:08:45Z",
      "type": "opensource",
      "external_id": "87c1876d27bdde7fb6636382fb5e659ae47c496a",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "New Relic Open Source External Projects Highlighted Projects New Relic Projects Menu External Projects Highlighted Projects New Relic Projects Categories Community Project Community Plus New Relic One Catalog Example Code New Relic Experimental Archived For the code snippets that appear in the project's README file, see this documentation. Community Project This code is developed in the open with input from the community through issues and PRs. There is an active maintainer team within New Relic, troubleshooting support in the New Relic Explorers Hub, and the documentation is available in the project repository. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Has active maintainer / maintainers, including at least one Relic Troubleshooting support via the New Relic Explorers Hub Issues and PR’s managed in GitHub Documentation reviewed by the New Relic documentation team Linted code An automated release pipeline Community Plus This code is developed in the open with input from the community through issues and PRs. A New Relic engineering team serves as the maintainer. Troubleshooting support is available in the New Relic Explorers Hub, and documentation is available in the project repository and docs.newrelic.com. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Is maintained by a New Relic engineering team Troubleshooting support via the New Relic Explorers Hub Issues and PR’s managed in GitHub For additional details on support options, see the Open Source Support Policy Documentation reviewed by the New Relic documentation team Linted code An automated release pipeline New Relic One Catalog This code is a part of the New Relic One Catalog. It meets the criteria for a Community Project; but it also contains UI workflows for configuration. Most Catalog projects seek to maintain a public roadmap, often expressed in a GitHub Project board and Issues within the repository. Requirements All the requirements of a Community Project An empty state application workflow that guides users through the setup of configuration data that is stored in NerdStorage Architectural review (including UX) by New Relic (Optional) maintains a public roadmap (recommended via a GitHub project in the repo) Example Code This code demonstrates an aspect of building on the New Relic One platform. Find the complete description of its usage and other relevant docs in the README. There is no long-term maintainer for this code nor is support provided, but the author(s) may address future updates / needs as platform features change. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file (optional) Issues are available at the project author's discretion Documentation reviewed by the New Relic documentation team Linted code New Relic Experimental This code solves an interesting problem but does not yet have an active maintainer(s). The project is being developed in the open for the purpose of feedback on a new feature or function. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Typically hosted in the New Relic Experimental GitHub org (Optional) Issues at the project owner's discertion Archived This code is read-only. There is neither a maintainer team nor support. Requirements Complies with New Relic's legal requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Previous references to Support should be modified or removed from the README Project is read-only and available for cloning only New Relic Open Source Standards External Projects Highlighted Projects New Relic Projects Create an issue Copyright © 2020 New Relic Inc.Version 1.9.2",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.65317,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " a public roadmap, often expressed in a GitHub Project board and Issues within the repository. Requirements All the requirements of a Community Project An empty state application workflow that guides users through the setup of configuration <em>data</em> that is stored in <em>NerdStorage</em> Architectural review (including"
      },
      "id": "5f31822228ccbc916988dff8"
    },
    {
      "sections": [
        "Query and store data",
        "Components overview",
        "Query components",
        "Mutation components",
        "Static methods",
        "NrqlQuery"
      ],
      "title": "Query and store data",
      "type": "developer",
      "tags": [
        "nerdgraph query components",
        "mutation components",
        "static methods"
      ],
      "external_id": "cbbf363393edeefbc4c08f9754b43d38fd911026",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/query-and-store-data/",
      "published_at": "2020-09-16T01:53:48Z",
      "updated_at": "2020-08-01T01:42:02Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Reference guide for SDK query components using NerdGraph",
      "body": "Query and store data 10 min To help you build a New Relic One application, we provide you with the New Relic One SDK. Here you can learn how to use the SDK query components, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Query-related React components can be identified by the Query suffix. Mutation-related components can be identified by the Mutation prefix. Components overview Our data components are based on React Apollo. The most basic component is NerdGraphQuery, which accepts any GraphQL (or GraphQL AST generated by the graphql-tag library as the query parameter, and a set of query variables passed as variables. Over this query, we have created an additional set of queries, which can be divided into four groups: User queries: These allow you to query the current user and its associated accounts. Components in this category: UserStorageQuery and AccountsQuery. Entities queries: Because New Relic One is entity-centric, we use queries to make access to your entities easier. You can count, search, list, query, and favorite them. Components in this category: EntityCountQuery, EntitySearchQuery, EntitiesByDomainTypeQuery, EntitiesByGuidsQuery, EntityByGuidQuery, EntityByNameQuery. Storage queries: New Relic One provides a simple storage mechanism that we call NerdStorage. This can be used by Nerdpack creators to store application configuration setting data, user-specific data, and other small pieces of data. Components in this category: UserStorageQuery, AccountStorageQuery, EntityStorageQuery, UserStorageMutation, AccountStorageMutation, and EntityStorageMutation. For details, see NerdStorage. NRQL queries: To be able to query your New Relic data via NRQL (New Relic Query Language), we provide a NrqlQuery component. This component can return data in different formats, so that you can use it for charting and not only for querying. Query components All query components accept a function as a children prop where the different statuses can be passed. This callback receives an object with the following properties: loading: Boolean that is set to true when data fetching is happening. Our components use the cache-and-network strategy, meaning that after the data has loaded, subsequent data reloads might be triggered first with stale data, then refreshed when the most recent data has arrived. data: Root property where the data requested is retrieved. The structure matches a root structure based on the NerdGraph schema. This is true even for highly nested data structures, which means you’ll have to traverse down to find the desired data. error: Contains an Error instance when the query fails. Set to undefined when data is loading or the fetch was successful. fetchMore: Callback function that can be called when the query is being loaded in chunks. The function will only be present when it’s feasible to do so, more data is available, and no fetchMore has already been triggered. Data is loaded in batches of 200 by default. Other components provided by the platform (like the Dropdown or the List) are capable of accepting fetchMore, meaning you can combine them easily. Mutation components Mutation components also accept a children as a function, like the query ones. The mutation can be preconfigured at the component level, and a function is passed back that you can use in your component. This is the standard React Apollo approach for performing mutations, but you might find it easier to use our static mutation method added to the component. More on this topic below. Static methods All of the described components also expose a static method so that they can be used imperatively rather than declaratively. All Query components have a static Query method, and all Mutation components have a mutation method. These static methods accept the same props as their query component, but passed as an object. For example: // Declarative way (using components). function renderAccountList() { return ( <ul> <AccountsQuery> ({data, error}) => { if (error) { return <li>Failed to retrieve list: {error.message}</li>; } return data.map((account) => { <li key={account.id}>{account.name}</li> }); }} </AccountsQuery> </ul> ); } // Imperative way (using promises). async function getAccountList() { let data = {}; try { data = await AccountsQuery.query(); } catch (error) { console.log('Failed to retrieve list: ' + error.message); return; } return data.actor.accounts.map((account) => { return account.name; }); } Copy Similarly, a mutation can happen either way; either declaratively or imperatively. NrqlQuery NrqlQuery deserves additional explanation, because there are multiple formats in which you can return data from it. To provide maximum functionality, all three are exposed through a formatType property. You can find its different values under NrqlQuery.formatType: NERD_GRAPH: Returns the format in which it arrives from NerdGraph. RAW: The format exposed by default in Insights and dashboards when being plotted as JSON. This format is useful if you have a pre-existing script in this format that you're willing to migrate to or incorporate with. CHART: The format used by the charting engine that we also expose. You can find a more detailed explanation of how to manipulate this format in the guide to chart components, and some examples. If you are willing to push data, we currently do not expose NrqlMutation. To do that, see the Event API for how to add custom events.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 82.27628,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> and store <em>data</em>",
        "sections": "<em>Query</em> and store <em>data</em>",
        "info": "Reference guide for SDK <em>query</em> components using NerdGraph",
        "tags": "nerdgraph <em>query</em> components",
        "body": ", EntityByGuid<em>Query</em>, EntityByName<em>Query</em>. Storage queries: New Relic One provides a simple storage mechanism that we call <em>NerdStorage</em>. This can be used by Nerdpack creators to store application configuration setting <em>data</em>, user-specific <em>data</em>, and other small pieces of <em>data</em>. Components in this category"
      },
      "id": "5efa989e28ccbc2f15307deb"
    }
  ],
  "/build-apps/howto-use-nrone-table-components": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table-header-cell/",
      "sections": [
        "TableHeaderCell",
        "Usage",
        "Props"
      ],
      "published_at": "2020-09-16T01:48:57Z",
      "title": "TableHeaderCell",
      "updated_at": "2020-08-03T04:46:36Z",
      "type": "developer",
      "external_id": "2a4be1419d1a6e501a8eed915b8acf7c9798259d",
      "document_type": "page",
      "popularity": 1,
      "info": "A TableHeaderCell component!",
      "body": "TableHeaderCell Usage Copy Props There are no props for this component.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 528.92267,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>TableHeaderCell</em>",
        "sections": "<em>TableHeaderCell</em>",
        "info": "A <em>TableHeaderCell</em> <em>component</em>!",
        "body": "<em>TableHeaderCell</em> Usage Copy Props There are no props for this <em>component</em>."
      },
      "id": "5efa9906196a67523e76646e"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/components/table-row/",
      "sections": [
        "TableRow",
        "Usage",
        "Props"
      ],
      "published_at": "2020-09-16T01:49:54Z",
      "title": "TableRow",
      "updated_at": "2020-08-03T04:45:42Z",
      "type": "developer",
      "external_id": "b9ca0d4e07a506dd961eb2194c5344bfa9ab770d",
      "document_type": "page",
      "popularity": 1,
      "info": "A TableRow component!",
      "body": "TableRow Usage Copy Props There are no props for this component.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 434.26685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>TableRow</em>",
        "sections": "<em>TableRow</em>",
        "info": "A <em>TableRow</em> <em>component</em>!",
        "body": "<em>TableRow</em> Usage Copy Props There are no props for this <em>component</em>."
      },
      "id": "5efa98d564441f93435f7e24"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-16T01:51:15Z",
      "title": "Build apps",
      "updated_at": "2020-09-16T01:51:15Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 414.0196,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the NerdGraphQuery <em>component</em> to an <em>application</em>",
        "body": " <em>app</em> Add a time picker to a sample application 30 min Add a <em>table</em> to your <em>app</em> Add a <em>table</em> to your New Relic One <em>app</em> 30 min Create a custom map view Build an <em>app</em> to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "nodeid": 16121,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Plan your cloud adoption",
        "Optimize your cloud native environment",
        "Create application baselines",
        "1. Identify components",
        "2. Determine compatibility",
        "3. Deploy monitoring",
        "4. Gather metrics",
        "5. Set up Dashboards",
        "Expert tips",
        "For more help"
      ],
      "title": "Create application baselines",
      "type": "docs",
      "external_id": "e971df6f5f6a6360b22e2929f33f9d7af6ff130f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/create-application-baselines",
      "published_at": "2020-09-14T06:01:37Z",
      "updated_at": "2020-09-10T10:03:33Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Plan your cloud adoption",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic to establish a baseline to use for comparison during your cloud adoption process.",
      "body": "Cloud migrations can take many forms. Some companies choose to port their applications directly from their data center to the cloud (a “Lift and Shift” migration) while others focus on completely re-architecting their applications to take advantage of benefits available only in the cloud. No matter your approach, there are three primary questions you want to answer after your migration: Has my application gotten slower? Is my application less stable than before? Am I losing customers due to either of the previous questions? To answer these questions, start by performing some basic testing to establish a baseline for the performance and availability of your systems. A baseline is a measurement of the current performance and availability of your application, which you then use as a comparison after your migration to validate your business case. In some cases, you may change a baseline when you perform migration acceptance testing. You can also use a baseline as a comparison point during your migration to make sure that you are on track. 1. Identify components Before you begin a cloud migration, identify all the tiers of your entire application stack. List all of the components (applications, services, etc.) that you want to migrate. Segment the application stack as follows: Application (backend/microservices/cron jobs) Dependency services, such as the message queue Database Website Underlying server and infrastructure Make sure that you have access to applications and instances before you start creating application baselines. Engage your application owners, DevOps engineers, and product managers for access. Example: List of components Here is an example of the list of components in an application stack: Component Name Owner Language Stack Accessibility (Internet, Intranet) Operating System Service 1 John Doe Java Internet RHEL 6 Service 2 Maya Wiz .NET Intranet Win2003 R2 RabbitMQ John Doe Java Intranet AIX Website Maya Wiz Classic ASP Internet Win2000 MS SQL Dave Z NA Intranet Win2003 R2 2. Determine compatibility Once you identify the applications that you want to migrate, it is time to verify which application tiers to monitor with the New Relic platform. Work with stakeholders in your organization to determine the amount of instrumentation that is possible–or allowed–within your organization. This is an important step and one that will pay off, as the more you can instrument, the better your baselines. Here are the New Relic products to use for baselining, depending on the components that you identified: New Relic APM: Monitor your web apps with New Relic APM. See Compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language. New Relic Infrastructure: Monitor your hosts with New Relic Infrastructure. See Compatibility and requirements for New Relic Infrastructure for supported operating systems and environments. You can also instrument other products and services with on-host integrations. New Relic Synthetics: Monitor web frontends and APIs with New Relic Synthetics. Sometimes, you may not be able to instrument your on-premise environment with APM or Infrastructure. For example, maybe your organization's policy forbids installing an agent behind a firewall. In these cases, if the application has a web frontend, use Synthetics, as it offers non-agent monitoring while still providing the ability to establish a baseline. Example: Components matched to New Relic products Match the components that you identified with their corresponding products: Component Name Tier Owner Language Stack Accessibility (Internet/ Intranet) Operating System New Relic Products Service 1 John Doe Java Internet RHEL 6 APM, Infrastructure, Synthetics Service 2 Maya Wiz .NET Intranet Win2003 R2 APM, Infrastructure ActiveMQ John Doe Java Intranet AIX APM, Plugin Website Maya Wiz Classic ASP Internet Win2000 Synthetics MS SQL Dave Z n/a Intranet Win2003 R2 Infrastructure, On-host Integration 3. Deploy monitoring Based on the component-product matches you made, deploy agents or monitors across your architecture: Deploy New Relic APM Install the APM agent on your application stack. The steps to install the APM agent are different based on language. Deploy New Relic Infrastructure After reviewing the requirements for New Relic Infrastructure, follow the instructions to install the Infrastructure agent on your hosts: Install for Linux Install for Windows Server Install on AWS Elastic Beanstalk Install with a configuration management tool Deploy Infrastructure on-host integrations To gain extended visibility into applications that your code depends on, deploy on-host integrations. Available integrations include Apache, MySQL, NGINX, and others. Create New Relic Synthetics monitors New Relic Synthetics is a suite of automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints. To get started add a monitor. Make sure to verify that your website URL is accessible from the public network. You may also need to add New Relic IPs to your allow list. 4. Gather metrics After you deploy the agents and monitors, identify which metrics are the most important to your business and use these metrics to define your KPIs. Some recommendations include: Response time: Time taken to respond to a request. Throughput: Number of requests that came in through the application. Requesting queuing (Apache, IIS, NGINX): Duration of time taken for a request to reach your application. Database call duration: Duration of time taken to complete a database call. DB call counts: Number of calls made by application code to the database. Error rate: Percent of errors reported. Apdex score: An industry standard to measure user satisfaction with the response time of web applications and services. DNS setup timing: The time it takes to connect and receive data from DNS. SSL setup timing: The time it takes to establish an SSL connection. You can find some of these metrics in service maps, as well as on APM, and Browser overview pages. For more detailed information about navigating, interpreting, and using New Relic APM, check out these New Relic University’s tutorials: Overview dashboard tour Transactions dashboard Understanding Apdex 5. Set up Dashboards After you define your KPIs, it is easy to visualize them in New Relic Dashboards. Dashboards provide a single location to view all the data that New Relic products gather. Dashboards data consists of events, and each event has an event type, a timestamp, and key-value attributes. For more information about events, see Data collection and Default events for New Relic products. You can locate your KPIs and business metrics data in New Relic using the data explorer and the NRQL query language. You can also build Dashboards to track the performance of those KPIs: Example: Component performance compared against baselines Continuing the examples in this document, the following table illustrates the maturity of your application performance over a period of time based on deployment milestones. Each milestone will serve as a new baseline for your applications: Component Milestone 1 Milestone 2 Milestone N Environment Component Name Response Time SLA Apdex Response Time SLA Apdex Response On-Prem Service 1 1.5 secs 80% 70% 1.5 secs 68% 0.65 1.4 secs Cloud Service 1 0.9 secs 96.8% 95% 0.9 secs 98% 0.99 0.7 secs On-Prem Service 2 0.7 secs 73% 68% 0.7 secs 80% 0.78 0.85 secs Cloud Service 2 0.6 secs 90% 92% 0.6 secs 89% 0.90 0.5 secs After your migration, compare these baselines against your migration acceptance testing baselines. Expert tips If you find that you need data that is not captured by default instrumentation, New Relic makes it easy to capture custom data: APM custom instrumentation Browser custom data Infrastructure custom attributes Custom event data Mobile custom data Synthetics custom attributes You can also learn more about APM custom instrumentation with the New Relic University Custom data tutorial series. For more help",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.9665,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>application</em> baselines",
        "sections": "1. Identify <em>components</em>",
        "info": "Use New <em>Relic</em> to establish a baseline to use for comparison during your cloud adoption process.",
        "body": " ASP Internet Win2000 Synthetics MS SQL Dave Z n&#x2F;a Intranet Win2003 <em>R</em>2 Infrastructure, On-host Integration 3. Deploy monitoring Based on the <em>component</em>-product matches you made, deploy agents or monitors across your architecture: Deploy New Relic APM Install the APM agent on your application stack"
      },
      "id": "5ad48685c75d0766faa181bd"
    },
    {
      "nodeid": 16171,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Plan your cloud adoption",
        "Optimize your cloud native environment",
        "Perform migration acceptance testing",
        "1. Gather existing on-premise baselines",
        "2. Compare baselines after you migrate",
        "3. Create dashboards to track migration results",
        "4. Uncover issues",
        "Expert tip for ensuring a successful migration",
        "For more help"
      ],
      "title": "Perform migration acceptance testing",
      "type": "docs",
      "external_id": "121a24aa76d3e2ca89c51d7510b0a7043d3aa689",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/migration_image.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/perform-migration-acceptance-testing",
      "published_at": "2020-09-13T22:36:57Z",
      "updated_at": "2020-09-10T10:13:47Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Plan your cloud adoption",
      "document_type": "page",
      "popularity": 1,
      "info": "Validate the success of your cloud migration by comparing the baselines of your on-premise applications.",
      "body": "You can validate the success of your cloud migration by comparing the baselines of your on-premise applications against the baselines of your migrated cloud applications. As you complete each milestone in your cloud migration, compare the baselines of your applications against their previous baselines. For the final acceptance test at the end of your migrations, compare the on-premise baselines against the final migrated cloud baselines. Follow the steps in this doc to determine if your migration was successful or if you still have some work to do before it is complete. 1. Gather existing on-premise baselines New Relic recommends creating application baselines before continuing this procedure. As part of creating application baselines, you identified application components to move to the cloud, deployed New Relic, and recorded baselines for your applications based on existing on-premise deployment. You can reuse the same table that you created in the application baseline tutorial for your on-premise baselines: Example of a baseline before cloud migration Component Name Response time Availability (SLA) Apdex Service 1 1.5 secs 80% 70% Service 2 0.7 secs 73% 68% 2. Compare baselines after you migrate Establish milestones as you progress with your cloud migration by reviewing baselines for applications, databases, and other application tiers. After you migrate an application to the cloud, repeat the same steps that you used to create an on-premise baseline until you have migrated all components to the cloud (applications, web services, databases, message queues). You can mark application baselines based on time (for example, bi-weekly) or based on the full migration of each application tier. Build on your on-premise baseline table to compare results after each migration milestone: Example of a baseline after cloud migration Component Name Response time Availability (SLA) Apdex Service 1 0.9 secs 96.8% 95% Service 2 0.6 secs 90% 92% You can see the most benefit from the Availability metric by monitoring it over a long period of time. However, as you move closer to completing your migration, this metric should get closer and closer to 100%. 3. Create dashboards to track migration results Use dashboard charts to track each of your business key performance indicator (KPI) so that you can measure the success of your cloud migration. This dashboard illustrates the maturity of your application’s performance over a period of time based on deployment milestones: At the end of your migration, you can display this information in dashboards to show a clear comparison between your on-premise environment and your migrated cloud environment. 4. Uncover issues New Relic provides performance metrics, but it also provides errors and unhandled exceptions associated with your applications. It is important to keep an eye on errors and exceptions so you can verify if they occur before, during, or after your migration. Refer to Identify issues and roadblocks for more detail regarding the detection of errors or possible issues with your application's architecture, scale, or performance. Expert tip for ensuring a successful migration Continue to compare baselines until you have successfully migrated all components of your application to the cloud. The goal is to have your cloud-based application baselines perform as well as, or better than, their on-premise baselines. You may not be able to draw 1:1 comparisons between your cloud-based components and their on-premise counterparts, but you will be able to compare established cloud migration milestones throughout your migration to make sure it is successful. For more help Explore the New Relic Platform.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 258.80188,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "New <em>Relic</em> solutions",
        "info": "Validate the success of your cloud migration by comparing the baselines of your on-premise <em>applications</em>.",
        "body": " deployment. You can reuse the same <em>table</em> that you created in the application baseline tutorial for your on-premise baselines: Example of a baseline before cloud migration <em>Component</em> Name Response time Availability (SLA) Apdex Service 1 1.5 secs 80% 70% Service 2 0.7 secs 73% 68% 2. Compare baselines"
      },
      "id": "5f59fc5b28ccbce888532724"
    }
  ],
  "/explore-docs/nerdstorage": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-16T01:51:15Z",
      "title": "Build apps",
      "updated_at": "2020-09-16T01:51:15Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 404.9348,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "body": " you start building <em>apps</em>, and dive into our library of <em>components</em>. We also have a growing number of open source <em>apps</em> that you can use to get started. The rest is up to you. Guides to build <em>apps</em> 15 min Create a &quot;Hello, World!&quot; application Build a &quot;Hello, World!&quot; <em>app</em> and publish it to <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Add, query, and mutate data using NerdStorage",
        "Before you begin",
        "Get started",
        "Add data to NerdStorage",
        "Query data from NerdStorage",
        "Mutate data in NerdStorage",
        "Delete collection from NerdStorage",
        "Next steps"
      ],
      "title": "Add, query, and mutate data using NerdStorage",
      "type": "developer",
      "tags": [
        "add data",
        "query data",
        "mutate data",
        "nerdstorage"
      ],
      "external_id": "97cc9637edea35ecd68683f1010f67a5f8c79038",
      "image": "https://developer.newrelic.com/static/e03456a7ed8556f83bd3329ea38b261d/8f217/add-data-NerdStorage.png",
      "url": "https://developer.newrelic.com/build-apps/add-query-mutate-data-nerdstorage/",
      "published_at": "2020-09-16T01:52:28Z",
      "updated_at": "2020-08-30T01:49:16Z",
      "document_type": "page",
      "popularity": 1,
      "info": "NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next.",
      "body": "Add, query, and mutate data using NerdStorage 45 min NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. Using NerdStorage, you can create individual documents of up to 64kb in size, create different collections of documents, and store data by entity, account, or user level. This guide explains how to add data and documents to NerdStorage. For an introduction to what NerdStorage is and how it works, see Intro to NerdStorage. Before you begin This guide requires that you have an API key and the New Relic One CLI as described in Set up your development environment. Get started First, get the NerdStorage app running successfully inside New Relic One. Step 1 of 3 Clone the example applications from the GitHub repo. Step 2 of 3 Use the New Relic One CLI to update the application UUID and run the application locally. In the terminal, switch to the /nr1-how-to/use-nerdstorage directory: cd / nr1 - how - to / use - nerdstorage; Copy Update the UUID and serve the application: nr1 nerdpack:uuid -gf nr1 nerdpack:serve Copy Step 3 of 3 Once the app is successfully served, your terminal will return the URL to view your running application on New Relic One. Load the URL. Click Apps and under Your apps you'll see the Use Nerdstorage app listed. Click to launch the app. Add data to NerdStorage Once the app is up and running on New Relic One, you can prepare the app and start adding data. On the How To Use NerdStorage app screen, there's a Saved to NerdStorage pane with a field for adding data. However, if you type something you'll get an error message. This is because you need to be set up to store data at the User level. You can do this with the help of the UserStorageMutation component. Step 1 of 3 Open the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file in the text editor of your choice and find the code for the TextField and Button used to enter data. The Button onClick prop makes a call to a helper method called _addToNerdStorage, and you need to update it to add UserStorageMutation The UserStorage NerdStorage components require a collection and documentId. In the constructor method in the application’s index.js file, you can see the variables being provided. In the .js file, it will look something like this: constructor(props) { super(props) this.collectionId = 'mycollection'; this.documentId = 'learning-nerdstorage'; this.state = { isOpen: true, storage: [], text: '', }; this._addToNerdStorage = this._addToNerdStorage.bind(this); this._removeFromNerdStorage = this._removeFromNerdStorage.bind(this); this._deleteDocument = this._deleteDocument.bind(this); } Copy Step 2 of 3 Import the UserStorageMutation by adding it to your import statement at the top of the index.js file: import { UserStorageMutation } from 'nr1'; Copy Then update the helper with this code beginning with _addToNerdStorage: _addToNerdStorage(){ const { text, storage } = this.state; storage.push(text); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { this.setState({text: ''}); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Step 3 of 3 Return to your running How To Use NerdStorage app screen on New Relic One and reload the page. Add some text in the text entry field and click the check button. This will update NerdStorage and trigger a Toast notification inside the app. You should then see the text you typed displayed as a table row below the text entry field. Query data from NerdStorage Once you get data storage working as described in the section above, you also need to get the app properly reading data from NerdStorage, or the app will reload with an empty state every time you navigate away from the app page and back. To do this, add the UserStorageQuery component and update the componentDidMount method. Step 1 of 3 Import the UserStorageQuery by adding it to the import statement in the application’s ./nerdlets/use-nerdstorage-nerdlet/index.js file. import { UserStorageMutation, UserStorageQuery } from 'nr1'; Copy Step 2 of 3 Then, add the following componentDidMount method to your application: componentDidMount(){ UserStorageQuery.query({ collection: this.collectionId, documentId: this.documentId, }) .then(({ data }) => { if(data !== null) { this.setState({storage: data.storage}); } }) .catch(err => console.log(err)); } Copy Step 3 of 3 Back inside the NerdStorage app, test your changes by adding a few more rows using the text entry field. Then exit and relaunch the application. The application should load and show all the data you entered before you navigated away. Mutate data in NerdStorage Each NerdStorage entry displayed in the table inside the app has a trash button that can be used to update a specific entry. The trash button works by making a call to the _removeFromNerdStorage helper method. Step 1 of 1 To get this process working, update the code in _removeFromNerdStorage: _removeFromNerdStorage(index, data){ const { storage } = this.state; storage.pop(data); this.setState({storage}, () => { UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.WRITE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, document: { storage }, }) .then((res) => { Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.NORMAL }); }) .catch((err) => console.log(err)); }); } Copy Once you do this, clicking the trash button removes the item it's associated with, and the app updates to show the change. Delete collection from NerdStorage While the trash button is a good method for removing specific entries one at a time, you may also want the ability to delete a whole NerdStorage document at once. You can do this by adding the Delete Document button to your app. Step 1 of 2 Add a new GridItem to the application immediately before the closing Grid tag. In the new GridItem add the following code to display your new button: <Button onClick={() => this._deleteDocument()} type={Button.TYPE.DESTRUCTIVE} sizeType={Button.SIZE_TYPE.SMALL} iconType={Button.ICON_TYPE.INTERFACE__OPERATIONS__TRASH} > Delete Document </Button>; Copy Step 2 of 2 Because the new Delete Document button will be calling the _deleteDocument helper method, you'll need to update that using this code: _deleteDocument(){ this.setState({storage: []}); UserStorageMutation.mutate({ actionType: UserStorageMutation.ACTION_TYPE.DELETE_DOCUMENT, collection: this.collectionId, documentId: this.documentId, }); Toast.showToast({ title: \"NerdStorage Update.\", type: Toast.TYPE.CRITICAL }); } Copy Back inside the application, you should now see both the individual trash buttons and the newly added Delete Document button. Next steps Now that you’ve successfully implemented NerdStorage into a New Relic One application, you can store and mutate data connected to your User. For more information on the various NerdStorage components, please visit the New Relic developer website API documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 307.3442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "sections": "Add, query, and mutate <em>data</em> using <em>NerdStorage</em>",
        "info": "<em>NerdStorage</em> is a document <em>database</em> <em>accessible</em> within <em>New</em> <em>Relic</em> <em>One</em>. It allows you to modify, save, and retrieve documents from <em>one</em> session to the next.",
        "tags": "<em>nerdstorage</em>",
        "body": " will return the URL to view your running application on <em>New</em> <em>Relic</em> <em>One</em>. Load the URL. Click <em>Apps</em> and under Your <em>apps</em> you&#x27;ll see the Use <em>Nerdstorage</em> <em>app</em> listed. Click to launch the <em>app</em>. Add <em>data</em> to <em>NerdStorage</em> Once the <em>app</em> is up and running on <em>New</em> <em>Relic</em> <em>One</em>, you can prepare the <em>app</em> and start adding <em>data</em>"
      },
      "id": "5efa98d4e7b9d26d6b7bab74"
    },
    {
      "sections": [
        "Intro to New Relic One API components",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One API components",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-09-16T01:52:27Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One API components",
      "body": "Intro to New Relic One API components To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.90605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API <em>components</em>",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API <em>components</em>",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API <em>components</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": " settings <em>data</em>, or user-specific <em>data</em>. For more on this, see <em>NerdStorage</em>. Platform APIs The Platform API <em>components</em> of the SDK enable your application to interact with different parts of the <em>New</em> <em>Relic</em> <em>One</em> platform, by reading and writing state from and to the URL, setting the configuration, etc"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-09-16T01:48:57Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.10901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> CLI Reference",
        "sections": "<em>New</em> <em>Relic</em> CLI Reference",
        "info": "The command line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> cli",
        "body": "<em>New</em> <em>Relic</em> CLI Reference The <em>New</em> <em>Relic</em> CLI enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching <em>data</em> from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> CLI commands Find details for the <em>New</em> <em>Relic</em> CLI command docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "image": "https://opensource.newrelic.com/static/New_Relic_One_Catalog_Project-044e387f68b03896ff65f46edcffb1f3.png",
      "url": "https://opensource.newrelic.com/oss-category/",
      "sections": [
        "Categories",
        "Community Project",
        "Requirements",
        "Community Plus",
        "New Relic One Catalog",
        "Example Code",
        "New Relic Experimental",
        "Archived"
      ],
      "published_at": "2020-09-16T01:45:29Z",
      "title": "New Relic Open Source Categories",
      "updated_at": "2020-09-02T02:08:45Z",
      "type": "opensource",
      "external_id": "87c1876d27bdde7fb6636382fb5e659ae47c496a",
      "document_type": "page",
      "popularity": 1,
      "info": "",
      "body": "New Relic Open Source External Projects Highlighted Projects New Relic Projects Menu External Projects Highlighted Projects New Relic Projects Categories Community Project Community Plus New Relic One Catalog Example Code New Relic Experimental Archived For the code snippets that appear in the project's README file, see this documentation. Community Project This code is developed in the open with input from the community through issues and PRs. There is an active maintainer team within New Relic, troubleshooting support in the New Relic Explorers Hub, and the documentation is available in the project repository. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Has active maintainer / maintainers, including at least one Relic Troubleshooting support via the New Relic Explorers Hub Issues and PR’s managed in GitHub Documentation reviewed by the New Relic documentation team Linted code An automated release pipeline Community Plus This code is developed in the open with input from the community through issues and PRs. A New Relic engineering team serves as the maintainer. Troubleshooting support is available in the New Relic Explorers Hub, and documentation is available in the project repository and docs.newrelic.com. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Is maintained by a New Relic engineering team Troubleshooting support via the New Relic Explorers Hub Issues and PR’s managed in GitHub For additional details on support options, see the Open Source Support Policy Documentation reviewed by the New Relic documentation team Linted code An automated release pipeline New Relic One Catalog This code is a part of the New Relic One Catalog. It meets the criteria for a Community Project; but it also contains UI workflows for configuration. Most Catalog projects seek to maintain a public roadmap, often expressed in a GitHub Project board and Issues within the repository. Requirements All the requirements of a Community Project An empty state application workflow that guides users through the setup of configuration data that is stored in NerdStorage Architectural review (including UX) by New Relic (Optional) maintains a public roadmap (recommended via a GitHub project in the repo) Example Code This code demonstrates an aspect of building on the New Relic One platform. Find the complete description of its usage and other relevant docs in the README. There is no long-term maintainer for this code nor is support provided, but the author(s) may address future updates / needs as platform features change. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file (optional) Issues are available at the project author's discretion Documentation reviewed by the New Relic documentation team Linted code New Relic Experimental This code solves an interesting problem but does not yet have an active maintainer(s). The project is being developed in the open for the purpose of feedback on a new feature or function. Requirements Complies with New Relic's legal and security requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Typically hosted in the New Relic Experimental GitHub org (Optional) Issues at the project owner's discertion Archived This code is read-only. There is neither a maintainer team nor support. Requirements Complies with New Relic's legal requirements for open source software Contains the appropriate New Relic open source category header in the repository's README file Previous references to Support should be modified or removed from the README Project is read-only and available for cloning only New Relic Open Source Standards External Projects Highlighted Projects New Relic Projects Create an issue Copyright © 2020 New Relic Inc.Version 1.9.2",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.73341,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Open Source Categories",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> Catalog",
        "body": "<em>New</em> <em>Relic</em> Open Source External Projects Highlighted Projects <em>New</em> <em>Relic</em> Projects Menu External Projects Highlighted Projects <em>New</em> <em>Relic</em> Projects Categories Community Project Community Plus <em>New</em> <em>Relic</em> <em>One</em> Catalog Example Code <em>New</em> <em>Relic</em> Experimental Archived For the code snippets that appear"
      },
      "id": "5f31822228ccbc916988dff8"
    }
  ],
  "/explore-docs/nr1-plugins": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-16T01:53:49Z",
      "updated_at": "2020-08-18T01:50:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.27287,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-09-16T01:48:57Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.58182,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-16T01:48:56Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.76569,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> apps",
        "body": "Intro to NerdStorage 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-09-16T01:47:05Z",
      "updated_at": "2020-08-26T01:47:20Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.02223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom app or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (<em>CLI</em>) An API key, which you get when you download the <em>CLI</em> Depending on what you want to do with your app"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-16T01:49:54Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.98044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em> Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    }
  ],
  "/explore-docs/nr1-nerdpack": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-subscription/",
      "sections": [
        "New Relic One CLI subscription commands",
        "Command details",
        "nr1 subscription:set",
        "Subscribe to a Nerdpack",
        "Usage",
        "Options",
        "Aliases",
        "nr1 subscription:list",
        "See your subscription",
        "nr1 subscription:unset",
        "Unsubscribe from a Nerdpack"
      ],
      "published_at": "2020-09-16T01:55:53Z",
      "title": "New Relic One CLI subscription commands",
      "updated_at": "2020-08-06T01:44:54Z",
      "type": "developer",
      "external_id": "12d2e1b06dede5b1272527f95a14518010aecc58",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to manage your Nerdpack subscriptions.",
      "body": "New Relic One CLI subscription commands To manage your Nerdpack subscriptions, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Command details nr1 subscription:set Subscribe to a Nerdpack Subscribes your account to a specific Nerdpack and channel. This command can be run with a Nerdpack UUID or within a specific Nerdpack folder. By default, the command uses the Nerdpack ID in package.json and subscribes to the STABLE channel. An account can only be subscribed to one Nerdpack and channel at a time. Usage $ nr1 subscription:set Options -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to subscribe to. By default, the command will use the one in package.json. -c, --channel=DEV/BETA/STABLE Specifies the channel to subscribe to. [default: STABLE] --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. Aliases $ nr1 nerdpack:subscribe nr1 subscription:list See your subscription Lists all the Nerdpacks your account is subscribed to. Your account is linked to your API key. Usage $ nr1 subscription:list Options --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 subscription:unset Unsubscribe from a Nerdpack Unsubscribes your account from a specific Nerdpack. When this command is executed within a Nerdpack folder, the Nerdpack ID from package.json is used by default. Usage $ nr1 subscription:unset Options -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to subscribe to. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. Aliases $ nr1 nerdpack:unsubscribe $ nr1 subscription:delete $ nr1 subscription:remove $ nr1 subscription:rm",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 816.0575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> subscription <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> subscription <em>commands</em>",
        "info": "An overview of the <em>CLI</em> <em>commands</em> you can use to manage your <em>Nerdpack</em> subscriptions.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> subscription <em>commands</em> To manage your <em>Nerdpack</em> subscriptions, use the <em>commands</em> below. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 subscription:set Subscribes your account to a <em>Nerdpack</em> and channel. nr1"
      },
      "id": "5f2b6096e7b9d225ebc9de6f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-16T01:49:54Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 587.3884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " (<em>New</em> <em>Relic</em> query language). See our other <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> docs for <em>commands</em> specific to <em>Nerdpack</em> set-up, <em>Nerdpack</em> subscriptions, <em>CLI</em> configuration, plugins, or catalogs. <em>Command</em> details nr1 help See <em>commands</em> and get details Shows all nr1 <em>commands</em> by default. To get details about a specific <em>command</em>"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-16T01:53:49Z",
      "updated_at": "2020-08-18T01:50:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 245.62701,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": ". For more on how to serve and publish your application, see our guide on Deploying your <em>New</em> <em>Relic</em> <em>One</em> app. Get started nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1 update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (<em>Nerdpack</em>, Nerdlet"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-catalog/",
      "sections": [
        "New Relic One CLI catalog commands",
        "Command details",
        "nr1 catalog:info",
        "Get catalog details",
        "Usage",
        "Options",
        "nr1 catalog:submit",
        "Send info to the catalog"
      ],
      "published_at": "2020-09-16T01:48:57Z",
      "title": "New Relic One CLI catalog commands",
      "updated_at": "2020-08-14T01:49:24Z",
      "type": "developer",
      "external_id": "e94d6ad2cd04e2c01aecef526778d341867b3031",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to manage your New Relic One catalog information.",
      "body": "New Relic One CLI catalog commands To manage your catalog, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder. Command details nr1 catalog:info Get catalog details Shows the information about your application that's displayed in the catalog. If run within a specific Nerdpack folder, the info from that Nerdpack will be shown. If you don't want to get info from your local Nerdpack, use the --nerdpack-id=NERDPACK_ID option to query from a specific Nerdpack. Usage $ nr1 catalog:info Options -f, --field=FIELD Specifies which field you want info from. -i, --nerdpack-id=NERDPACK_ID Specifies which Nerdpack to get info from. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 catalog:submit Send info to the catalog Gathers the information you add to the catalog directory for your application and saves it to the catalog. See our catalog docs for details on adding screenshots and metadata to your applications to make them easy to find, attractive, and informative. This command must be run on a Nerdpack folder. The command will search for specific files using convention names. Usage $ nr1 catalog:submit Options -P, --skip-screenshots Skips upload of screenshot assets. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.22548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> catalog <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> catalog <em>commands</em>",
        "info": "An overview of the <em>CLI</em> <em>commands</em> you can use to manage your <em>New</em> <em>Relic</em> <em>One</em> catalog information.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> catalog <em>commands</em> To manage your catalog, use the <em>commands</em> below. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 catalog:info Shows the <em>Nerdpack</em> info stored in the catalog. nr1 catalog:submit Gathers and submits"
      },
      "id": "5f28bd6a64441f805eb11a26"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-09-16T01:47:05Z",
      "updated_at": "2020-08-26T01:47:20Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 161.57681,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom app or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (<em>CLI</em>) An API key, which you get when you download the <em>CLI</em> Depending on what you want to do with your app"
      },
      "id": "5efa9973e7b9d242237bab39"
    }
  ],
  "/collect-data/custom-attributes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/collect-data/",
      "sections": [
        "Collect data",
        "Guides to collect data",
        "Add custom attributes",
        "Create custom events",
        "Build queries with NerdGraph",
        "Collect data - any source",
        "Query data with NRQL"
      ],
      "published_at": "2020-09-16T01:52:27Z",
      "title": "Collect data",
      "updated_at": "2020-09-16T01:52:27Z",
      "type": "developer",
      "external_id": "fb5d6f75b61858b09e3e8c63f3b2af97813f47b6",
      "document_type": "page",
      "popularity": 1,
      "body": "Collect data Through our opensource agents or APIs, New Relic makes it easy to collect data from any source. The guides in this section provide strategies for collecting and querying data for use in your existing implementation, or in apps you build. The opportunities are endless. Guides to collect data   Add custom attributes Use custom attributes for deeper analysis 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events 25 min Build queries with NerdGraph Try NerdGraph and build the queries you need 15 min Collect data - any source APIs, agents, OS emitters - get any data 10 min Query data with NRQL Query default data, custom events, and attributes",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.19818,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em>",
        "body": " data   Add <em>custom</em> <em>attributes</em> Use <em>custom</em> <em>attributes</em> for deeper analysis 5 min Create <em>custom</em> events Define, visualize, and get alerts on the data you want using <em>custom</em> events 25 min Build queries with NerdGraph Try NerdGraph and build the queries you need 15 min Collect data - any source APIs, agents, OS emitters - get any data 10 min Query data with <em>NRQL</em> Query default data, <em>custom</em> events, and <em>attributes</em>"
      },
      "id": "5efa997328ccbc768c307de2"
    },
    {
      "category_2": "Exceptions",
      "nodeid": 10646,
      "sections": [
        "Mobile monitoring UI",
        "Mobile App pages",
        "Network pages",
        "Exceptions",
        "Usage pages",
        "Crash analysis: Group and filter your crashes",
        "Use crash analysis features",
        "View the filterable Crash list",
        "Use the crash analysis workflow",
        "For more help"
      ],
      "title": "Crash analysis: Group and filter your crashes",
      "category_0": "Mobile",
      "type": "docs",
      "category_1": "Mobile monitoring UI",
      "external_id": "32a11c727dacfa983ff7b4772776a210cc5ae2f0",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/mobile-crash-profiles.png",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/crashes/crash-analysis-group-filter-your-crashes",
      "published_at": "2020-09-16T05:51:38Z",
      "updated_at": "2020-09-16T05:51:38Z",
      "breadcrumb": "Contents / Mobile / Mobile monitoring UI / Exceptions",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's crash analysis features to identify and deal with DevOps issues for resolving unanticipated exceptions with mobile apps.",
      "body": "Mobile app crashes can result in users submitting negative reviews, which can affect your organization's reputation. Crashes can also result in users deleting your app altogether, which affects your organization's profitability. With the Crash analysis user interface, you can identify and deal with one of the largest bottlenecks in the development lifecycle: the time it takes to resolve unanticipated exceptions. Use crash analysis features When your development team receives an email notification, they can select the email link to review detailed information about the crash in our user interface, or analyze chart data directly through a query. The individual Crash details page also includes tracking tools for your team to follow the issue from reporting to resolution. Our crash analysis feature helps developers to: Slice and dice your crash and network data (using groups and filters) to analyze trends leading to the crash. Understand a particular user's experience by using a custom attribute. Pinpoint when most crashes occur; for example, by filtering by Last Interaction, or by viewing the interaction trail in the Crash report page. Align issues with common characteristics in networks or devices. Examine specific problems in a crash report that may be buried in thread breakdown data, trace details, or the trail of user interactions in the crashed session. Quickly see trends from the Crash profiles tab. View the filterable Crash list To view the filterable Crash list in the New Relic Mobile user interface: Go to one.newrelic.com > Mobile > (select an app) > Exceptions > Crash analysis. OR To view the filterable Crash analysis page directly from the mobile app's Overview page, select the Crash occurrences chart's title. Use any of our standard page functions to drill down into detailed information; for example, zoom into any area of a chart. Use the crash analysis workflow To get the most out of Mobile monitoring's Crash analysis UI, use this basic workflow. Start with the Crash rate percentage and Crash-free users percentage charts to see at a glance whether there are any unexpected spikes, dips, or patterns with crash time frames, or uneventful periods within the selected time period. Use the groups and filters to examine attributes (for crashes, devices, locations, or other custom attributes) in more detail. Use the Top 5 occurrences chart to identify patterns for the type of occurrence you selected from the groups and filters. Also correlate any general patterns for the selected type of occurrence to crash percentages that occurred during this time period. Optional: Query or share the chart data. Look for patterns in the Crash location table information, including location, exception type, date and number of occurrences, version, and number of users affected by the crash. Select a crash report from the table to view its interaction trail, its event trail, thread details for individual occurrences, attributes, and more. If necessary, resymbolicate or export the crash details to Xcode so you can debug your source code more easily. When finished, mark the crash occurrences as Resolved. Resolved crashes include a banner identifying who resolved the crash and when. Based on Mobile monitoring's data retention policies, you can filter by resolved crashes when you need to track back to historical information. Crash percentages charts: See patterns immediately. Start with the Crash rate percentage and Crash-free users percentage charts to see at a glance whether there are any unexpected spikes, dips, or patterns with crashes in general. For example: Are there any spikes near a recent version release? Is there a time period when the percentage of users has been affected significantly by the crash? (If the Crash-free users percentage chart is empty, there were no user sessions during the selected time period.) Groups and filters: Slice and dice the crash data. You can select a group, and then filter to specific data, including: Group the crash list by type of crash, device, location, or other custom attributes. Show open crashes, resolved crashes, or all crashes. Use the time picker to adjust the currently selected time period. Filter by a specific Version or by one or more attribute Filter, such as Last Interaction, App Build, or any of the longer list of standard and custom attributes). The selected filters appear at the top of the UI page. Top five occurrences: Analyze specific characteristics. Use the Top 5 occurrences chart to identify what types of crashes and how many occurred during the selected time period. This chart shows the top five crash occurrences by the group and filters you select. For example, you can group by email address (if instrumented as a custom attribute), then filter down to a specific email to examine that user's experience. To filter or group by other attributes, use the search window, or select any of the available filters. For example, filter by type of crash, device, a specific location, or any custom attributes. To look for other historical patterns, change the selected time period. one.newrelic.com > Mobile > (select an app) > Exceptions > Crash analysis: Here is an example of the Top 5 occurrences chart filtered by the Crash locations group. Select any groups or filters to analyze your crash data any way you want. Queries and image links: Query crash data and share charts with others. Mobile monitoring's Crash analysis charts use default attributes for mobile events, along with any custom attributes you have added to this event type. To view or share the data, click the ellipsis icon. Add to dashboard link: View the chart, and copy it to a new or existing dashboard. View query link: View the NRQL query used to calculate the chart data. Get as image link: Select this option to get a public URL of the chart, then share it using any media. Crash reports: Dive into the interaction trail, thread breakdown, and more. Supplementing the charts, the Crash report table lists crash types by location, and links them to relevant crash report details. Each row helps you find answers to questions such as: How many of this crash type or exception occurred within the selected time period? What is the most recent exception message? Does a specific app version have a higher (or lower) number of users affected? When did the exception first and last occur? one.newrelic.com > Mobile > (select an app) > Exceptions > Crash analysis: Sort on any column to analyze patterns in the Crash reports table, then select any report to review crash details. Sometimes it may be more useful to examine crash report data from lowest to highest. For example: Which exception has the fewest number of occurrences? When did a particular exception start (Earliest occurrence)? You can change the sort order or filter options to focus on just the types of exceptions that matter the most to you and your teams. Crash profiles: Quickly see key differences between crashed and crash-free accounts. Crash profiles provide quick, clear insight into your Mobile crash data by surfacing any anomalies in your mobile application’s performance. Unexpected differences between attributes and behaviors are highlighted, illuminating key differences between crashed and crash-free accounts. You can quickly pinpoint key issues through drill-downs and filters for a fast, streamlined troubleshooting experience. one.newrelic.com > Mobile > (select an app) > Exceptions> Crash analysis > Crash profiles: Compare crashed and crash-free sessions. Crash event trail: See all the events leading up to a crash. The Mobile monitoring crash event trail shows you the events leading up to a crash of a mobile app. These can be events onitors by default, or custom events you've created. For more information, see Crash event trail. Examine crash report details: Export to Xcode or resymbolicate your source code. From the Crash report table, you can drill down into a specific Crash report. From here you can: Examine the interaction trail from session start through the crash event. Explore the related thread breakdown. Select Export crash details so you can examine source code using Xcode. Resymbolicate the crash report for easier debugging. File a ticket, and resolve the crash. one.newrelic.com > Mobile > (select an app) > Crashes > Crash report: This is an example of an interaction trail that includes the option to resymbolicate the crash occurrence. To analyze and debug your source code using Xcode, select Export crash details. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.974304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " there are any unexpected spikes, dips, or patterns with crash time frames, or uneventful periods within the selected time period. Use the groups and filters to examine <em>attributes</em> (for crashes, devices, locations, or other <em>custom</em> <em>attributes</em>) in more detail. Use the Top 5 occurrences chart to identify"
      },
      "id": "58181a9a8e9c0f431dbd4fce"
    },
    {
      "nodeid": 32796,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Plan your cloud adoption",
        "Optimize your cloud native environment",
        "Customer experience improvement: Track experience indicators",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "3. Share dashboards across departments",
        "4. Use data to separate performance by cohort and debug issues at the customer level",
        "For more help"
      ],
      "title": "Customer experience improvement: Track experience indicators",
      "type": "docs",
      "external_id": "4e6a6333e185fe1886b02fa3e5b98a819d9e0f99",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/customer-experience-improvement-track-experience-indicators",
      "published_at": "2020-09-14T02:09:52Z",
      "updated_at": "2020-09-11T00:14:45Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Optimize your cloud native environment",
      "document_type": "page",
      "popularity": 1,
      "info": "The four steps help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience.",
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effects of application and infrastructure performance on your business. A clear understanding of what creates a successful customer experience can help modern software teams become more efficient and boost productivity. An efficient, well-functioning IT culture helps organizations make rapid, frequent releases and product changes. A strong culture also democratizes data beyond the typical backend users, making it available to groups such as customer service, support, sales, and marketing. However, this information enablement is useful only if it serves to optimize customer experience. The four steps outlined here are designed to help you leverage the data you collect to make the greatest possible improvements in your organization’s digital customer experience. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the frontend and backend transactions responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both the frontend and backend, be sure to forward custom attributes from APM to Browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Establish objectives and baselines tutorials, consider what service-level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the ones listed above to measure the impact of your changes and optimizations at a customer level—rather than just measuring pure performance. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could the product team make more informed roadmap decisions? Customer success: Can this data be used to make customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Use data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes. See NRQL alerts will change how you think about using New Relic data for more information. For more help",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.02562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Customer</em> experience improvement: Track experience indicators",
        "sections": "1. Use <em>custom</em> <em>attributes</em> to associate performance data",
        "info": "The four steps help you leverage the data you collect to make the greatest possible improvements in your organization’s digital <em>customer</em> experience.",
        "body": " with <em>custom</em> <em>attributes</em>. If you plan to collect this information in both the frontend and backend, be sure to forward <em>custom</em> <em>attributes</em> from APM to Browser. Here are some common <em>attributes</em> to collect: User ID Organization or customer ID A&#x2F;B testing cohort value High-value customer indicator Purchase"
      },
      "id": "5f5ac17528ccbce4f0532733"
    },
    {
      "nodeid": 16556,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Plan your cloud adoption",
        "Optimize your cloud native environment",
        "Customer experience improvement: track experience indicators",
        "Prerequisites",
        "1. Use custom attributes to associate performance data",
        "2. Create dashboards with performance and business metrics",
        "3. Share dashboards across departments",
        "4. Utilize data to separate performance by cohort and debug issues at the customer level",
        "For more help"
      ],
      "title": "Customer experience improvement: track experience indicators",
      "type": "docs",
      "external_id": "f9dd5a60c37a9ce8e30b061f42dd92b77c97829c",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/Insights-catalyst-dashbaord-1.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/customer-experience-improvement-track-experience-indicators",
      "published_at": "2020-09-14T05:44:31Z",
      "updated_at": "2020-09-10T10:42:56Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Identify and track the key indicators of customer experience to understand the effect of application performance on your business.",
      "body": "This tutorial covers methods to identify and track the key indicators of customer experience and clarifies the effect of application performance on your business. A clear understanding of what creates successful customer experience helps DevOps teams drive greater efficiencies in work efforts and deliver greater productivity. An efficient, well-functioning DevOps culture enables organizations to make rapid, frequent releases and product changes. A strong DevOps culture also democratizes data beyond the typical backend users, and makes it available to groups like customer service, support, sales, and marketing. However, this data information enablement is only useful if its purpose is to improve and optimize customer experience. Prerequisites This tutorial assumes you’ve reviewed the Establish team dashboards tutorial. 1. Use custom attributes to associate performance data In order to relate performance data to user experience, you need to capture information that ties a particular user or customer to the front- and back-end transactions that are responsible for their interactions with your application. In New Relic, you collect this data with custom attributes. If you plan to collect this information in both frontend and backend, be sure to forward custom attributes from APM to Browser. Here are some common attributes to collect: User ID Organization or customer ID A/B testing cohort value High-value customer indicator Purchase value or product IDs (for e-commerce) If you’ve completed the Iterate and measure impact or Establish objectives and baselines tutorials, consider what service level objectives (SLOs) or key metrics you defined in those stages. New Relic recommends including attributes like the above to measure the impact of your changes and optimizations at a customer level—not only a performance level. 2. Create dashboards with performance and business metrics Using the attributes collected in Step 1, build dashboards to examine the impact of performance issues on your users. Additionally, to drive visibility across your teams, add dedicated widgets to the team dashboards you built in the Establish team dashboards . insights.newrelic.com > Dashboards For example, if you were collecting a custom username attribute, you could use NRQL queries like these to create your widgets for your New Relic Insights dashboard: Number of errors by username: SELECT count(*) FROM TransactionError FACET username Median response time by username: SELECT percentile(duration,50) FROM Transaction FACET username Total purchase value in transactions with errors: SELECT sum(purchaseTotal) FROM TransactionError FACET username If you include a FACET clause in your queries, you’ll be able to click into metric results to see corresponding change in the performance data. For more information on faceting, see Linking Between Dashboards to Drill Into Your Data. 3. Share dashboards across departments Dashboards, data, and metrics that nobody looks at or knows about might as well not exist. When considering how, or with whom, to share your dashboards, consider the following questions: Which teams are responsible for applications that have high levels of end-user interaction? What non-engineering teams could benefit from this information? Customer support: Could customer issues be resolved faster? Product/engineering: Could product make more informed roadmap decisions? Customer success: Can this data be used to make our customers more successful? Are there other teams that can benefit from cohort analysis that includes performance metrics? 4. Utilize data to separate performance by cohort and debug issues at the customer level After you create your dashboards, use them to scope issues affecting particular customers or sets of customers. For example, the following widget shows which apps have errors for a particular user: insights.newrelic.com > Dashboards Use attributes that track user and performance to set alerts on high priority users or customers. For example, you could include a WHERE clause in your NRQL queries to scope the results to a set of user IDs or customer IDs. Set alerts on any performance or business metric that is tied to these attributes. See NRQL alerts will change how you think about using New Relic data for more information. For more help",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.85391,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Customer</em> experience improvement: track experience indicators",
        "sections": "1. Use <em>custom</em> <em>attributes</em> to associate performance data",
        "info": "Identify and track the key indicators of <em>customer</em> experience to understand the effect of application performance on your business.",
        "body": ", sales, and marketing. However, this data information enablement is only useful if its purpose is to improve and optimize customer experience. Prerequisites This tutorial assumes you’ve reviewed the Establish team dashboards tutorial. 1. Use <em>custom</em> <em>attributes</em> to associate performance data In order"
      },
      "id": "5f5adb2728ccbc7152532752"
    },
    {
      "image": "https://developer.newrelic.com/static/nerd-days-cd32e6ce7bce9feb13142801151df03c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-16T01:45:36Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-16T01:37:52Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 27 Days : 15 Hours : 1 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 92.469315,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add <em>custom</em> <em>attributes</em>",
        "body": " <em>custom</em> <em>attributes</em> Use <em>custom</em> <em>attributes</em> for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    }
  ],
  "/build-apps/add-time-picker-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-16T01:51:15Z",
      "title": "Build apps",
      "updated_at": "2020-09-16T01:51:15Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.35957,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " <em>app</em> Add a <em>time</em> <em>picker</em> to a sample application 30 min Add a table to your <em>app</em> Add a table to your New Relic One <em>app</em> 30 min Create a custom map view Build an <em>app</em> to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "https://developer.newrelic.com/static/nerd-days-cd32e6ce7bce9feb13142801151df03c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-16T01:45:36Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-16T01:37:52Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 27 Days : 15 Hours : 1 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.24445,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Add a <em>time</em> <em>picker</em> to your <em>app</em>",
        "body": " source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an <em>app</em> to show page view data on a map 20 min Add a <em>time</em> <em>picker</em> to your <em>app</em> Add a <em>time</em> <em>picker</em> to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "Intro to New Relic One API components",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One API components",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-09-16T01:52:27Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One API components",
      "body": "Intro to New Relic One API components To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.91856,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "New Relic One <em>apps</em>",
        "body": ". They can be divided into these categories: <em>PlatformStateContext</em>: provides read access to the platform URL state variables. Example: <em>time</em>Range in the <em>time</em> <em>picker</em>. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2020-09-16T01:52:28Z",
      "updated_at": "2020-08-30T01:43:57Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Add tables to your New Relic One application 30 min Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. git clone https://github.com/newrelic/nr1-how-to.git` cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet` Copy Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. nr1 nerdpack:uuid -gf # Update the app unique ID npm install # Install dependencies nr1 nerdpack:serve # Serve the demo app locally Copy Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the `nerdlets/create-a-table-nerdlet` subdirectory and open the `index.js` file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside of the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.88865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add tables to your New Relic One <em>application</em>",
        "sections": "Add tables to your New Relic One <em>application</em>",
        "info": "Add a table to your New Relic One <em>app</em>.",
        "tags": "table in <em>app</em>",
        "body": " as shown in the example. export default class Nr1HowtoAdd<em>TimePicker</em> extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to&#x2F;create-a-table. Before you can load the demo"
      },
      "id": "5efa989ee7b9d2ad567bab51"
    },
    {
      "category_2": "Network pages",
      "nodeid": 17056,
      "sections": [
        "Mobile monitoring UI",
        "Mobile App pages",
        "Network pages",
        "Exceptions",
        "Usage pages",
        "HTTP requests page",
        "Find and use HTTP requests page",
        "Understand HTTP request data",
        "Group, sort, and filter HTTP requests",
        "View and share HTTP request data",
        "View legacy HTTP requests UI page",
        "For more help"
      ],
      "title": "HTTP requests page",
      "category_0": "Mobile",
      "type": "docs",
      "category_1": "Mobile monitoring UI",
      "external_id": "c062da8810e6a10397d94d4718cc70decde5a0c3",
      "image": "https://docs.newrelic.com/sites/default/files/styles/inline_660px/public/thumbnails/image/screen%20http%20requests%20details_0.png?itok=3PVAFIAQ",
      "url": "https://docs.newrelic.com/docs/mobile-monitoring/mobile-monitoring-ui/network-pages/http-requests-page",
      "published_at": "2020-09-16T01:41:58Z",
      "updated_at": "2020-09-13T20:40:51Z",
      "breadcrumb": "Contents / Mobile / Mobile monitoring UI / Network pages",
      "document_type": "page",
      "popularity": 1,
      "info": "Mobile monitoring's HTTP requests page helps you better understand your mobile app’s HTTP requests and how those network calls are affecting performance.",
      "body": "Mobile monitoring has an HTTP requests UI page that helps you better understand HTTP requests associated with your mobile app and how those network calls are affecting performance. This document describes the Enterprise-level HTTP requests page. Non-Enterprise accounts will see the legacy HTTP requests page. Find and use HTTP requests page To view Mobile monitoring's HTTP requests page: Go to one.newrelic.com > Mobile > (select an app) > Network > HTTP requests. Use our standard page functions to look for trends in the HTTP analysis charts. Target specific request and response attributes by grouping, sorting, and filtering the data. Understand HTTP request data Here are some places to find the most important HTTP request information: Response time chart The response time chart shows how your app's network calls are performing across percentiles. Use it to compare the average response time to the 1st, 50th, and 99th percentile. Percentiles let you filter out outliers that may be making your average response time higher than expected. HTTP errors and network failures chart This chart shows the unsuccessful network calls your app is experiencing. Select the chart title to go to the HTTP errors page for more detail on the errors and failures. Total requests Sort by Total requests to identify which network requests are being used most frequently. The reason this can be helpful is because your slowest network calls may be only infrequently used, while more frequently used requests might be more worthy of optimization even if they are not the slowest. For a description of the non-Enterprise HTTP requests UI page, see Legacy HTTP requests. Group, sort, and filter HTTP requests If you want to... Do this... Group and sort HTTP requests in different ways Make selections from the Group by and Sort by dropdowns. By default, the HTTP requests page is grouped by request domain and sorted by average response time. Filter for specific HTTP requests Select an HTTP request from the Errors and failures list and/or select multiple filters from the Filter dropdown. See or remove applied filters The filters you select are displayed next to the filter dropdown. To clear filters, select the X icon on the filter you want to clear. Change the time window Select a new time period from the time picker dropdown. View information for a specific app version Using the Versions dropdown, select the version for which you want to see charts and lists. View and share HTTP request data To view any HTTP requests chart in Insights: Select ellipses for any chart. Select View query > View in Insights. Optional: Add the data to a dashboard, or share it by using a permalink. To delve deeper into your request data, query MobileRequest events and attributes. View legacy HTTP requests UI page Accounts that do not have an Enterprise-level subscription see a different HTTP requests UI page: View legacy HTTP requests UI To view your top five domains or drill down into details about specific HTTP requests: Go to one.newrelic.com > (select an app) > Network > HTTP requests. Optional: Select the Sort by and Hide < 1% throughput options. To view or hide all requests made by your app, select Expand all or Collapse all. To view details for a specific host or HTTP request (including request time, average throughput, and data transfer), select its name. View legacy drill-down details Use any of New Relic's standard page functions to drill down into detailed information. In addition, from the HTTP requests page, you can drill down into detailed information about specific requests, including: Top five HTTP request times Average throughput Average data transfer one.newrelic.com > Mobile > (select an app) > Network > HTTP requests > (select a request): Here is an example of a selected HTTP request for an app monitored by New Relic Mobile. To view details for the transaction, select App server drill-down. If you want to... Do this View information to a specific version of your app Select Versions from the side bar (if applicable). Change the time period Use the time picker below the New Relic menu bar. View the related app's transaction This feature is not available when the related app has distributed tracing enabled. To view the related app's transaction: Select App server drill-down, then view the Transactions page for the app associated with this HTTP request. To return to the HTTP requests page, select your browser's Back function. View legacy request data You can dig deeper into your request data by querying and charting the MobileRequest event. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.87431,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Mobile <em>App</em> pages",
        "info": "Mobile monitoring&#x27;s HTTP requests page helps you better understand your mobile <em>app’s</em> HTTP requests and how those network calls are affecting performance.",
        "body": " applied filters The filters you select are displayed next to the filter dropdown. To clear filters, select the X icon on the filter you want to clear. Change the <em>time</em> window Select a new <em>time</em> period from the <em>time</em> <em>picker</em> dropdown. View information for a specific <em>app</em> version Using the Versions dropdown"
      },
      "id": "561c91294bb81c21a800026a"
    }
  ],
  "/automate-workflows/5-mins-tag-resources": [
    {
      "image": "https://developer.newrelic.com/static/nerd-days-cd32e6ce7bce9feb13142801151df03c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-16T01:45:36Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-16T01:37:52Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 27 Days : 15 Hours : 1 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.40019,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-16T01:52:28Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-16T01:52:28Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.21712,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using Helm charts",
        "body": " solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly <em>tag</em> resources Add <em>tags</em> to apps for easy filtering 20 min Set up <em>New</em> <em>Relic</em> using Helm charts Learn how to set up <em>New</em> <em>Relic</em> using Helm charts 30 min Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the entire stack See how easy"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Get your application details",
        "Add a simple tag to your application",
        "Bonus step: Create a deployment marker",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2020-09-16T01:49:54Z",
      "updated_at": "2020-08-08T01:41:47Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Get started with the New Relic CLI 20 min Access the New Relic platform from the comfort of your terminal: you can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. Our CLI has been designed for automating common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic personal API Key, which you can create from the Account settings of your New Relic account An instrumented application in your New Relic account Step 1 of 10 Install the New Relic CLI The New Relic CLI can be downloaded via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile Now that you've installed the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. To create your first CLI profile, run the profiles add command. Note that you need to set the region of your New Relic account: use -r to set either us or eu (this is required). # Create the tutorial account for the US region newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_API_KEY -r YOUR_REGION # Set the profile as defaults newrelic profiles default -n tutorial Copy Step 3 of 10 Get your application details In this example, you are going to add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 The New Relic CLI can retrieve your application details as a JSON object. To search for your APM application use the apm application search command. If you get an error, check that the account ID and application name you provided are correct. newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Copy Step 5 of 10 If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example. When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. [ { accountId: YOUR_ACCOUNT_ID, applicationId: YOUR_APP_ID, domain: 'APM', entityType: 'APM_APPLICATION_ENTITY', guid: 'A_LONG_GUID', name: 'NAME_OF_YOUR_APP', permalink: 'https://one.newrelic.com/redirect/entity/A_LONG_GUID', reporting: true, type: 'APPLICATION', }, ]; Copy Step 6 of 10 Add a simple tag to your application Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Let's suppose that you want to add an environment tag to your application. Go ahead and add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command. newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Copy Step 7 of 10 What if you want to add multiple tags? Tag sets come to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags at once to your application, modify and run the following snippet. newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Copy Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 You've created and added some tags to your application, but how do you know they're there? You need to retrieve your application's tags. To retrieve your application's tags, use the entity tags get command. newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Step 9 of 10 Bonus step: Create a deployment marker Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same Application ID from your earlier search. newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Copy Step 10 of 10 Notice that the JSON response includes the revision and timestamp of the deployment. This workflow could be built into a continuous integration or continuous deployment (CI/CD) system to help indicate changes in your application's behavior after deployments. Here is an example. { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands. For example, you could create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.8752,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": " Now that you have the GUID, you can point the <em>New</em> <em>Relic</em> <em>CLI</em> directly at your application. Adding a <em>tag</em> is the simplest way to try out the <em>CLI</em> capabilities (don&#x27;t worry, <em>tags</em> can be deleted by using entity <em>tags</em> delete). Let&#x27;s suppose that you want to add an environment <em>tag</em> to your application. Go ahead"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "nodeid": 34966,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Plan your cloud adoption",
        "Optimize your cloud native environment",
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "2. Take advantage of integrations and existing tools",
        "3. Leverage the power of APIs",
        "For more help"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "external_id": "91b25e8572d235c7f95963650848fc6ab6cf4b39",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/NRCLItool.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation",
      "published_at": "2020-09-13T18:54:57Z",
      "updated_at": "2020-09-10T08:41:00Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Capture tangible, measurable metrics from before and after deployments to optimize your DevOps team. ",
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Read this Best Practices post for more information about automating instrumentation in your pipeline 2. Take advantage of integrations and existing tools It’s always worth taking a little extra time to look for time-saving integrations and tools that can help to achieve your automation goals. For example, you can use IBM’s open-sourced New Relic CLI (command line interface) tool to automate a variety of tasks, such as managing New Relic Synthetics monitors; creating, editing, and deleting New Relic Alerts policies and conditions; and managing user accounts. Use IBM's New Relic CLI tool to manage your Synthetics monitors, alert policies, and user accounts. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards For more help",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 74.123146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> solutions",
        "body": " It’s always worth taking a little extra time to look for time-saving integrations and tools that can help to achieve your automation goals. For example, you can use IBM’s open-sourced <em>New</em> <em>Relic</em> <em>CLI</em> (command line interface) tool to automate a variety of tasks, such as managing <em>New</em> <em>Relic</em> Synthetics",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; Measure DevOps success"
      },
      "id": "5f5e0c14196a67e25fce6a8a"
    },
    {
      "sections": [
        "Explore NerdGraph using the API Explorer",
        "Before you begin",
        "Build a query to retrieve your name",
        "Click the play button to see the result",
        "Add more fields to your query",
        "Experiment with mutations",
        "Tip",
        "Try your NerdGraph query in the terminal",
        "Next steps"
      ],
      "title": "Explore NerdGraph using the API Explorer",
      "type": "developer",
      "tags": [
        "nerdgraph",
        "mutations",
        "nerdgraph query terminal"
      ],
      "external_id": "df1f04edc2336c69769d946edbaf263a5339bc92",
      "image": "https://developer.newrelic.com/static/0ce8c387a290d7fbd6be155322be9bce/bc8d6/create-account.png",
      "url": "https://developer.newrelic.com/collect-data/get-started-nerdgraph-api-explorer/",
      "published_at": "2020-09-16T01:49:54Z",
      "updated_at": "2020-08-21T01:47:54Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Explore NerdGraph, our GraphQL API, and build the queries you need.",
      "body": "Explore NerdGraph using the API Explorer 25 min NerdGraph is New Relic's GraphQL API. It allows you to get all the information you need in a single request. With NerdGraph API Explorer you don't need to know the query format: using the Query Builder you can browse our entire graph and compose queries just by selecting the items you want and filling out their required values. Before you begin Go to api.newrelic.com/graphiql and log in using your New Relic user ID and password: the NerdGraph API Explorer loads up. Make sure you have a valid New Relic API key. You can create one directly from the NerdGraph API Explorer. Step 1 of 5 Build a query to retrieve your name Time for your first NerdGraph query. Search for your name in the New Relic database: Erase everything in the query editor. Select the following fields in the query explorer in this order: actor, user, name. This GraphQL snippet appears in the editor. { actor { user { name } } } Copy Step 2 of 5 Click the play button to see the result With this query, you're telling NerdGraph to retrieve your name. You're asking for the name field, which is nested within the user field. This refers to the user who owns the API key, which in turn is nested within actor. Click the play button to see the result: It has almost the same shape as the request. All the fields in the Query Builder make up what's called the GraphQL schema, which describes all the available data types and their attributes. To learn more about each field, click the Docs button, or hover over a field in the editor. Step 3 of 5 Add more fields to your query Now you can try adding more fields to your query. The simplest way is clicking the fields in the Query Builder: The API Explorer knows where the attributes should go in the query. In the example, you add the account id and email fields. Once again, running the GraphQL query results in just the data you need, without over or under-fetching data. Notice that the id field has an argument: passing arguments is a powerful way of customizing your NerdGraph queries. Every field and object can contain arguments, so instead of running multiple queries, you just compose the one that you need. { actor { user { name email } account(id: 12345678) } } Copy Step 4 of 5 Experiment with mutations In GraphQL, mutations are a way to execute queries with side effects that can alter the data by creating, updating, or deleting objects (Commonly referred to as CRUD operations in REST APIs). Ready for your first mutation? Erase what's in the editor. Scroll down the Query Builder and expand mutation. Select the fields in the following screenshot: In this case, you're trying to add a custom tag to an entity. Notice that the editor complains if you don't select errors: mutations must have a way of telling you how the operation performed in the backend (failed requests result in null responses). Tip Unlike REST, GraphQL APIs like NerdGraph can return partial responses. For example, if you try adding tags to multiple entities, some mutations can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your NerdGraph query in the terminal Let's say that you've built a NerdGraph query you're happy with and you want to test it elsewhere. To capture code-ready queries and mutations: Select the Tools menu. Copy the query as a curl call or as a New Relic CLI command. # curl version curl https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: API_KEY_REDACTED' \\ --data-binary '{\"query\":\"{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id: 12345678)\\n }\\n}\\n\", \"variables\":\"\"}' # New Relic CLI version newrelic nerdgraph query '{ actor { user { name email } account(id: 12345678) } } ' Copy Next steps Now you know the basics of composing and testing NerdGraph queries, but how do you turn them into client or server code? Solutions such as GraphQL Code Generator can help you turn the NerdGraph queries into code for your implementation. Try creating more complex queries by clicking fields and expanding objects in the Query Builder (be careful with mutations though, since they could write data to your account). For more information on NerdGraph and explore other projects from the developer community, check out the threads on the Explorer’s Hub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 68.73528,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Click</em> the play button to see the result",
        "body": " and mutations: Select the Tools menu. Copy the query as a curl call or as a <em>New</em> <em>Relic</em> <em>CLI</em> command. # curl version curl https:&#x2F;&#x2F;api.newrelic.com&#x2F;graphql \\ -H &#x27;Content-Type: application&#x2F;json&#x27; \\ -H &#x27;API-Key: API_KEY_REDACTED&#x27; \\ --data-binary &#x27;{&quot;query&quot;:&quot;{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id"
      },
      "id": "5efa9973196a6791f4766402"
    }
  ],
  "/automate-workflows/get-started-kubernetes": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-16T01:52:28Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-16T01:52:28Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.05295,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up New Relic using the <em>Kubernetes</em> <em>operator</em>",
        "body": " it is to leverage automation in your DevOps environment! 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using the <em>Kubernetes</em> <em>operator</em> Learn how to provision New Relic resources using the <em>Kubernetes</em> <em>operator</em> 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Create NRQL alert conditions",
        "Create NRQL alert condition",
        "Alert threshold types",
        "NRQL alert syntax",
        "Sum of query results (limited or intermittent data)",
        "Offset the query time window",
        "NRQL alert threshold examples",
        "Create a description",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2020-09-14T05:05:47Z",
      "updated_at": "2020-09-03T23:54:56Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can create alert conditions using NRQL queries. Create NRQL alert condition To create a NRQL alert condition: When you start to create a condition, where it prompts you to Select a product, click NRQL. Tips for creating and using a NRQL condition: Topic Tips Condition types NRQL condition types include static, baseline, and outlier. Create a description For some condition types, you can create a Description. Query results Queries must return a number. The condition works by evaluating that returned number against the thresholds you set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Condition settings Use the Condition settings to: Configure whether and how open violations are force-closed. Adjust the evaluation offset. Create a concise and descriptive condition name. (NerdGraph API Only) Provide a text description for the condition that will be included in violations and notifications. Troubleshooting procedures Optional: To include your organization's procedures for handling the incident, add the runbook URL to the condition. Limits on conditions See the maximum values. Health status NRQL alert conditions do not affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you cannot use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. NRQL alert syntax Here is the basic syntax for creating all NRQL alert conditions. Depending on the threshold type, also include a FACET clause as applicable. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Optional Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Static: Optional Baseline: Not allowed Outlier: Required Including a FACET clause in your NRQL syntax depends on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than this number of values, the alert condition cannot be created. If you create the condition and the query returns more than this number later, the alert will fail. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of the one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum, and the preview chart will update accordingly. Offset the query time window Every minute, we evaluate the NRQL query in one-minute time windows. The start time depends on the value you select in the NRQL condition's Advanced settings > Evaluation offset. Example: Using the default time window to evaluate violations With the Evaluation offset at the default setting of three minutes, the NRQL time window applied to your query will be: SINCE 3 minutes ago UNTIL 2 minutes ago If the event type is sourced from an APM language agent and aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend evaluating data from three minutes ago or longer. An offset of less than 3 minutes will trigger violations sooner, but you might see more false positives and negatives due to data latency. For cloud data, such as AWS integrations, you may need an offset longer than 3 minutes. Check our AWS polling intervals documentation to determine your best setting. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Create a description You can define a description that passes useful information downstream for better violation responses or for use by downstream systems. For details, see Description. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.29056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "sections": "Create <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "info": "How to define thresholds that trigger <em>alert</em> notifications based on your <em>NRQL</em> queries.",
        "category_0": "<em>Alerts</em> and Applied intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "category_2": "<em>Alert</em> <em>conditions</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>alerts</em>-applied-intelligence&#x2F;new-relic-<em>alerts</em>&#x2F;<em>alert</em>-<em>conditions</em>&#x2F;create-<em>nrql</em>-<em>alert</em>-<em>conditions</em>",
        "body": "You can create <em>alert</em> <em>conditions</em> using <em>NRQL</em> queries. Create <em>NRQL</em> <em>alert</em> condition To create a <em>NRQL</em> <em>alert</em> condition: When you start to create a condition, where it prompts you to Select a product, click <em>NRQL</em>. Tips for creating and using a <em>NRQL</em> condition: Topic Tips Condition types <em>NRQL</em> condition types",
        "breadcrumb": "Contents &#x2F; Alerts and Applied intelligence &#x2F; New Relic Alerts &#x2F; <em>Alert</em> <em>conditions</em>"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 7391,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "View entity health status and find entities without alert conditions",
        "Exceptions",
        "Color-coded health status",
        "Example: App without conditions",
        "Example: App with conditions",
        "For more help"
      ],
      "title": "View entity health status and find entities without alert conditions",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "16c3fc543366aed467c2219a18774c5220117948",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/view-entity-health-status-find-entities-without-alert-conditions",
      "published_at": "2020-09-13T16:34:45Z",
      "updated_at": "2020-09-03T16:22:32Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "The color-coded health status indicates whether app or other entity has any alerts policies assigned to it.",
      "body": "With alerts you can easily tell whether an entity (the target for the notification) has one or more conditions associated with it: If yes, its health status indicator on the selected index (APM, Browser, etc.) will be color-coded to the current state. To view a summary of current alert violations, mouse over its health status indicator. If no, its health status indicator on the selected index will appear grey. To learn more about how conditions and policies work together, see Introduction to important concepts. Exceptions The health status indicator doesn't apply for: NRQL alert conditions Infrastructure entities Dashboards Entities targeted by labels Color-coded health status The index automatically appears when you select the product from the New Relic menu bar. For example, to view the index of APM apps, go to one.newrelic.com, then click APM. The Applications index lists all APM product entities and their current health status. Color Health status Green The entity is fine; We are collecting data that you can view in the appropriate UI. No alert violations are currently reported for it. Yellow A warning threshold has been violated. Red A critical threshold has been violated: Notifications have been sent based on the selected incident rollup preference. The incident appears in the Incidents index. Gray No alerts conditions have been detected for this entity. This could mean alerts are muted, not set up, or the reporting system is down. Example: App without conditions Here's an example of an app listed on the APM index that is not associated with any conditions. Its color-coded health status is light grey, which indicates no alert conditions are set up for that entity. Go to one.newrelic.com, then click Entity explorer: This example shows an app that currently isn't associated with any alerts conditions. Its grey status icon means it doesn't have any conditions. Follow standard procedures to add it to an existing condition or to create a new condition for it. Example: App with conditions Here's an example of an app listed on the APM index that is associated with one or more conditions. Its color-coded health status is green, because we are collecting data for it, and currently there are no Warning (yellow) or Critical (red) violations. Go to one.newrelic.com, then click Entity explorer: This example shows an app that has one or more conditions. Its color-coded health status (green) shows the app hasn't reached any threshold violations. To view the index listing currently open incidents across all products, not just this entity, select View all violations. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 63.9146,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View entity health status and find entities without <em>alert</em> <em>conditions</em>",
        "sections": "<em>Alert</em> <em>conditions</em>",
        "info": "The color-coded health status indicates whether app or other entity has any <em>alerts</em> policies assigned to it.",
        "category_0": "<em>Alerts</em> and Applied intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "category_2": "<em>Alert</em> <em>conditions</em>",
        "body": ", mouse over its health status indicator. If no, its health status indicator on the selected index will appear grey. To learn more about how <em>conditions</em> and policies work together, see Introduction to important concepts. Exceptions The health status indicator doesn&#x27;t apply for: <em>NRQL</em> <em>alert</em> <em>conditions</em>",
        "breadcrumb": "Contents &#x2F; Alerts and Applied intelligence &#x2F; New Relic Alerts &#x2F; <em>Alert</em> <em>conditions</em>"
      },
      "id": "5f2edf54e7b9d2f64ec9de88"
    },
    {
      "category_2": "Understand and use data",
      "nodeid": 37981,
      "sections": [
        "Elastic Container Service integration",
        "Get started",
        "Install",
        "Understand and use data",
        "Troubleshooting",
        "Recommended ECS alert conditions",
        "Recommended alert conditions",
        "For more help"
      ],
      "title": "Recommended ECS alert conditions",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Elastic Container Service integration",
      "external_id": "304f01e7a5c68e9ef4dc76782eb9ff6847854065",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/elastic-container-service-integration/understand-use-data/ecs-integration-recommended-alert-conditions",
      "published_at": "2020-09-13T16:55:34Z",
      "updated_at": "2020-08-06T00:29:40Z",
      "breadcrumb": "Contents / Integrations / Elastic Container Service integration / Understand and use data",
      "document_type": "page",
      "popularity": 1,
      "info": "Tips for useful alert conditions to set for New Relic's Amazon ECS integration. ",
      "body": "New Relic's ECS integration reports and displays performance data from your Amazon ECS environment. This document provides some recommended alert conditions for monitoring ECS performance. Recommended alert conditions Here are some recommended ECS alert conditions. To add these alerts, go to the Alerts UI and add the following NRQL alert conditions to an existing or new alert policy: High CPU usage NRQL: FROM ContainerSample SELECT cpuUsed / cpuLimitCores Critical: > 90% for 5 minutes High memory usage NRQL: FROM ContainerSample SELECT memoryUsageBytes / memorySizeLimitBytes Critical: > 80% for 5 minutes Restart count NRQL: FROM ContainerSample SELECT max(restartCount) - min(restartCount) Critical: > 5 for 5 minutes For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.621605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "sections": "Recommended ECS <em>alert</em> <em>conditions</em>",
        "info": "Tips for useful <em>alert</em> <em>conditions</em> to set for New Relic&#x27;s Amazon ECS integration. ",
        "body": " to the Alerts UI and add the following <em>NRQL</em> <em>alert</em> <em>conditions</em> to an existing or new <em>alert</em> policy: High CPU usage <em>NRQL</em>: FROM ContainerSample SELECT cpuUsed &#x2F; cpuLimitCores Critical: &gt; 90% for 5 minutes High memory usage <em>NRQL</em>: FROM ContainerSample SELECT memoryUsageBytes &#x2F; memorySizeLimitBytes Critical: &gt; 80"
      },
      "id": "5ee05e9e28ccbcef4f4c8dda"
    },
    {
      "category_2": "Alert conditions",
      "nodeid": 10951,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Baseline rules and settings",
        "For more help"
      ],
      "title": "Create baseline alert conditions",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions",
      "external_id": "0708312e6e3221aa381963e90472d3f7016d4dc6",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-alerts-baseline-thresholds.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions",
      "published_at": "2020-09-13T21:44:00Z",
      "updated_at": "2020-08-15T08:34:17Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to create a baseline alert conditions and set thresholds that adjust to data patterns and fluctuations. ",
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trend s, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: APM: Application metric baseline Browser: Metric baseline NRQL (and then choose a baseline type threshold) Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 60.83992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "<em>Alert</em> <em>conditions</em>",
        "info": "How to create a baseline <em>alert</em> <em>conditions</em> and set thresholds that adjust to data patterns and fluctuations. ",
        "category_0": "<em>Alerts</em> and Applied intelligence",
        "category_1": "New Relic <em>Alerts</em>",
        "category_2": "<em>Alert</em> <em>conditions</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>alerts</em>-applied-intelligence&#x2F;new-relic-<em>alerts</em>&#x2F;<em>alert</em>-<em>conditions</em>&#x2F;create-baseline-<em>alert</em>-<em>conditions</em>",
        "body": " that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for <em>NRQL</em> <em>alert</em> <em>conditions</em>.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline",
        "breadcrumb": "Contents &#x2F; Alerts and Applied intelligence &#x2F; New Relic Alerts &#x2F; <em>Alert</em> <em>conditions</em>"
      },
      "id": "5f2d847b28ccbc876888e004"
    }
  ],
  "/collect-data/collect-data-from-any-source": [
    {
      "category_2": "Ingest APIs",
      "nodeid": 35471,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Ingest APIs",
        "Telemetry SDKs: Report custom telemetry data",
        "Requirements and compatibility",
        "Available libraries",
        "Write your own Telemetry SDK or contribute to an existing one",
        "Integrations built with the Telemetry SDKs",
        "For more help"
      ],
      "title": "Telemetry SDKs: Report custom telemetry data",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "47a4c8f38c1b1674504ea302d865fd499e90ea39",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-started/capabilities/telemetry-sdks-send-custom-telemetry-data-new-relic",
      "published_at": "2020-09-14T02:24:34Z",
      "updated_at": "2020-08-11T01:15:34Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Ingest APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "Report custom telemetry data with New Relic's open-source Telemetry SDKs.",
      "body": "Our Telemetry SDKs are an open source set of API client libraries that send metrics and trace data to the New Relic platform. We offer open-source integrations for telemetry tools like Prometheus, Istio, and OpenCensus that were created using our Telemetry SDKs. If those solutions (or our other integrations) don't meet your needs, you can use the Telemetry SDKs to create your own telemetry data solutions. Requirements and compatibility To build with the Telemetry SDKs, you will need an Event API insert key. New Relic has contributed the Telemetry SDK to the open source community under an Apache 2.0 license. Available libraries The Telemetry SDKs are open source software on GitHub. Use the language-specific GitHub links below to get library details, coding examples, and procedures for how to use the SDKs. We currently support the following libraries, with more to be created in the future: Language Library Supported data types Java Java library on GitHub New Relic Metrics New Relic Traces Node/TypeScript NodeJS library on GitHub New Relic Metrics New Relic Traces Python Python library on GitHub New Relic Metrics New Relic Events New Relic Traces Go Go library on Github New Relic Metrics New Relic Traces .NET .NET library on GitHub .NET package in NuGet New Relic Metrics New Relic Traces For more on the supported data types: Metrics: see the Metric API Traces: see the Trace API Write your own Telemetry SDK or contribute to an existing one If you need a Telemetry SDK in a language that does not currently exist or want to contribute to an existing library, please see the Telemetry SDK specifications. Integrations built with the Telemetry SDKs To see the integrations built using our Telemetry SDKs, see Open source telemetry integrations. For all monitoring solutions, see our integrations page. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.91821,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "sections": "<em>Telemetry</em> <em>SDKs</em>: Report custom <em>telemetry</em> data",
        "info": "Report custom <em>telemetry</em> data with New Relic&#x27;s open-source <em>Telemetry</em> <em>SDKs</em>.",
        "category_0": "<em>Telemetry</em> Data Platform",
        "category_2": "Ingest <em>APIs</em>",
        "body": " Metrics New Relic Traces .NET .NET library on GitHub .NET package in NuGet New Relic Metrics New Relic Traces For more on the supported data types: Metrics: see the <em>Metric</em> <em>API</em> Traces: see the <em>Trace</em> <em>API</em> Write your own <em>Telemetry</em> <em>SDK</em> or contribute to an existing one If you need a <em>Telemetry</em> <em>SDK</em>",
        "breadcrumb": "Contents &#x2F; <em>Telemetry</em> Data Platform &#x2F; Ingest and manage data &#x2F; Ingest APIs"
      },
      "id": "5d89fefbe7b9d2537ed30dc1"
    },
    {
      "category_2": "Get started",
      "nodeid": 36051,
      "sections": [
        "Ingest and manage data",
        "Get started",
        "Understand data",
        "Manage data",
        "Ingest APIs",
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Agent APIs",
        "Telemetry SDKs",
        "APIs for sending metrics, traces, logs, and events",
        "New Relic One applications",
        "For more help"
      ],
      "title": "Get data into New Relic",
      "category_0": "Telemetry Data Platform",
      "type": "docs",
      "category_1": "Ingest and manage data",
      "external_id": "7a413b4d7e5bd81088a08507ae4bad64c7e24b2d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-data-new-relic/getting-started/introduction-new-relic-data-ingest-apis-sdks",
      "published_at": "2020-09-13T19:29:06Z",
      "updated_at": "2020-08-10T23:16:39Z",
      "breadcrumb": "Contents / Telemetry Data Platform / Ingest and manage data / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to how to get data into New Relic. ",
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. To browse all New Relic-built tools and solutions, see New Relic integrations. Agent APIs Some of our monitoring solutions come with APIs and/or SDKs that allow you to customize the data reported and how it reports. For more information, see the relevant product: APM agent APIs Browser API Mobile API Infrastructure monitoring: the Flex integration tool Telemetry SDKs If our more curated solutions don't work for you, our open source Telemetry SDKs let you build your own solution. These SDKs are language wrappers for our data-ingest APIs (below) that let you send telemetry data to New Relic without requiring install of an agent. APIs for sending metrics, traces, logs, and events If our more curated solutions don't work for you, we also have data-ingest APIs: Trace API Event API Metric API Log API To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open source New Relic One apps, or share your own with the open source community. For details, see New Relic One applications. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.79189,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>APIs</em> for sending <em>metrics</em>, <em>traces</em>, logs, and <em>events</em>",
        "category_0": "<em>Telemetry</em> Data Platform",
        "body": " also have data-ingest APIs: <em>Trace</em> <em>API</em> <em>Event</em> <em>API</em> <em>Metric</em> <em>API</em> Log <em>API</em> To learn about the differences between these data types, see Data types. New Relic One applications You can build entirely custom applications that reside in New Relic One and make use of any data you want. You can use existing open",
        "breadcrumb": "Contents &#x2F; <em>Telemetry</em> Data Platform &#x2F; Ingest and manage data &#x2F; Get started"
      },
      "id": "5f24aa60196a67ede394f5f3"
    },
    {
      "category_2": "Custom events",
      "nodeid": 13806,
      "sections": [
        "Event data sources",
        "Default events",
        "Custom events",
        "Report custom event data",
        "Overview of reporting custom events and attributes",
        "Send custom events and attributes",
        "Extend data retention",
        "For more help"
      ],
      "title": "Report custom event data",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Event data sources",
      "external_id": "afb5f5a81ae06b22935d98c470ed9cabd7c9da6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/insights-data-sources/custom-data/report-custom-event-data",
      "published_at": "2020-09-14T00:28:37Z",
      "updated_at": "2020-07-26T05:52:23Z",
      "breadcrumb": "Contents / Insights / Event data sources / Custom events",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the options for sending custom event data to New Relic. ",
      "body": "New Relic products report a variety of default event data to your account. This document will explain how to report your own custom events and attributes. Overview of reporting custom events and attributes Event data is one of the fundamental New Relic data types. Events are reported by most New Relic products, and we give you several options for reporting your own custom events. Reporting custom events allows you to create more useful and customized queries and charts of your data, and is a key part of optimizing how New Relic works for you. Before beginning, it's important to know that reporting a large number of custom events and/or attributes can cause degraded query performance, or cause you to approach or pass data collection rate limits. For optimal performance, first think about what data you want to analyze, and then create only the events and/or attributes necessary to meet these specific goals. Be aware of the following data and subscription requirements for inserting and accessing custom data: Ensure you follow limits and requirements around event/attribute data types, naming syntax, and size. The amount of data you have access to over time depends on your data retention policy. Send custom events and attributes Methods for sending custom events and attributes include: Source How to send custom data APM agent Use APM agent APIs to report custom events and custom attributes. Browser agent Add custom attributes to the PageView event via the Browser API call addCustomAttribute. Send PageAction event and attributes via Browser API. Forward APM agent custom attributes to PageView event. Event API To report custom events not associated with other New Relic products, use the Event API. Infrastructure Add custom attributes to default Infrastructure events. Use the Flex integration tool to report your own custom event data. Mobile agent Use the mobile agent API to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck event via the $util.insights tools. For ways to report other types of custom data, see: Metric API Logs Trace API Extend data retention To learn about how to extend how long events are retained in your account, see Event data retention. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.19327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report custom <em>event</em> data",
        "sections": "<em>Event</em> data sources",
        "info": "An overview of the options for sending custom <em>event</em> data to New Relic. ",
        "category_1": "<em>Event</em> data sources",
        "category_2": "Custom <em>events</em>",
        "body": " the Flex integration tool to report your own custom <em>event</em> data. Mobile <em>agent</em> Use the mobile <em>agent</em> <em>API</em> to send custom events and attributes. Synthetics Add custom attributes to the SyntheticCheck <em>event</em> via the $util.insights tools. For ways to report other types of custom data, see: <em>Metric</em> <em>API</em> Logs <em>Trace</em>",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; <em>Event</em> data sources &#x2F; Custom events"
      },
      "id": "5e8e7f9de7b9d2aa122cf0f6"
    },
    {
      "category_2": "Intro to APIs",
      "nodeid": 15691,
      "sections": [
        "Get started",
        "Intro to APIs",
        "Introduction to New Relic APIs",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "See APIs in action",
        "For more help"
      ],
      "title": "Introduction to New Relic APIs",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "Get started",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/apis/get-started/intro-apis/introduction-new-relic-apis",
      "external_id": "bb3a7314b2407cfa765425553484cb364e27e7e3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/get-started/intro-apis/introduction-new-relic-apis",
      "published_at": "2020-09-15T01:41:39Z",
      "updated_at": "2020-08-10T01:40:52Z",
      "breadcrumb": "Contents / APIs / Get started / Intro to APIs",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to all of the available New Relic APIs. ",
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This section of the docs provides examples and reference documentation for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. While typical REST APIs require loading from multiple URLs, NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. New Relic provides a powerful GraphQL tool to explore the API with embedded schema definitions. To get started, go to api.newrelic.com/graphiql. For sample queries and mutations, use our NerdGraph tutorials. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users. Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. If you implemented the REST API for querying subscription usage data prior to July 10, 2018, those usage-related REST APIs are now deprecated. You should use the Query API, which requires creating an API key. For more on switching to the new API format, see the transition guide. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights API resources for Insights include: Resource Details Insert events API To report custom data use the Event insertion API. Query API To query your Insights data using NRQL-formatted queries, use the Query API. This API can also be used to retrieve subscription usage data. Dashboard API To create, read, update, and delete dashboards, use the Dashboard API. Other New Relic product APIs You can also report custom data from other New Relic features. For more information, see the API sections for other products. NerdGraph You can use NerdGraph (our GraphQL API) to query data with NRQL. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.61281,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>APIs</em>",
        "sections": "<em>Telemetry</em> <em>APIs</em> for core data types",
        "info": "An introduction to all of the available New Relic <em>APIs</em>. ",
        "category_0": "<em>APIs</em>",
        "category_2": "Intro to <em>APIs</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;<em>apis</em>&#x2F;get-started&#x2F;intro-<em>apis</em>&#x2F;introduction-new-relic-<em>apis</em>",
        "body": ". <em>Telemetry</em> APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed <em>agent</em>. Data type Description <em>Trace</em> <em>API</em> Send distributed tracing data to New Relic. <em>Event</em> <em>API</em> Send <em>event</em> data to New"
      },
      "id": "5d4ae71be7b9d211b4d535a4"
    },
    {
      "category_2": "Java agent release notes",
      "nodeid": 36271,
      "sections": [
        "APM agent release notes",
        "Go agent release notes",
        "Java agent release notes",
        ".NET agent release notes",
        "Node.js agent release notes",
        "PHP agent release notes",
        "Python agent release notes",
        "Ruby agent release notes",
        "C SDK release notes",
        "Java Agent 5.8.0",
        "New features",
        "New OSS SDK",
        "Fixes"
      ],
      "title": "Java Agent 5.8.0",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "APM agent release notes",
      "external_id": "bc3a41e5e576ff66be3ecfe7085f2d3c8bbd796d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-580",
      "published_at": "2020-09-14T00:44:41Z",
      "updated_at": "2019-10-31T15:19:35Z",
      "breadcrumb": "Contents / Release notes / APM agent release notes / Java agent release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Released on:  Tuesday, October 29, 2019 - 12:00 Download New features gRPC gRPC error reporting is now configurable Response codes, component type, and method type are now recorded as attributes. The agent now reports the gRPC status code rather than \"translating\" to HTTP status codes. Vert.x The Java agent now provides visibility into your applications built using the Vert.x 3.8. The agent instruments Vert.x Web, Vert.x Core, and Vert.x HTTP client. With this instrumentation, the agent will identify and name your transactions based on Vert.x web routing paths. The agent will also time web handlers, track async handlers, and external calls made with Vert.x HTTP client. XML custom instrumentation The custom XML instrumentation XSD has been enhanced to support now include support for specifying leaf tracers. Class Histogram A new Class Histogram extension is now available to report heap memory details as events. Jedis Added support for Jedis 3.0.0 and higher. You can now see your Jedis calls in breakdowns in the overview chart, entries in the Databases tab, and segments in transaction traces. Lettuce Instrumentation modules for Lettuce 4 and 5 are now available via the Java agent incubator. New OSS SDK We now have an open source Telemetry SDK for Java for sending telemetry data to New Relic. The current SDK supports sending dimensional metrics to the Metric API and spans to the Trace API. Fixes The Solr 7 instrumentation would not report Update JMX metrics. HttpURLConnection instrumentation produced External metrics only when network methods (getInputStream, getResponseCode) are called. MongoDB instrumentation would report duplicate metrics when applications invoked MongoClientOptions.build() more than once.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.53886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Java <em>Agent</em> 5.8.0",
        "sections": "APM <em>agent</em> release notes",
        "category_1": "APM <em>agent</em> release notes",
        "category_2": "Java <em>agent</em> release notes",
        "body": " <em>agent</em> incubator. New OSS <em>SDK</em> We now have an open source <em>Telemetry</em> <em>SDK</em> for Java for sending <em>telemetry</em> data to New Relic. The current <em>SDK</em> supports sending dimensional metrics to the <em>Metric</em> <em>API</em> and spans to the <em>Trace</em> <em>API</em>. Fixes The Solr 7 instrumentation would not report Update JMX metrics",
        "breadcrumb": "Contents &#x2F; Release notes &#x2F; APM <em>agent</em> release notes &#x2F; Java <em>agent</em> release notes"
      },
      "id": "5dbafb88196a67d9b59aa23d"
    }
  ],
  "/build-apps/map-pageviews-by-region": [
    {
      "image": "https://developer.newrelic.com/static/nerd-days-cd32e6ce7bce9feb13142801151df03c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-16T01:45:36Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-16T01:37:52Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 27 Days : 15 Hours : 1 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.31985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create a <em>custom</em> <em>map</em> <em>view</em>",
        "body": " source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a <em>custom</em> <em>map</em> <em>view</em> Build an <em>app</em> to show <em>page</em> <em>view</em> data on a <em>map</em> 20 min Add a time picker to your <em>app</em> Add a time picker to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "category_2": "Installation",
      "nodeid": 36151,
      "sections": [
        "On-host integrations",
        "Get started",
        "Installation",
        "On-host integrations list",
        "Understand and use data",
        "Troubleshooting",
        "Secrets management",
        "Define secrets",
        "Secrets variables",
        "AWS KMS secrets",
        "Vault secrets",
        "tls_config properties",
        "CyberArk command line interface",
        "CyberArk REST API",
        "For more help"
      ],
      "title": "Secrets management",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "On-host integrations",
      "external_id": "3ed4bf692161b620f4768d98b920dfdf102ce524",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/installation/secrets-management",
      "published_at": "2020-09-16T05:40:08Z",
      "updated_at": "2020-09-16T05:40:08Z",
      "breadcrumb": "Contents / Integrations / On-host integrations / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "Use secrets variables in your New Relic infrastructure integration configuration to inject sensitive data that you don’t want in your configuration files.",
      "body": "With secrets management, you can configure on-host integrations with New Relic's infrastructure agent to use sensitive data (such as passwords) without having to write them as plain text into the integration's configuration file. Currently, Hashicorp Vault, AWS KMS, and CyberArk are supported. Define secrets To use secrets in an integration configuration YAML file: Define a variables section, where each entry is a name for a secret object. In each entry, include the source of the secret and the proper configuration to retrieve those secrets. In the integration configuration section, set ${variable.property} placeholders that will be automatically replaced by the properties of the secret object. If the secrets retrieval fails, the integration won't be executed, as the infrastructure agent does not have all the data it requires to execute. For example, the following configuration will retrieve an object named creds from Vault. (You can define the object's name for the secret.) Let's assume that the stored object is a JSON with a property named user and another property named password. We want to use them to set the basic HTTP credentials of the status_url property from an Nginx on-host integration: integration_name: com.newrelic.nginx variables: creds: vault: http: url: http://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true labels: env: production role: load_balancer Secrets variables Define secrets in each integration configuration under a variables section. Each entry is a user-defined secret name that will store the properties of the retrieved secrets. Each variable can contain the following properties: YAML key Description ttl Type: String Amount of time before a secret is refreshed. This can be a number followed by a time unit (s, m or h). Examples: 30s, 10m, 1h Default: 1h aws-kms Type: YAML properties AWS KMS secret retrieval configuration vault Type: Vault Vault secret retrieval configuration cyberark-cli Type: YAML properties CyberArk command line interface configuration cyberark-api Type: YAML properties CyberArk REST API configuration AWS KMS secrets To retrieve your secrets from Amazon KMS, you can set the following properties in your aws-kms section. Not all fields are required. For example, you will need either data, file, or http to provide the encoded KMS string. YAML key Description data Type: String Base64 encoded KMS string to decrypt file Type: String Path to file containing Base64 encoded KMS string to decrypt http Type: YAML properties HTTP configuration to use to request Base64 encoded KMS string to decrypt. For more information, see Vault http. credential_file Type: String Path to AWS credentials file config_file Type: String Path to AWS config file region Type: String AWS KMS region type Type: String (plain, equal, or json) Secret value format: plain: a raw string to be stored directly into the destination variable. equal: a key=property one-line string to be stored as object properties into the destination variable. json: a JSON object to be stored as properties into the destination variable. Secrets of type plain or json use dot notation; for example, ${mysecret.nestedkey}. The following example will allow retrieving a plain password string from AWS KMS. It must be decrypted from the provided data encoded string. variables: myPassword: aws-kms: data: T0hBSStGTEVY region: ap-southeast-2 credential_file: \"./my-aws-credentials-file\" config_file: \"./my-aws-config-file\" type: plain Vault secrets Vault must enable an http field containing the HTTP configuration used to connect to Vault. The http entry can contain the following entries: YAML key Description url Type: String URL to request data from tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers tls_config properties Secrets must use dot notation, for example, ${mysecret.nestedkey}. YAML key Description enable Type: Boolean Enable TLS Default: false insecure_skip_verify Type: Boolean Skip verifying server’s certificate chain and host Default: false min_version Type: UInt16 The minimum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.0) max_version Type: UInt16 The maximum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.3) ca Type: String TLS certificate \"\" The following example will retrieve a secret using a Vault token from a secured server, and skip the server certificates verification: variables: mydata: vault: http: url: https://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token tls_config: insecure_skip_verify: true CyberArk command line interface To retrieve secrets from the CyberArk command line interface (CLI) use the following configuration, all keys are required YAML Key Description cli Type: string Full path to the CyberArk CLI executable Default: \"\" app-id Type: string Application id of the secret holder Default: \"\" safe Type: string Safe containing the secret Default: \"\" folder Type: string Folder containing the secret Default: \"\" object Type: string The object the secret is associated with Default: \"\" The following example will retrieve a CyberArk secret using the command line interface: variables: credentials: cyberark-cli: cli: /full/path/to/clipasswordsdk app-id: my-appid safe: my-safe folder: my-folder object: my-object CyberArk REST API To retrieve secrets using the CyberArk REST API there must be a http key containing the HTTP configuration. The http key contains these sub-keys, only url is required: YAML key Description url Type: String URL to request data from, this key is required Default: none tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers The following example will retrieve a secret using the CyberArk REST API, skipping server certificate verification: variables: credentials: cyberark-api: http: url: https://hostname/AIMWebService/api/Accounts?AppID=myAppID&Query=Safe=mySafe;Object=myObject tls_config: insecure_skip_verify: true For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.87747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ": YAML properties HTTP configuration to use to request Base64 encoded KMS string to decrypt. For more information, see Vault http. credential_file Type: String Path to AWS credentials file config_file Type: String Path to AWS config file <em>region</em> Type: String AWS KMS <em>region</em> type Type: String (plain"
      },
      "id": "5dc2d677e7b9d2d311e4648c"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-09-16T01:47:05Z",
      "updated_at": "2020-08-26T01:47:20Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.39412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "body": ", publish it to New Relic One, and share it with others by subscribing accounts to it. <em>Map</em> pageviews by <em>region</em> takes you through the steps to create one of our popular open source apps. You learn to add a <em>custom</em> query to an <em>app</em> and <em>view</em> it in a table, then add that data to a <em>map</em>. Contribute"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-16T01:48:56Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.39529,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "tags": "new relic one <em>apps</em>",
        "body": " as a nested key-value <em>map</em>. Data is inside documents, which are nested inside collections: { &#x27;Your<em>Nerdpack</em>Uuid&#x27;: { &#x27;collection-1&#x27;: { &#x27;document-1-of-collection-1&#x27;: &#x27;{&quot;lastNumber&quot;: 42, &quot;another&quot;: [1]}&#x27;, &#x27;document-2-of-collection-1&#x27;: &#x27;&quot;userToken&quot;&#x27;, &#x2F;&#x2F; ... }, &#x27;another-collection&#x27;: { &#x27;fruits&#x27;: &#x27;[&quot;pear&quot;, &quot;apple"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubsribe apps",
        "Handle duplicate applications"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-09-16T01:55:54Z",
      "updated_at": "2020-09-02T02:05:55Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. nr1 update Copy Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. nr1 catalog:submit Copy Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubsribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.869194,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "sections": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "info": "Start sharing and using the <em>custom</em> New Relic One <em>apps</em> you build",
        "tags": "publish <em>apps</em>",
        "body": " that you haven&#x27;t subscribed to, some developed by New Relic engineers to provide visualizations we think you&#x27;ll want, like Cloud Optimizer, which analyzes your cloud environment, or <em>PageView</em> <em>Map</em>, which uses Browser events to chart performance across geographies. Your apps in the catalog are created"
      },
      "id": "5efa999de7b9d283e67bab8f"
    }
  ],
  "/build-apps/build-hello-world-app": [
    {
      "sections": [
        "Intro to New Relic One API components",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One API components",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-09-16T01:52:27Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One API components",
      "body": "Intro to New Relic One API components To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 215.39996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to New Relic <em>One</em> API components",
        "sections": "Intro to New Relic <em>One</em> API components",
        "info": "Intro to New Relic <em>One</em> API components",
        "tags": "New Relic <em>One</em> apps",
        "body": ", and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named <em>nr1</em>, which you get when you install the <em>NR1</em> <em>CLI</em>. The <em>nr1</em> components can be divided into several categories: UI components Chart components Query and storage components Platform"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-09-16T01:49:54Z",
      "updated_at": "2020-08-14T01:49:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Copy Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 196.72403,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "sections": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "info": "An overview of the <em>Nerdpack</em> <em>File</em> <em>Structure</em>",
        "tags": "<em>file</em> <em>structure</em>",
        "body": " components, see our app building guides and the New Relic <em>One</em> <em>CLI</em> command reference. <em>Nerdpack</em> <em>file</em> <em>structure</em> When you generate a <em>Nerdpack</em> template using the <em>nr1</em> create command, it has the following <em>file</em> <em>structure</em>: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-16T01:49:54Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.16275,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic <em>One</em> <em>CLI</em> common commands",
        "sections": "New Relic <em>One</em> <em>CLI</em> common commands",
        "info": "An overview of common commands you can use with the New Relic <em>One</em> <em>CLI</em>.",
        "body": " Nerdpacks and their <em>file</em> <em>structure</em>, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. For more on how to set up your Nerdpacks, see our <em>Nerdpack</em> <em>CLI</em> commands. Usage $ <em>nr1</em> create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Permissions for managing applications",
        "New Relic One pricing plan",
        "Original product-based pricing"
      ],
      "title": "Permissions for managing applications",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2020-09-16T01:52:27Z",
      "updated_at": "2020-09-02T02:04:41Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for subscribing to apps",
      "body": "Permissions for managing applications When you create an app, you'll likely want to share it. From New Relic One's Apps page, you can subscribe to apps you create, publish, and deploy, and to other publicly available apps. You must have the Nerdpack manager role to subcribe accounts to apps. Read on to learn about permissions and versions. Permissions for managing applications The Nerdpack manager role is a New Relic add-on role. When you create a Nerdpack, you have the Nerdpack manager role for handling that Nerdpack. New Relic account administrators have the Nerdpack manager role automatically, and can subscribe their accounts to available Nerdpacks. User permissions vary depending on which pricing plan you are on. New Relic One pricing plan For accounts with New Relic One pricing, there are permissions differences for basic users and full users: Full users have the Nerdpack manager role and have full capabilities for creating and managing New Relic One applications, as well as accessing all types of applications in the New Relic One catalog. A basic user can develop and view their own local New Relic One apps, but they cannot: Subscribe other users to apps they’ve created. Access or manage apps in the New Relic One catalog. Access apps in the entity explorer sidebar. Original product-based pricing For accounts on our original product-based pricing, here are access details: Subscribe to publicly available applications To subscribe to publicly available applications, you must have the Nerdpack manager role. Nerdpack manager permissions are automatically assigned to New Relic account owners and admins and can be assigned to individual users. If you aren’t an owner or admin, you can request Nerdpack manager permission, or ask your New Relic admin or owner to subscribe the apps to your account for you. You can add any of the publicly available applications to master accounts or separate sub-accounts on which you have the Nerdpack manager role, or to separate sub-accounts under a master account you own or administer. If you add the application to a master account, the access flows to all of its sub-accounts as well. Subscribe to applications that you create You also must have the Nerdpack manager role to subscribe the applications you create to accounts. Applications that you publish and deploy can only be subscribed to the master account that was used to publish them, or to its sub-accounts. This means you might want a New Relic admin to deploy your applications for you if they need to be available across the organization.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.78366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Permissions for managing <em>applications</em>",
        "sections": "Permissions for managing <em>applications</em>",
        "info": "Learn about permissions for <em>subscribing</em> to apps",
        "tags": "<em>nerdpack</em> manager",
        "body": "Permissions for managing <em>applications</em> When you create an app, you&#x27;ll likely want to share it. From New Relic <em>One</em>&#x27;s Apps page, you can <em>subscribe</em> to apps you create, publish, and deploy, and to other publicly available apps. You must have the <em>Nerdpack</em> manager role to subcribe accounts to apps. Read"
      },
      "id": "5f45bf2864441ffb4dfdcdbb"
    },
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2020-09-16T01:51:15Z",
      "updated_at": "2020-08-14T01:45:09Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "Map page views by region in a custom app 30 min New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: nr1 create --type nerdpack --name pageviews-app Copy Serve the project up to New Relic: cd pageviews-app && nr1 nerdpack:serve Copy Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). const accountId = [Replace with your account ID]; Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. import { TableChart } from `nr1`; Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line: return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; Copy with this export code: export default class PageViewApp extends React.Component { render() { return ( <div className=\"container\"> <div className=\"row\"></div> </div> ); } } Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. .container { width: 100%; height: 99vh; display: flex; flex-direction: column; .row { margin: 10px; display: flex; flex-direction: row; } .chart { height: 250px; } } Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" />; Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. import { TextField } from 'nr1'; Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". <div className=\"row\"> <TextField placeholder=\"US\" onChange={(event) => { this.setState({ countryCode: event.target.value }); }} /> </div>; Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. constructor(props) { super(props); this.state = { countryCode: null } } Copy Then, add a constructor to your render() function. Above return, add: const { countryCode } = this.state; Copy Now add countryCode to your table chart query. <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" />; Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: npm install --save leaflet react-leaflet Copy In your nerdlets styles.scss file, import the Leaflet CSS: @import `~leaflet/dist/leaflet.css`; Copy While you're in styles.scss, fix the width and height of your map: .containerMap { width: 100%; z-index: 0; height: 70vh; } Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. module.exports = { module: { rules: [ { test: /\\.(png|jpe?g|gif)$/, use: [ { loader: 'file-loader', options: {}, }, { loader: 'url-loader', options: { limit: 25000 }, }, ], }, ], }, }; Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. import { Map, CircleMarker, TileLayer } from 'react-leaflet'; Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: import { NerdGraphQuery, Spinner, Button, BlockText } from 'nr1'; Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. mapData() { const { countryCode } = this.state; const query = `{ actor { account(id: 1606862) { mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : ''} LIMIT 1000 \") { results nrql } } } }`; return query; }; Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. getMarkerColor(measure, apdexTarget = 1.7) { if (measure <= apdexTarget) { return '#11A600'; } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { return '#FFD966'; } else { return '#BF0016'; } }; Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. const defaultMapCenter = [10.5731, -7.5898]; Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. <div className=\"row\"> <NerdGraphQuery query={this.mapData()}> {({ loading, error, data }) => { if (loading) { return <Spinner fillContainer />; } if (error) { return 'Error'; } const { results } = data.actor.account.mapData; console.debug(results); return 'Hello'; }} </NerdGraphQuery> </div>; Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: return ( <Map className=\"containerMap\" center={defaultMapCenter} zoom={2} zoomControl> <TileLayer attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" /> {results.map((pt, i) => { const center = [pt.lat, pt.lng]; return ( <CircleMarker key={`circle-${i}`} center={center} color={this.getMarkerColor(pt.y)} radius={Math.log(pt.x) * 3} onClick={() => { alert(JSON.stringify(pt)); }} /> ); })} </Map> ); Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.11425,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Create and serve a new <em>Nerdpack</em>",
        "tags": "<em>nerdpack</em>",
        "body": " look like a series of interactive charts or a map of the world. <em>Nerdpack</em>: New Relic&#x27;s standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see <em>Nerdpack</em> <em>file</em> <em>structure</em>. Launcher: The button on New Relic <em>One</em>"
      },
      "id": "5efa993c196a67066b766469"
    }
  ],
  "/explore-docs/nerdpack-file-structure": [
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Summary",
        "Related information"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2020-09-16T01:51:15Z",
      "updated_at": "2020-08-21T01:45:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Create a \"Hello, World!\" application 15 min Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the NR1 VS Code extension to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: npm start Copy Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: nr1 nerdpack:publish Copy Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: nr1 create Copy Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: nr1 catalog:submit Copy Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it. Related information Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can see it directly on their homepage.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 457.6848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>Nerdpack</em> <em>file</em> <em>structure</em>",
        "body": "!&quot; application The <em>CLI</em> allows you to run a local version of <em>New</em> <em>Relic</em> <em>One</em>. You can develop your application locally before you publish it in <em>New</em> <em>Relic</em> <em>One</em>. If you followed all the steps in the <em>CLI</em> quick start, you now have files under a <em>new</em> directory named after your <em>nerdpack</em> project. Here&#x27;s how you edit"
      },
      "id": "5efa9973196a67d16d76645c"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-09-16T01:47:05Z",
      "updated_at": "2020-08-26T01:47:20Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 318.5841,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": ". At the end of the Quick start, you have a project consisting of the following: A <em>Nerdpack</em> - The package containing all the files required by your application. It contains two types of files that you customize to build your app: <em>Nerdlets</em>, and the <em>launcher</em>. <em>One</em> or more <em>Nerdlet</em> files - A specific UI view"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubsribe apps",
        "Handle duplicate applications"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-09-16T01:55:54Z",
      "updated_at": "2020-09-02T02:05:55Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. nr1 update Copy Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. nr1 catalog:submit Copy Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubsribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 309.5304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "sections": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "info": "Start sharing and using the custom <em>New</em> <em>Relic</em> <em>One</em> apps you build",
        "body": " to the app Handle duplicate applications Before you begin This guide requires the following: A <em>New</em> <em>Relic</em> <em>One</em> app or <em>Nerdpack</em> <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> A <em>Nerdpack</em> manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to <em>New</em> <em>Relic</em> <em>One</em> to test"
      },
      "id": "5efa999de7b9d283e67bab8f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-16T01:49:54Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 304.12497,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common commands",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common commands",
        "info": "An overview of common commands you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": " update Updates to the latest version of the <em>CLI</em>. nr1 create Creates a <em>new</em> component from a template (<em>Nerdpack</em>, <em>Nerdlet</em>, <em>launcher</em>, or catalog). nr1 profiles Manages the profiles you use to run <em>CLI</em> commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-16T01:53:49Z",
      "updated_at": "2020-08-18T01:50:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 282.54712,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " <em>CLI</em> commands to: Generate <em>Nerdpack</em>&#x2F;<em>Nerdlet</em> templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> In <em>New</em> <em>Relic</em>, click Apps and then in the <em>New</em> <em>Relic</em> <em>One</em> catalog area, click the Build"
      },
      "id": "5efa989e28ccbc535a307dd0"
    }
  ],
  "/build-apps/publish-deploy": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-16T01:51:15Z",
      "title": "Build apps",
      "updated_at": "2020-09-16T01:51:15Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.01103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Publish</em> and <em>deploy</em> <em>apps</em>",
        "body": " <em>app</em> <em>Add</em> a time picker to a sample application 30 min <em>Add</em> a table to your <em>app</em> <em>Add</em> a table to your New Relic One <em>app</em> 30 min Create a custom map view Build an <em>app</em> to show page view data on a map 30 min <em>Publish</em> and <em>deploy</em> <em>apps</em> Start sharing the <em>apps</em> you build"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Permissions for managing applications",
        "New Relic One pricing plan",
        "Original product-based pricing"
      ],
      "title": "Permissions for managing applications",
      "type": "developer",
      "tags": [
        "nerdpack manager",
        "permissions",
        "managing apps"
      ],
      "external_id": "c7f4c7fbd9d093d303c7f8268f8560ff9f435230",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/permission-manage-apps/",
      "published_at": "2020-09-16T01:52:27Z",
      "updated_at": "2020-09-02T02:04:41Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn about permissions for subscribing to apps",
      "body": "Permissions for managing applications When you create an app, you'll likely want to share it. From New Relic One's Apps page, you can subscribe to apps you create, publish, and deploy, and to other publicly available apps. You must have the Nerdpack manager role to subcribe accounts to apps. Read on to learn about permissions and versions. Permissions for managing applications The Nerdpack manager role is a New Relic add-on role. When you create a Nerdpack, you have the Nerdpack manager role for handling that Nerdpack. New Relic account administrators have the Nerdpack manager role automatically, and can subscribe their accounts to available Nerdpacks. User permissions vary depending on which pricing plan you are on. New Relic One pricing plan For accounts with New Relic One pricing, there are permissions differences for basic users and full users: Full users have the Nerdpack manager role and have full capabilities for creating and managing New Relic One applications, as well as accessing all types of applications in the New Relic One catalog. A basic user can develop and view their own local New Relic One apps, but they cannot: Subscribe other users to apps they’ve created. Access or manage apps in the New Relic One catalog. Access apps in the entity explorer sidebar. Original product-based pricing For accounts on our original product-based pricing, here are access details: Subscribe to publicly available applications To subscribe to publicly available applications, you must have the Nerdpack manager role. Nerdpack manager permissions are automatically assigned to New Relic account owners and admins and can be assigned to individual users. If you aren’t an owner or admin, you can request Nerdpack manager permission, or ask your New Relic admin or owner to subscribe the apps to your account for you. You can add any of the publicly available applications to master accounts or separate sub-accounts on which you have the Nerdpack manager role, or to separate sub-accounts under a master account you own or administer. If you add the application to a master account, the access flows to all of its sub-accounts as well. Subscribe to applications that you create You also must have the Nerdpack manager role to subscribe the applications you create to accounts. Applications that you publish and deploy can only be subscribed to the master account that was used to publish them, or to its sub-accounts. This means you might want a New Relic admin to deploy your applications for you if they need to be available across the organization.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 73.53078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Permissions for managing <em>applications</em>",
        "sections": "Permissions for managing <em>applications</em>",
        "info": "Learn about permissions for <em>subscribing</em> to <em>apps</em>",
        "tags": "managing <em>apps</em>",
        "body": "Permissions for managing applications When you create an <em>app</em>, you&#x27;ll likely want to share it. From New Relic One&#x27;s <em>Apps</em> page, you can <em>subscribe</em> to <em>apps</em> you create, <em>publish</em>, and <em>deploy</em>, and to other publicly available <em>apps</em>. You must have the Nerdpack manager role to subcribe accounts to <em>apps</em>. Read"
      },
      "id": "5f45bf2864441ffb4dfdcdbb"
    },
    {
      "category_2": "Hosting services",
      "nodeid": 13151,
      "sections": [
        "Node.js agent",
        "Getting started",
        "Installation and configuration",
        "Supported features",
        "Attributes",
        "API guides",
        "Hosting services",
        "Troubleshooting",
        "Install New Relic Node.js agent in GAE flexible environment",
        "Use native deploy",
        "Build a custom runtime",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install New Relic Node.js agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Node.js agent",
      "external_id": "92a838b215a23bd47fcc8b45abdf347c56f720db",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment",
      "published_at": "2020-09-13T23:13:01Z",
      "updated_at": "2020-08-18T06:29:37Z",
      "breadcrumb": "Contents / APM agents / Node.js agent / Hosting services",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your APM's Node.js app in the Google App Engine (GAE) flexible environment. ",
      "body": "With New Relic's Node.js agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Use native deploy To use Google App Engine's \"native mode\" installation with your Node.js app: Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Optional: Set environment variables to configure the Node.js agent's GAE app.yaml file. Use the Google Cloud SDK's gcloud command line tool to deploy GAE apps. To deploy your Node.js app to your initialized GAE flexible environment, run the following command: gcloud --project new-relic-apm-nodejs app deploy Google App Engine automatically includes your Node.js app's newrelic.js configuration file in the deployed package. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. You can deploy the app without any special configuration. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Google App Engine's documentation for Node.js Google App Engine's tutorial to deploy a Node.js app 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Optional: Set environment variables. 3. Configure and deploy The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the Dockerfile, build the container, and deploy your app, follow the GAE procedures for Node.js. Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Node.js agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT To view the logs, use the Cloud Platform Console's Log Viewer. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 34.412266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use native <em>deploy</em>",
        "info": "How to install your APM&#x27;s Node.js <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": ". This document explains how to <em>add</em> New Relic to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime Use native <em>deploy</em> To use Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with your"
      },
      "id": "5972fea707552313d3f9ba8d"
    },
    {
      "category_2": "Hosting services",
      "nodeid": 13866,
      "sections": [
        "Python agent",
        "Getting started",
        "Installation",
        "Configuration",
        "Supported features",
        "Back-end services",
        "Custom instrumentation",
        "API guides",
        "Python agent API",
        "Web frameworks and servers",
        "Hosting services",
        "Attributes",
        "Troubleshooting",
        "Install the Python agent in GAE flexible environment",
        "Deploy using GAE's native support",
        "Build a custom runtime using Docker",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install the Python agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Python agent",
      "external_id": "c1ce9a74f2eccba9cf0cd509a6f15f2d02fabb16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/hosting-services/install-python-agent-gae-flexible-environment",
      "published_at": "2020-09-13T23:16:40Z",
      "updated_at": "2020-08-30T17:24:26Z",
      "breadcrumb": "Contents / APM agents / Python agent / Hosting services",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your Python app in the Google App Engine (GAE) flexible environment. ",
      "body": "With the Python agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding agent data to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in New Relic One. This document explains how to add agent data to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Deploy using GAE's native support When using Google App Engine \"native mode\" installation, you provide your app code and an app.yaml file. Google App Engine then deploys to a standard prebuilt Docker image. For example, to deploy with native support for a Flask/Django app: Follow standard procedures to install the Python agent, including your license key. Set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to newrelic.ini. Once the agent and configuration file have been installed, the Python agent can automatically monitor applications that reside in the GAE flexible environment. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add agent data to your GAE flex app by building a custom runtime for Docker. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Our GAE flex examples on Github for Python Google App Engine's documentation for Python Google App Engine's tutorials to deploy a Python app 1. Set up the GAE project and install dependencies When building a custom runtime using Docker, set the NEW_RELIC_CONFIG_FILE as an environment variable pointing to the Dockerfile instead of to your Python app's newrelic.ini. Follow standard procedures to install the Python agent, including your license key. Follow Google App Engine procedures Python to create a Google Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK also provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: env: flex runtime: custom 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example shows the Python agent installed for an application served with gunicorn. These procedures are similar to the Python quick start guide. The Dockerfile will contain customer-specific code, including Python version, installation requirements, etc). # [START dockerfile] FROM gcr.io/google_appengine/python # Install the fortunes binary from the debian repositories. RUN apt-get update && apt-get install -y fortunes # Optional: Change the -p argument to use Python 2.7. RUN virtualenv /env -p python3.5 # Set virtualenv environment variables. This is equivalent to running # source /env/bin/activate. ENV VIRTUAL_ENV /env ENV PATH /env/bin:$PATH ADD requirements.txt /app/ RUN pip install -r requirements.txt ADD . /app/ CMD NEW_RELIC_CONFIG_FILE=newrelic.ini newrelic-admin run-program gunicorn -b :$PORT main:app # [END dockerfile] 4. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud app deploy Wait until the deployment completes. To open the app in the browser, run the following command: gcloud app browse To view your GAE flex app data, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect Python agent logs to Stackdriver in the Cloud Platform Console, add the following statement to the newrelic.ini configuration: log_file = stderr To view the logs, use the Cloud Platform Console's Log Viewer. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 25.272243,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Deploy</em> using GAE&#x27;s native support",
        "info": "How to install your Python <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": " explains how to <em>add</em> agent data to your GAE flex <em>app</em> using either of these methods: Google <em>App</em> Engine&#x27;s &quot;native mode&quot; installation with a standard GAE runtime Docker installation using a custom runtime <em>Deploy</em> using GAE&#x27;s native support When using Google <em>App</em> Engine &quot;native mode&quot; installation, you provide"
      },
      "id": "5f3fb624196a672fda1cd4a3"
    },
    {
      "category_2": "Installation",
      "nodeid": 13121,
      "sections": [
        "Go agent",
        "Get started",
        "Installation",
        "Configuration",
        "Instrumentation",
        "API guides",
        "Features",
        "Troubleshooting",
        "Install the Go agent in GAE flexible environment",
        "Build a custom runtime using Docker",
        "Recommendation: Disable health checks",
        "Get agent troubleshooting logs from GAE",
        "For more help"
      ],
      "title": "Install the Go agent in GAE flexible environment",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Go agent",
      "external_id": "d6409627d1a1d951d544a84613ad1709456f4560",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/installation/install-go-agent-gae-flexible-environment",
      "published_at": "2020-09-13T23:11:59Z",
      "updated_at": "2020-08-15T09:48:00Z",
      "breadcrumb": "Contents / APM agents / Go agent / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "How to install your New Relic's Go app in the Google App Engine (GAE) flexible environment. ",
      "body": "With our Go agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. Here we explain how to add New Relic to your GAE flex app by configuring a custom runtime, and give an example of deploying a Go app with Docker. The Go agent can run in a GAE flexible environment using a custom runtime. Due to limitations of other environments, do not use the GAE standard environment or Google App Engine's \"native mode\" installation. Build a custom runtime using Docker See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by installing the Go agent, building a custom Go runtime for Docker, and deploying a golang application. For more information about deploying and configuring your Go app in the GAE flexible environment, see: Google App Engine's documentation for Go Google App Engine's tutorials to deploy a Go app 1. Set up the GAE project and install dependencies Follow standard procedures to install the Go agent for your specific app server, including your license key. Follow Google App Engine procedures for Go to create a new Cloud Platform project, create an App Engine application, download and install git, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex 3. Configure a Dockerfile The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. The following Dockerfile example code defines the golang version used. FROM golang:1.8-onbuild CMD go run main.go 4. Build a Docker image To build the Docker image, run the following command. Be sure to include the period at the end of the code, to indicate the current directory contains the build files. docker build --rm -t Docker-image-name . 5. Deploy Docker image to initialized GAE flexible environment To deploy your Docker image to your initialized GAE flexible environment, run the following command: gcloud --project go-app-name app deploy Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Recommendation: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in APM. Recommendation: Configure your app.yaml to disable health checks by adding: health_check: enable_health_check: False Get agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see GAE's documentation for debugging an instance. To redirect New Relic Go agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.yml file to: log_file_name: STDOUT For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 21.3886,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "How to install your New Relic&#x27;s Go <em>app</em> in the Google <em>App</em> Engine (GAE) flexible environment. ",
        "body": " command line tool to manage and <em>deploy</em> GAE <em>apps</em>. 2. Configure your <em>app</em>.yaml The <em>app</em>.yaml configuration file is required for a GAE flexible environment <em>app</em> with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex 3. Configure a Dockerfile The Dockerfile defines the Docker"
      },
      "id": "5f37af50196a67d8f955e63e"
    }
  ],
  "/explore-docs/newrelic-cli": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-16T01:52:28Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-16T01:52:28Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 806.4677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using Helm charts",
        "body": " CloudFormation, and a command-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "image": "https://developer.newrelic.com/static/nerd-days-cd32e6ce7bce9feb13142801151df03c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-16T01:45:36Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-16T01:37:52Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 27 Days : 15 Hours : 1 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 805.8116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "nodeid": 34966,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Plan your cloud adoption",
        "Optimize your cloud native environment",
        "Automate instrumentation",
        "Prerequisite",
        "1. Make instrumentation part of every build",
        "2. Take advantage of integrations and existing tools",
        "3. Leverage the power of APIs",
        "For more help"
      ],
      "title": "Automate instrumentation",
      "type": "docs",
      "external_id": "91b25e8572d235c7f95963650848fc6ab6cf4b39",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/NRCLItool.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/automate-instrumentation",
      "published_at": "2020-09-13T18:54:57Z",
      "updated_at": "2020-09-10T08:41:00Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Capture tangible, measurable metrics from before and after deployments to optimize your DevOps team. ",
      "body": "Replacing manual instrumentation with automated setup benefits you in many ways. Automation can make you faster, and it helps to eliminate fat-finger errors—and more importantly, it improves observability. You'll spend less time instrumenting systems, and reduce toil as your development ecosystem grows. Prerequisite Before starting this tutorial, be sure to complete the Measure code pipeline tutorial. 1. Make instrumentation part of every build Rolling instrumentation into your standard build process makes visibility the default, instead of being viewed as yet another burden on your developers. Modern build tools like Gradle can do almost anything; you can take advantage of that power to instrument your code quickly and efficiently. Read this Best Practices post for more information about automating instrumentation in your pipeline 2. Take advantage of integrations and existing tools It’s always worth taking a little extra time to look for time-saving integrations and tools that can help to achieve your automation goals. For example, you can use IBM’s open-sourced New Relic CLI (command line interface) tool to automate a variety of tasks, such as managing New Relic Synthetics monitors; creating, editing, and deleting New Relic Alerts policies and conditions; and managing user accounts. Use IBM's New Relic CLI tool to manage your Synthetics monitors, alert policies, and user accounts. 3. Leverage the power of APIs Now that you've instrumented your services, you can take advantage of New Relic's REST API to harvest information from your instrumentation and to manage your monitoring process. The New Relic API Explorer can help you to determine the cURL request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. The New Relic documentation includes a wealth of additional information on APIs that you can use to automate a number of important tasks, including: APIs to set up alert conditions APIs to define synthetic monitors APIs to create dashboards For more help",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 741.23157,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> solutions",
        "body": " It’s always worth taking a little extra time to look for time-saving integrations and tools that can help to achieve your automation goals. For example, you can use IBM’s open-sourced <em>New</em> <em>Relic</em> <em>CLI</em> (command line interface) tool to automate a variety of tasks, such as managing <em>New</em> <em>Relic</em> Synthetics",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; Measure DevOps success"
      },
      "id": "5f5e0c14196a67e25fce6a8a"
    },
    {
      "image": "https://newrelic.com/content/dam/new-relic/opengraph/NROG_Image.png",
      "url": "https://newrelic.com/resources/webinars/Build-nerdlet-New-Relic-One-programmability-EMEA-200520?video=past-webinar",
      "sections": [
        "During the webinar you will learn:",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-09-13T14:31:28Z",
      "title": "Build a Nerdlet with New Relic One Programmability",
      "updated_at": "2020-09-03T06:40:46Z",
      "type": "storefront",
      "external_id": "8e6acf295e0921c9d6ddbb015cf6a7ab1829c8cf",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Build a nerdlet with New Relic One programmability Webinar Build a nerdlet with New Relic One programmability   Learn how to build an application using data available in New Relic. Watch this exclusive 60 minute session to get an introduction to the fundamentals of New Relic One programmability and walk through the key concepts of developing New Relic applications. Training is delivered by a New Relic facilitator, who will guide you through the creation of an app from scratch.   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Executing New Relic CLI commands Making GraphQL and web service requests. During the webinar you will learn: Installation of New Relic CLI and environment setup Familiarisation with New Relic One application component model and lifecycle Advanced UI construction and data processing Individual self paced experimentation and Open Source example deployment. Request a demo COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 561.84467,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build a Nerdlet with <em>New</em> <em>Relic</em> One Programmability",
        "body": " command-line interface (<em>CLI</em>) on local workstation Setting <em>New</em> <em>Relic</em> API developer access credentials Executing <em>New</em> <em>Relic</em> <em>CLI</em> commands Making GraphQL and web service requests. During the webinar you will learn: Installation of <em>New</em> <em>Relic</em> <em>CLI</em> and environment setup Familiarisation with <em>New</em> <em>Relic</em> One"
      },
      "id": "5ed2fe08e7b9d263f7c70718"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Note",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-09-16T01:49:54Z",
      "updated_at": "2020-08-14T01:45:08Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). # Create the tutorial account for the US region newrelic profiles add -n tutorial --apiKey API_KEY -r us # Set the profile as default newrelic profiles default -n tutorial Copy Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. # Change the `name` to match any of your existing entities newrelic entity search --name \"test\" Copy Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Note Adding tags is an asynchronous operation: it could take a little while for the tags to get created. # Adding a single tag newrelic entity tags create --guid GUID --tag key:value # Adding multiple tags newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Copy Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 543.31335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the <em>New</em> <em>Relic</em> <em>CLI</em> is a good candidate for automation. In this 5-minute guide, you use the <em>New</em> <em>Relic</em>"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    }
  ],
  "/explore-docs/nr1-cli": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-16T01:48:56Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.05185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to NerdStorage 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-nerdpack/",
      "sections": [
        "New Relic One CLI Nerdpack commands",
        "Command details",
        "nr1 nerdpack:clone",
        "Clone an existing Nerdpack",
        "Usage",
        "Options",
        "nr1 nerdpack:serve",
        "Serve your Nerdpack locally",
        "nr1 nerdpack:uuid",
        "Get your Nerdpack's UUID",
        "nr1 nerdpack:publish",
        "Publish your Nerdpack",
        "nr1 nerdpack:deploy",
        "Deploy your Nerdpack to a channel",
        "nr1 nerdpack:undeploy",
        "Undeploy your Nerdpack"
      ],
      "published_at": "2020-09-16T01:49:54Z",
      "title": "New Relic One CLI Nerdpack commands",
      "updated_at": "2020-08-04T01:44:10Z",
      "type": "developer",
      "external_id": "7c1050a6a8624664b90c15111f7c72e96b2fbe17",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI commands you can use to set up your New Relic One Nerdpacks.",
      "body": "New Relic One CLI Nerdpack commands To set up your Nerdpacks, use the commands below. You can click any command to see its usage options and additional details about the command. Command Description nr1 nerdpack:clone Clones a Nerdpack from a git repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. Command details nr1 nerdpack:clone Clone an existing Nerdpack Duplicates an existing Nerdpack onto your local computer. You can clone an open source Nerdpack from our Open Source GitHub repositories. After choosing a git repository, this command performs the following actions so that you can start using the Nerdpack: Clones the repository. Sets the repository as remote upstream. Installs all of its dependencies (using npm). Generates a new UUID using your profile, and commits it. Usage $ nr1 nerdpack:clone OPTION Options -r, --repo=REPO Repository location (either an HTTPS or SSH path). (Required) -p, --path=PATH Determines the directory to clone to (defaults to the repository name). -f, --force Replaces destination folder if it exists. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:serve Serve your Nerdpack locally Launches a server with your Nerdpack locally on the New Relic One platform, where it can be tested live. To learn more about working with apps locally, see our guide on how to serve, publish, and deploy documentation. Usage $ nr1 nerdpack:serve Options --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:uuid Get your Nerdpack's UUID Prints the UUID (Universal Unique ID) of your Nerdpack, by default. The UUID determines what data the Nerdpack can access and who can subscribe to the Nerdpack. To deploy a Nerdpack you didn't make, you'll have to assign it a new UUID by using the -g or --generate option. For more details, see our GitHub workshop on GitHub. Usage $ nr1 nerdpack:uuid Options --profile=PROFILE The authentication profile you want to use. -f, --force If present, it will override the existing UUID without asking. -g, --generate Generates a new UUID if not available. --verbose Adds extra information to the output. nr1 nerdpack:publish Publish your Nerdpack Publishes your Nerdpack to New Relic. Please note: If no additional parameters are passed in, this command will automatically deploy the Nerdpack onto the DEV channel. If you want to specify your own list of deploy channels, add the --channel option. For example, $ nr1 nerdpack:publish --channel BETA --channel STABLE. If you want to disable this behavior, add -D or --skip-deploy to the command. Then, you can use nr1 nerdpack:deploy to perform a deploy manually. For more on publishing and deploying, see Deploy to New Relic One. Usage $ nr1 nerdpack:publish Options -B, --skip-build Skips the previous build process. -D, --skip-deploy Skips the following deploy process. -c, --channel=DEV/BETA/STABLE Specifies the channel to deploys to. [default: STABLE] -f, --force Forces the publish, overriding any existing version in the registry. --dry-run Undergoes publishing process without actually publishing anything. --extra-metadata-path=extra-metadata-path Specifies a json file .path with extra metadata. [default: extra-metadata.json] --prerelease=STRING The value you enter will be appended to the current version of generated files. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:deploy Deploy your Nerdpack to a channel Deploys a Nerdpack version to a specific channel (DEV, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. For more on publishing and deploying, see Deploy to New Relic One. Usage $ nr1 nerdpack:deploy OPTION Options -c, --channel=DEV/BETA/STABLE Specifies the channel to deploy to. (required) -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to deploy. By default, the command will use the one in package.json. --from-version=VERSION Specifies which version to deploy. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 nerdpack:undeploy Undeploy your Nerdpack Undeploys a Nerdpack version from a specific channel (for example, DEV, BETA, or STABLE). Usage $ nr1 nerdpack:undeploy OPTION Options -c, --channel=DEV/BETA/STABLE Specifies the channel to undeploy from. (required) -i, --nerdpack-id=NERDPACK_ID Specifies the Nerdpack to deploy. By default, the command will use the one in package.json. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.088234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> CLI <em>Nerdpack</em> <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> CLI <em>Nerdpack</em> <em>commands</em>",
        "info": "An overview of the CLI <em>commands</em> you can use to set up your <em>New</em> <em>Relic</em> <em>One</em> <em>Nerdpacks</em>.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> CLI <em>Nerdpack</em> <em>commands</em> To set up your Nerdpacks, use the <em>commands</em> below. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 <em>nerdpack</em>:clone Clones a <em>Nerdpack</em> from a git repository. nr1 <em>nerdpack</em>:serve Serves your <em>Nerdpack</em>"
      },
      "id": "5f28bd6a64441f9817b11a38"
    },
    {
      "sections": [
        "Intro to New Relic One API components",
        "Components of the SDK",
        "UI components",
        "Chart components",
        "Query and storage components",
        "Platform APIs"
      ],
      "title": "Intro to New Relic One API components",
      "type": "developer",
      "tags": [
        "SDK components",
        "New Relic One apps",
        "UI components",
        "chart components",
        "query and storage components",
        "Platform APIs"
      ],
      "external_id": "3620920c26bcd66c59c810dccb1200931b23b8c2",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/intro-to-sdk/",
      "published_at": "2020-09-16T01:52:27Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to New Relic One API components",
      "body": "Intro to New Relic One API components To help you build New Relic One applications, we provide you with the New Relic One SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations, and fetch New Relic or third-party data. Components of the SDK SDK components are located in the Node module package named nr1, which you get when you install the NR1 CLI. The nr1 components can be divided into several categories: UI components Chart components Query and storage components Platform APIs UI components The UI components category of the SDK contains React UI components, including: Text components: These components provide basic font and heading elements. These include HeadingText and BlockText. Layout components: These components give you control over the layout, and help you build complex layout designs without having to deal with the CSS. Layout components include: Grid and GridItem: for organizing more complex, larger scale page content in rows and columns Stack and StackItem: for organizing simpler, smaller scale page content (in column or row) Tabs and TabsItem: group various related pieces of content into separate hideable sections List and ListItem: for providing a basic skeleton of virtualized lists Card, CardHeader and CardBody : used to group similar concepts and tasks together Form components: These components provide the basic building blocks to interact with the UI. These include Button, TextField, Dropdown and DropdownItem, Checkbox, RadioGroup, Radio, and Checkbox. Feedback components: These components are used to provide feedback to users about actions they have taken. These include: Spinnerand Toast. Overlaid components: These components are used to display contextual information and options in the form of an additional child view that appears above other content on screen when an action or event is triggered. They can either require user interaction (like modals), or be augmenting (like a tooltip). These include: Modal and Tooltip. Components suffixed with Item can only operate as direct children of that name without the suffix. For example: GridItem should only be found as a child of Grid. Chart components The Charts category of the SDK contains components representing different types of charts. The ChartGroup component helps a group of related charts share data and be aligned. Some chart components can perform NRQL queries on their own; some accept a customized set of data. Query and storage components The Query components category contains components for fetching and storing New Relic data. The main way to fetch data is with NerdGraph, our GraphQL endpoint. This can be queried using NerdGraphQuery. To simplify use of NerdGraph queries, we provide some components with pre-defined queries. For more on using NerdGraph, see Queries and mutations. We also provide storage for storing small data sets, such as configuration settings data, or user-specific data. For more on this, see NerdStorage. Platform APIs The Platform API components of the SDK enable your application to interact with different parts of the New Relic One platform, by reading and writing state from and to the URL, setting the configuration, etc. They can be divided into these categories: PlatformStateContext: provides read access to the platform URL state variables. Example: timeRange in the time picker. navigation: an object that allows programmatic manipulation of the navigation in New Relic One. Example: opening a new Nerdlet. NerdletStateContext: provides read access to the Nerdlet URL state variables. Example: an entityGuid in the entity explorer. nerdlet: an object that provides write access to the Nerdlet URL state.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 77.43624,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API components",
        "sections": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API components",
        "info": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API components",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>apps</em>",
        "body": "Intro to <em>New</em> <em>Relic</em> <em>One</em> API components To help you build <em>New</em> <em>Relic</em> <em>One</em> applications, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. Here we give you an introduction to the types of API calls and components in the SDK. The SDK provides everything you need to build your Nerdlets, create visualizations"
      },
      "id": "5efa989e28ccbc4071307de5"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-09-16T01:47:05Z",
      "updated_at": "2020-08-26T01:47:20Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.627872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Prepare to build or modify <em>apps</em>",
        "info": "Prepare to build <em>apps</em> and contribute to this site",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom <em>app</em> or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your <em>app</em>"
      },
      "id": "5efa9973e7b9d242237bab39"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-09-16T01:49:54Z",
      "updated_at": "2020-08-14T01:49:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Copy Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 53.845543,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Nerdpack</em> file structure",
        "sections": "<em>Nerdpack</em> file structure",
        "info": "An overview of the <em>Nerdpack</em> File Structure",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> CLI",
        "body": " components, see our <em>app</em> building guides and the <em>New</em> <em>Relic</em> <em>One</em> CLI <em>command</em> reference. <em>Nerdpack</em> file structure When you generate a <em>Nerdpack</em> template using the nr1 create <em>command</em>, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png"
      },
      "id": "5efa989e196a671300766404"
    }
  ],
  "/explore-docs/nr1-common": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-16T01:53:49Z",
      "updated_at": "2020-08-18T01:50:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 179.33368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-16T01:52:28Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-16T01:52:28Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.99318,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using Helm charts",
        "body": " CloudFormation, and a <em>command</em>-line interface. These tools enable you to integrate <em>New</em> <em>Relic</em> into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and <em>CLI</em> guides below, find more automation"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "image": "https://developer.newrelic.com/static/nerd-days-cd32e6ce7bce9feb13142801151df03c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-16T01:45:36Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-16T01:37:52Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 27 Days : 15 Hours : 1 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.08669,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " source APIs, agents, OS emitters - get any data 20 min Automate <em>common</em> tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-09-16T01:48:57Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 146.58182,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-16T01:48:56Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.76569,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> apps",
        "body": "Intro to NerdStorage 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    }
  ],
  "/explore-docs/nr1-catalog": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-16T01:53:49Z",
      "updated_at": "2020-08-18T01:50:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 252.80849,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " <em>CLI</em> <em>commands</em> to: Generate Nerdpack&#x2F;Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the <em>catalog</em> Installing the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> In <em>New</em> <em>Relic</em>, click Apps and then in the <em>New</em> <em>Relic</em> <em>One</em> <em>catalog</em> area, click the Build"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "image": "https://developer.newrelic.com/static/nerd-days-cd32e6ce7bce9feb13142801151df03c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-16T01:45:36Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-16T01:37:52Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 27 Days : 15 Hours : 1 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.67789,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local <em>New</em> <em>Relic</em> <em>One</em> <em>Catalog</em> Start the guide Get inspired 30 min Add a table to your app Add a table to your <em>New</em> <em>Relic</em> <em>One</em> app 15 min Collect data - any"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-16T01:49:54Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.70596,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em> Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubsribe apps",
        "Handle duplicate applications"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-09-16T01:55:54Z",
      "updated_at": "2020-09-02T02:05:55Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. nr1 update Copy Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. nr1 catalog:submit Copy Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubsribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.31352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "sections": "Serve, publish, and deploy your <em>New</em> <em>Relic</em> <em>One</em> app",
        "info": "Start sharing and using the custom <em>New</em> <em>Relic</em> <em>One</em> apps you build",
        "body": " a matter of kicking off a <em>catalog</em> <em>command</em> that validates the information and saves it to the <em>catalog</em>. Step 1 of 3 Update the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> to ensure you&#x27;re working with the latest version. nr1 update Copy Step 2 of 3 Add <em>catalog</em> metadata and screenshots. Run nr1 create and then select <em>catalog</em> to add"
      },
      "id": "5efa999de7b9d283e67bab8f"
    },
    {
      "sections": [
        "Create a \"Hello, World!\" application",
        "Before you begin",
        "Tip",
        "Create a local version of the \"Hello, World!\" application",
        "Publish your application to New Relic",
        "Add details to describe your project",
        "Subscribe accounts to your application",
        "Summary",
        "Related information"
      ],
      "title": "Create a \"Hello, World!\" application",
      "type": "developer",
      "tags": [
        "nr1 cli",
        "Nerdpack file structure",
        "NR One Catalog",
        "Subscribe applications"
      ],
      "external_id": "aa427030169067481fb69a3560798265b6b52b7c",
      "image": "https://developer.newrelic.com/static/cb65a35ad6fa52f5245359ecd24158ff/9466d/hello-world-output-local.png",
      "url": "https://developer.newrelic.com/build-apps/build-hello-world-app/",
      "published_at": "2020-09-16T01:51:15Z",
      "updated_at": "2020-08-21T01:45:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a \"Hello, World!\" app and publish it to New Relic One",
      "body": "Create a \"Hello, World!\" application 15 min Here's how you can quickly build a \"Hello, World!\" application in New Relic One. In these steps, you create a local version of the New Relic One site where you can prototype your application. Then, when you're ready to share the application with others, you can publish it to New Relic One. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and New Relic. To develop projects, you need the New Relic One CLI (command line interface). If you haven't already installed it, do the following: Install Node.js. Complete all the steps in the CLI quick start. For additional details about setting up your environment, see Set up your development environment. Tip Use the NR1 VS Code extension to build your apps. Create a local version of the \"Hello, World!\" application The CLI allows you to run a local version of New Relic One. You can develop your application locally before you publish it in New Relic One. If you followed all the steps in the CLI quick start, you now have files under a new directory named after your nerdpack project. Here's how you edit those files to create a \"Hello, World!\" project: Step 1 of 9 Open a code editor and point it to the new directory named after your nerdpack project (for example, my-awesome-nerdpack). Your code editor displays two artifacts: launchers containing the homepage tile nerdlets containing your application code Step 2 of 9 Expand nerdlets in your code editor, and open index.js. Step 3 of 9 Change the default return message to \"Hello, World!\": import React from 'react'; // https://docs.newrelic.com/docs/new-relic-programmable-platform-introduction export default class MyAwesomeNerdpackNerdletNerdlet extends React.Component { render() { return <h1>\"Hello, World!\"</h1>; } } Copy Step 4 of 9 As an optional step, you can add a custom launcher icon using any image file named icon.png. Replace the default icon.png file under launcher by dragging in your new image file: Step 5 of 9 To change the name of the launcher to something meaningful, in your code editor under launchers, open nr1.json. Step 6 of 9 Change the value for displayName to anything you want as the launcher label, and save the file: { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"INSERT_YOUR_TILE_LABEL_HERE\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy Step 7 of 9 To see your new changes locally, start the Node server with this command in your terminal: npm start Copy Step 8 of 9 Open a browser and go to https://one.newrelic.com/?nerdpacks=local (this url is also shown in the terminal). Step 9 of 9 When the browser opens, click Apps, and then in the Other apps section, click the new launcher for your application. Here's an example where we inserted a leaf icon: After you click the new launcher, your \"Hello, World!\" appears: Publish your application to New Relic Your colleagues can't see your local application, so when you are ready to share it, publish it to the New Relic One catalog. The catalog is where you can find any pre-existing custom applications, as well as any applications you create in your own organization. Step 1 of 4 Execute the following in your terminal: nr1 nerdpack:publish Copy Step 2 of 4 Close your local New Relic One development tab, and open New Relic One. Step 3 of 4 Click the Apps launcher. Step 4 of 4 Under New Relic One catalog, click the launcher for your new application. When your new application opens, notice that it doesn't display any helpful descriptive information. The next section shows you how to add descriptive metadata. Add details to describe your project Now that your new application is in the New Relic One catalog, you can add details that help users understand what your application does and how to use it. Step 1 of 5 Go to your project in the terminal and execute the following: nr1 create Copy Step 2 of 5 Select catalog, which creates a stub in your project under the catalog directory. Here's how the results might look in your code editor: Step 3 of 5 In the catalog directory of your project, add screenshots or various types of metadata to describe your project. For details about what you can add, see Add catalog metadata and screenshots. Step 4 of 5 After you add the screenshots and descriptions you want, execute the following to save your metadata to the catalog: nr1 catalog:submit Copy Step 5 of 5 Return to the catalog and refresh the page to see your new screenshots and metadata describing your project. Subscribe accounts to your application To make sure other users see your application in the catalog, you need to subscribe accounts to the application. Any user with the NerdPack manager or admin role can subscribe to an application from accounts that they have permission to manage. Step 1 of 3 If you're not already displaying your application's description page in the browser, click the launcher for the application in the catalog under Your company applications. Step 2 of 3 On your application's description page, click Add this app. Step 3 of 3 Select the accounts you want to subscribe to the application, and then click Update accounts to save your selections. When you return to the Apps page, you'll see the launcher for your new application. Summary Now that you've completed the steps in this example, you learned the basic steps to: Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can use it. Related information Create a local application. Publish the application to the New Relic One catalog so you can share it with your colleagues. Add details to the project in the catalog so users understand how to use it. Subscribe accounts to your application so other users can see it directly on their homepage.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.06793,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Publish your application to <em>New</em> <em>Relic</em>",
        "info": "Build a &quot;Hello, World!&quot; app and publish it to <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "NR <em>One</em> <em>Catalog</em>",
        "body": ", you can publish it to <em>New</em> <em>Relic</em> <em>One</em>. See the video, which demonstrates the steps in this guide in five minutes. Before you begin To get started, make sure you have accounts in GitHub and <em>New</em> <em>Relic</em>. To develop projects, you need the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (<em>command</em> line interface). If you haven&#x27;t already"
      },
      "id": "5efa9973196a67d16d76645c"
    }
  ],
  "/explore-docs/nr1-config": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-16T01:53:49Z",
      "updated_at": "2020-08-18T01:50:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 210.73929,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "category_2": "Installation",
      "nodeid": 36151,
      "sections": [
        "On-host integrations",
        "Get started",
        "Installation",
        "On-host integrations list",
        "Understand and use data",
        "Troubleshooting",
        "Secrets management",
        "Define secrets",
        "Secrets variables",
        "AWS KMS secrets",
        "Vault secrets",
        "tls_config properties",
        "CyberArk command line interface",
        "CyberArk REST API",
        "For more help"
      ],
      "title": "Secrets management",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "On-host integrations",
      "external_id": "3ed4bf692161b620f4768d98b920dfdf102ce524",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/installation/secrets-management",
      "published_at": "2020-09-16T05:40:08Z",
      "updated_at": "2020-09-16T05:40:08Z",
      "breadcrumb": "Contents / Integrations / On-host integrations / Installation",
      "document_type": "page",
      "popularity": 1,
      "info": "Use secrets variables in your New Relic infrastructure integration configuration to inject sensitive data that you don’t want in your configuration files.",
      "body": "With secrets management, you can configure on-host integrations with New Relic's infrastructure agent to use sensitive data (such as passwords) without having to write them as plain text into the integration's configuration file. Currently, Hashicorp Vault, AWS KMS, and CyberArk are supported. Define secrets To use secrets in an integration configuration YAML file: Define a variables section, where each entry is a name for a secret object. In each entry, include the source of the secret and the proper configuration to retrieve those secrets. In the integration configuration section, set ${variable.property} placeholders that will be automatically replaced by the properties of the secret object. If the secrets retrieval fails, the integration won't be executed, as the infrastructure agent does not have all the data it requires to execute. For example, the following configuration will retrieve an object named creds from Vault. (You can define the object's name for the secret.) Let's assume that the stored object is a JSON with a property named user and another property named password. We want to use them to set the basic HTTP credentials of the status_url property from an Nginx on-host integration: integration_name: com.newrelic.nginx variables: creds: vault: http: url: http://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token instances: - name: nginx-server-metrics command: metrics arguments: status_url: http://${creds.user}:${creds.password}@example.com/status status_module: discover remote_monitoring: true labels: env: production role: load_balancer Secrets variables Define secrets in each integration configuration under a variables section. Each entry is a user-defined secret name that will store the properties of the retrieved secrets. Each variable can contain the following properties: YAML key Description ttl Type: String Amount of time before a secret is refreshed. This can be a number followed by a time unit (s, m or h). Examples: 30s, 10m, 1h Default: 1h aws-kms Type: YAML properties AWS KMS secret retrieval configuration vault Type: Vault Vault secret retrieval configuration cyberark-cli Type: YAML properties CyberArk command line interface configuration cyberark-api Type: YAML properties CyberArk REST API configuration AWS KMS secrets To retrieve your secrets from Amazon KMS, you can set the following properties in your aws-kms section. Not all fields are required. For example, you will need either data, file, or http to provide the encoded KMS string. YAML key Description data Type: String Base64 encoded KMS string to decrypt file Type: String Path to file containing Base64 encoded KMS string to decrypt http Type: YAML properties HTTP configuration to use to request Base64 encoded KMS string to decrypt. For more information, see Vault http. credential_file Type: String Path to AWS credentials file config_file Type: String Path to AWS config file region Type: String AWS KMS region type Type: String (plain, equal, or json) Secret value format: plain: a raw string to be stored directly into the destination variable. equal: a key=property one-line string to be stored as object properties into the destination variable. json: a JSON object to be stored as properties into the destination variable. Secrets of type plain or json use dot notation; for example, ${mysecret.nestedkey}. The following example will allow retrieving a plain password string from AWS KMS. It must be decrypted from the provided data encoded string. variables: myPassword: aws-kms: data: T0hBSStGTEVY region: ap-southeast-2 credential_file: \"./my-aws-credentials-file\" config_file: \"./my-aws-config-file\" type: plain Vault secrets Vault must enable an http field containing the HTTP configuration used to connect to Vault. The http entry can contain the following entries: YAML key Description url Type: String URL to request data from tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers tls_config properties Secrets must use dot notation, for example, ${mysecret.nestedkey}. YAML key Description enable Type: Boolean Enable TLS Default: false insecure_skip_verify Type: Boolean Skip verifying server’s certificate chain and host Default: false min_version Type: UInt16 The minimum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.0) max_version Type: UInt16 The maximum SSL/TLS version that is acceptable Default: 0 (which uses TLS version 1.3) ca Type: String TLS certificate \"\" The following example will retrieve a secret using a Vault token from a secured server, and skip the server certificates verification: variables: mydata: vault: http: url: https://my.vault.host/v1/newengine/data/secret headers: X-Vault-Token: my-vault-token tls_config: insecure_skip_verify: true CyberArk command line interface To retrieve secrets from the CyberArk command line interface (CLI) use the following configuration, all keys are required YAML Key Description cli Type: string Full path to the CyberArk CLI executable Default: \"\" app-id Type: string Application id of the secret holder Default: \"\" safe Type: string Safe containing the secret Default: \"\" folder Type: string Folder containing the secret Default: \"\" object Type: string The object the secret is associated with Default: \"\" The following example will retrieve a CyberArk secret using the command line interface: variables: credentials: cyberark-cli: cli: /full/path/to/clipasswordsdk app-id: my-appid safe: my-safe folder: my-folder object: my-object CyberArk REST API To retrieve secrets using the CyberArk REST API there must be a http key containing the HTTP configuration. The http key contains these sub-keys, only url is required: YAML key Description url Type: String URL to request data from, this key is required Default: none tls_config Type: YAML properties Use the TLS configuration properties headers Type: YAML map Request headers The following example will retrieve a secret using the CyberArk REST API, skipping server certificate verification: variables: credentials: cyberark-api: http: url: https://hostname/AIMWebService/api/Accounts?AppID=myAppID&Query=Safe=mySafe;Object=myObject tls_config: insecure_skip_verify: true For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.74432,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "CyberArk <em>command</em> line interface",
        "info": "Use secrets variables in your <em>New</em> <em>Relic</em> infrastructure integration <em>configuration</em> to inject sensitive data that you don’t want in your <em>configuration</em> files.",
        "body": "With secrets management, you can configure on-host integrations with <em>New</em> <em>Relic</em>&#x27;s infrastructure agent to use sensitive data (such as passwords) without having to write them as plain text into the integration&#x27;s configuration file. Currently, Hashicorp Vault, AWS KMS, and CyberArk are supported"
      },
      "id": "5dc2d677e7b9d2d311e4648c"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-09-16T01:48:57Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.10492,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-16T01:48:56Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.76569,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> apps",
        "body": "Intro to NerdStorage 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "sections": [
        "Set up your development environment",
        "Before you begin",
        "A note on support",
        "Tip",
        "Prepare to build or modify apps",
        "Start building",
        "Contribute to developer.newrelic.com"
      ],
      "title": "Set up your development environment",
      "type": "developer",
      "tags": [
        "developer account",
        "API key",
        "New Relic One CLI"
      ],
      "external_id": "c45638a9cd548d1ffffc9f1c7708f115a92ae04a",
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/set-up-dev-env/",
      "published_at": "2020-09-16T01:47:05Z",
      "updated_at": "2020-08-26T01:47:20Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Prepare to build apps and contribute to this site",
      "body": "Set up your development environment 20 min If you've decided to build a custom app or modify one of our open source apps, you need a few essential tools: The New Relic One command line interface (CLI) An API key, which you get when you download the CLI Depending on what you want to do with your app, you might have some additional setup and configuration. This guide covers: Downloading the New Relic One CLI to build or modify apps Contribute content to this website Before you begin You must have: A github account account - While not strictly necessary for building apps, a GitHub account enables you to download and customize our open source apps, and contribute an open source project. A New Relic developer account - if you don't already have one, you can get a free trial account for developing New Relic applications. npm - If you've installed Node.js, then you already have npm, which is used to share, reuse, and update JavaScript code, and is necessary for working with React components that are the framework for New Relic apps and this website. A note on support Building a New Relic One application is the same as building any JavaScript/React application. We offer support to help with our building tools (our CLI and SDK library). However, we don't offer support for basic JavaScript or React coding questions or issues. For common questions and answers about building, see the Explorers Hub page on building on New Relic One. Tip Use the New Relic One VSCode extension to build your apps. Prepare to build or modify apps Step 1 of 1 Download the CLI and API key. On the Build New Relic One applications page, complete the Quick start steps. These six Quick start steps get you an API key for use with developing apps, and the New Relic One CLI, for building and deploying apps. At the end of the Quick start, you have a project consisting of the following: A Nerdpack - The package containing all the files required by your application. It contains two types of files that you customize to build your app: Nerdlets, and the launcher. One or more Nerdlet files - A specific UI view or window. A Nerdlet is a React JavaScript package that includes an index.js file, a stylesheet, and a JSON-format config file. It can contain any JS functionality (charts, interactive fields, tooltips, etc.). A launcher file: This is the basis for the launcher, which is used to open your application from New Relic One after you publish your app. Start building Step 1 of 1 If you're ready to code, cd to your Nerdpack and get started. If you want to learn more about building applications, try these step-by-step guides: Build a \"Hello, World!\" application shows how to create a little application, publish it to New Relic One, and share it with others by subscribing accounts to it. Map pageviews by region takes you through the steps to create one of our popular open source apps. You learn to add a custom query to an app and view it in a table, then add that data to a map. Contribute to developer.newrelic.com This site is open source, and we want your input. Create a pull request if you see a mistake you know how to fix. Drop us a GitHub issue if you see some content gaps you want us to work on. Or write up a whole new guide if you have one you'd like to share. Read on to learn how. Step 1 of 3 Fork the developer-website GithHub repo. Forking the repo enables you to work on your own copy of the developer.newrelic.com files, and build the site locally. It also enables us to more easily manage incomimg pull requests. On the developer-website page in GitHub, select the Fork button on the top right of the page, choose the account you want to fork to, and wait a few seconds while the fork is created. Sync regularly to keep your fork up to date with changes and additions to the main branch upstream. Step 2 of 3 Make a feature or documentation request. On any page, select the GitHub button at the top of the page, and then select the kind of change you want, and fill out the GitHub form. Step 3 of 3 Contribute a new guide. Check out our contributors guidelines, which will walk you through the process.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 135.14474,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": "Set up your development environment 20 min If you&#x27;ve decided to build a custom app or modify <em>one</em> of our open source apps, you need a few essential tools: The <em>New</em> <em>Relic</em> <em>One</em> <em>command</em> line interface (<em>CLI</em>) An API key, which you get when you download the <em>CLI</em> Depending on what you want to do with your app"
      },
      "id": "5efa9973e7b9d242237bab39"
    }
  ],
  "/automate-workflows/get-started-terraform": [
    {
      "nodeid": 16501,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Plan your cloud adoption",
        "Optimize your cloud native environment",
        "Incident orchestration: Align teams, tools, processes",
        "Prerequisites",
        "1. Assign first responders to team dashboards",
        "2. Determine incident thresholds for alert conditions",
        "3. Ensure alerts have auditable notification channels",
        "4. Automate triage and resolution steps",
        "For more help"
      ],
      "title": "Incident orchestration: Align teams, tools, processes",
      "type": "docs",
      "external_id": "0bec265edc6b4792a80c5a5810e624d5545fbc4e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/incident-orchestration-align-teams-tools-processes",
      "published_at": "2020-09-14T18:53:42Z",
      "updated_at": "2020-09-10T10:39:42Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Incident orchestration is the alignment of teams, tools, and processes to prepare for incidents and outages in your software. ",
      "body": "Incident orchestration is the alignment of teams, tools, and processes to prepare for incidents and outages in your software. The goal is to provide your teams a predictable framework and process to: Maximize efficiency in communication and effort. Minimize the overall impact to your business. Prerequisites Before starting this tutorial, be sure to complete these New Relic tutorials: Establish team dashboards Set up proactive alerting 1. Assign first responders to team dashboards Recommendation: For each team dashboard, make sure: It has an owner who assumes responsibility for the health of the applications and features it monitors. There is no ambiguity about who is responsible for attending to and resolving an alert condition. This policy will vary between organizations depending on size, structure, and culture. For example, some teams may prefer to assign dashboards and alerts based on de-facto features or application ownership. Other teams may prefer to adopt an on-call rotation (often referred to as \"pager duty\"). In on-call rotations, designated team members handle all first-line incident responses, and they resolve or delegate responsibilities based on predetermined incident thresholds. 2. Determine incident thresholds for alert conditions For each of your applications: Identify the thresholds for what is officially considered an incident. As you create alert policies with New Relic Alerts, make sure each set of threshold criteria is context-dependent. Document incident evaluation and known remediation procedures in runbooks. Include links to your runbooks when you define conditions and thresholds for your alert policies. For instance, a certain alert condition may be dismissable during low-traffic periods but require active remediation during peak hours. 3. Ensure alerts have auditable notification channels Recommendation: Make sure that communications during critical incidents take place in easily accessible and highly visible channels. A group chat room dedicated to incident communication is usually a great choice. This allows all stakeholders to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available notification channels in New Relic Alerts. For example, to set up a notification channel in Slack: Make sure your organization has completed New Relic's integration requirements with Slack. In the Slack app, select the dropdown in the top-left corner of the app, and select Customize Slack. Click Configure apps. From the list of app integrations, select New Relic. Expand the instructions for New Relic Alerts, and follow the steps to configure notifications from New Relic. 4. Automate triage and resolution steps Automation of simple or repeatable incident response tasks will increase efficiency and minimize the impact of incidents. With proper automation in place, you can disable or isolate faulty application components as soon as an alert threshold is reached, rather than after a notification has been issued. For example, a team managing an application for a digital media company wants to be able to remove commenting abilities from the website if the system has errors. In this case, they could: Add an endpoint to their front-end web application that will toggle a feature flag enabling or disabling the UI components associated with posting comments on an article. Create an alert policy with a threshold set on the sustained error rate in the commenting service. Assign a webhook notification channel that will send a POST request to this endpoint, as well as to the standard team notification channels. In this scenario, errors in the commenting system will trigger the webhook and remove the commenting UI from the website. Users can still use core functionality of the site without seeing errors generated by the commenting service. The application will maintain a stable but degraded state, allowing the team to focus on recovery without the pressure of preventing users from accessing the site. You can also use webhooks to create issues and action items in ticketing systems that have REST APIs, such as Zendesk. Use New Relic Alerts to create a webhook notification channel, and customize the webhook payload as needed. New Relic also provides integrations for some common ticketing systems. You can use any of the available integrations to file tickets from New Relic APM. For more help",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.784256,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "3. Ensure alerts have auditable <em>notification</em> <em>channels</em>",
        "body": " to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available <em>notification</em> channels in New Relic Alerts. For example, to set up a <em>notification</em> <em>channel</em> in Slack: Make sure your organization has completed New Relic"
      },
      "id": "5f5b2113e7b9d2249dacfd34"
    },
    {
      "category_2": "Alert notifications",
      "nodeid": 6491,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Test alert notification channels",
        "Request the test",
        "Troubleshoot the test results",
        "For more help"
      ],
      "title": "Test alert notification channels",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "fcea4cf920f099fa1fcf7fab3760d57bdf2e02b7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/test-alert-notification-channels",
      "published_at": "2020-09-13T18:31:55Z",
      "updated_at": "2020-08-11T04:16:54Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Alert notifications",
      "document_type": "page",
      "popularity": 1,
      "info": "Be sure to save your alerts notification channels before testing them to make sure they're working properly.",
      "body": "You must save a new notification channel or any changes to an existing notification channel before testing it. Alerts will then send a test message to your chosen destination. Request the test To test a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Follow standard procedures to add a new notification channel or to update an existing notification channel, and save it. Select a notification channel, and then click Envelope Message Icon Send a test notification. Review the test confirmation message, and then click Got it. Troubleshoot the test results A confirmation message will automatically show up in the user interface that indicates where the test was sent (for example, email) and whether it was successful. Also, the test notification message itself includes detailed information, including: The person who requested the test Links to policies for the channel Links to all notification channels and policies for the account When troubleshooting problems, review the test notification message, and verify the setup requirements for the type of notification channel you selected. If necessary, make additional changes to your notification channel, and test it again as needed. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 91.91113,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Test alert <em>notification</em> <em>channels</em>",
        "sections": "Test alert <em>notification</em> <em>channels</em>",
        "info": "Be sure to save your alerts <em>notification</em> <em>channels</em> before testing them to make sure they&#x27;re working properly.",
        "category_2": "Alert <em>notifications</em>",
        "body": "You must save a new <em>notification</em> <em>channel</em> or any changes to an existing <em>notification</em> <em>channel</em> before testing it. Alerts will then send a test message to your chosen destination. Request the test To test a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click Alerts &amp; AI, then click"
      },
      "id": "5f2dbb3664441fd3a556a97c"
    },
    {
      "category_2": "Alert notifications",
      "nodeid": 6481,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Update alert notification channels",
        "Reference for updating channels",
        "Basic process",
        "For more help"
      ],
      "title": "Update alert notification channels",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "external_id": "ee8bce401d0623e8b85d84a6a20bd8a72b9764ef",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/update-alert-notification-channels",
      "published_at": "2020-09-13T18:31:55Z",
      "updated_at": "2020-08-11T06:42:27Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Alert notifications",
      "document_type": "page",
      "popularity": 1,
      "info": "Read about how to update alerts notification channels. ",
      "body": "Depending on the selected channel type, different values appear. Reference for updating channels Here's a quick reference for updating channels which also includes links to more detailed information and procedures. Add or remove policies assigned to a channel To add or remove policies assigned to a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Choose a channel, and then click Alert policies. From the selected policy, use the windows to select, remove, or clear all notification channels. Assign a channel to policies To add a notification channel to one or more policies: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies. Choose a policy, click Notification channels, and then click Add notification channels. Choose a channel, and then click Update policy. Change a channel's name To rename an existing notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, then choose a channel. From the Channel details, change the name (maximum 64 characters) based on the channel type if applicable, and then save. Check for policies assigned to a user To check whether an account user has any policies assigned: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Optional: Search by \"user\" to browse users or a specific username or email. Choose the user, then click Alert policies. Check how many policies are assigned to a channel To check whether a notification channel has any policies assigned: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create more channels To create a new notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. Click New notification channel. Delete a channel To delete a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels. In the list, click the Delete icon. Test a saved channelView assigned alert policies To view the policies assigned to a notification channel: Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, choose a channel, and then click Alert policies. OR To view the notification channels assigned to a policy: Go to one.newrelic.com, in the top nav click Alerts & AI, click Policies, choose a policy, then click Notification channels. Basic process Go to one.newrelic.com, in the top nav click Alerts & AI, click Notification channels, then choose a channel. From the Channel details page, make any necessary changes, and then save. The user interface shows a Last modified time stamp for any changes to policies, including their conditions and notification channels. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.71829,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update alert <em>notification</em> <em>channels</em>",
        "sections": "Update alert <em>notification</em> <em>channels</em>",
        "info": "Read about how to update alerts <em>notification</em> <em>channels</em>. ",
        "category_2": "Alert <em>notifications</em>",
        "body": " to a <em>notification</em> <em>channel</em>: Go to one.newrelic.com, in the top nav click Alerts &amp; AI, click <em>Notification</em> channels. Choose a <em>channel</em>, and then click Alert policies. From the selected policy, use the windows to select, remove, or clear all <em>notification</em> channels. Assign a <em>channel</em> to policies To add"
      },
      "id": "5f2dbad928ccbcb8ca88dfed"
    },
    {
      "category_2": "Alert notifications",
      "nodeid": 6281,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Notification channels: Control where to send alerts",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "Receive mobile push notifications",
        "Acknowledge alert notifications",
        "For more help"
      ],
      "title": "Notification channels: Control where to send alerts",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts",
      "external_id": "65878aca7993877ee748776c87e9225c90687e3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts",
      "published_at": "2020-09-13T18:26:37Z",
      "updated_at": "2020-08-15T11:49:29Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Alert notifications",
      "document_type": "page",
      "popularity": 1,
      "info": "Read about how to set up alerts notification channels so you can be notified when incidents are opened, acknowledged, or closed.",
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User For your convenience, we automatically load all users and their email addresses for the selected account. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. A user channel also sends push notifications to any of the user's registered mobile devices. A device is registered if the user has logged into New Relic using the mobile app on the device. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.010254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> <em>channels</em>: Control where to send alerts",
        "sections": "<em>Notification</em> <em>channels</em>: Control where to send alerts",
        "info": "Read about how to set up alerts <em>notification</em> <em>channels</em> so you can be <em>notified</em> when incidents are opened, acknowledged, or closed.",
        "category_2": "Alert <em>notifications</em>",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;alerts-applied-intelligence&#x2F;new-relic-alerts&#x2F;alert-<em>notifications</em>&#x2F;<em>notification</em>-<em>channels</em>-control-where-send-alerts",
        "body": " account: Go to one.newrelic.com, in the top nav click Alerts &amp; AI, then click <em>Notification</em> channels. Add or remove <em>notification</em> channels To set up a new <em>notification</em> <em>channel</em>: On the <em>Notification</em> channels, click New <em>notification</em> <em>channel</em>. Select the type of <em>channel</em> and complete other required steps"
      },
      "id": "5f2dbad864441fb7d256a9db"
    },
    {
      "nodeid": 32791,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Plan your cloud adoption",
        "Optimize your cloud native environment",
        "Set proactive alerts and align teams, tools, and processes for incident response",
        "Prerequisites",
        "1. Define policies",
        "2. Set specific alerts",
        "3. Identify groups",
        "4. Determine thresholds",
        "5. Set notification channels",
        "6. Automate resolution",
        "7. Establish reviews",
        "8. Fine-tune process",
        "Expert tip",
        "For more help"
      ],
      "title": "Set proactive alerts and align teams, tools, and processes for incident response ",
      "type": "docs",
      "external_id": "6040cb4f86b1533eb31ac0e71e58709d77f79b50",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/proactive-baseline-alerts-devops_0.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/set-proactive-alerts-align-teams-tools-processes-incident-response",
      "published_at": "2020-09-14T10:09:16Z",
      "updated_at": "2020-09-11T00:14:46Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Optimize your cloud native environment",
      "document_type": "page",
      "popularity": 1,
      "info": "Using New Relic's proactive alerting, you can spend less time firefighting and more time deploying significant changes to your product.",
      "body": "The term alerting often carries some negative connotations: many developers correlate alerting with errors, mistakes, and ongoing issues. However, developers who are proactive about alerting, know they don't have to stare at dashboards all day because effective alerts tell them when to check in. Well-defined alerts help you understand the health of your systems, so you can respond to performance problems before they affect your customers. Further, a focused alerts policy helps you pinpoint any degradation that could impact performance in your application or environment. With proactive alerting, you'll decrease user-reported incidents, and your teams will spend less time firefighting and more time deploying significant changes to your product. After you define the right alerts, proper incident orchestration aligns your teams, tools, and processes to prepare for incidents and outages in your software. The goal is to provide your teams a predictable framework and process to: Maximize efficiency in communication and effort. Minimize the overall impact to your business. Prerequisites This tutorial assumes you have: Instrumented your applications in New Relic. Reviewed the Establish objectives and baselines tutorial. Optionally added custom attributes and events. 1. Define policies Define required alerting policies based on SLOs. A service level objective (SLO) is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI). Examples of service level indicators could be average response time, response time percentile, and application availability. SLOs would then clarify a target value for those SLIs such as: Average response time should be less than 200 ms. 95% of requests should be completed within 250 ms. Availability of the service should be 99.99%. These SLOs can also be logically grouped together to provide an overall boolean indicator of whether the service is meeting expectations or not (for example, 95% of requests completed within 250 ms AND availability is 99.99%), which can be helpful for alerting purposes. Use these SLIs as key performance indicators (KPIs) so your team and organization can measure your service and ensure it's meeting customer expectations. By breaking down the quantitative performance metrics that are required of your services, you can then identify what kinds of alerts you should set for each. For instance, you could set an alert to notify you if web transaction times go above half a millisecond, or if the error rate goes higher than 0.20%. However, not every SLO needs to become an alert. A strong alerting strategy takes SLOs and creates a set of simple, actionable alerts. New Relic often finds that our most mature customers set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. As a result, New Relic customers often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. As you design your alerting strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” Example questions and KPI solutions For a simple framework of areas to set alerts for, use the following questions and advised metrics and KPIs: Questions Metrics and KPIs Are we open for business? New Relic Browser and New Relic APM can be used to alert on site availability. How's our underlying infrastructure? Set KPIs for key hardware, network, and storage components. How's the health of our application? Track metrics for JVM performance, queuing, caching, and similar dependencies. How’s the overall quality of our application? Use an Apdex score to quickly access an application’s quality. How are our customers doing? Consider real end-user metrics (Browser or APM), synthetic users (Synthetics), and Apdex scores. How's our overall business doing? Focus on key transactions within an application, and tie them to expected business outcomes to illustrate correlation between your application and business performance. 2. Set specific alerts Set specific alerts for performance, correctness, throughput, availability, and dependencies With New Relic you can set alerts on your instrumented applications, end-user experience, infrastructure, databases, and more. New Relic will alert you if your site's availability dips or if your error rate spikes above acceptable levels, as defined by your SLOs. You can set warning thresholds to monitor issues that may be approaching a critical severity but don't yet warrant a pager notification. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create alert fatigue while thresholds that are too loose will lead to unhappy customers. Baseline alerts allow you to set dynamic thresholds for alerts based on historical performance. Use baselines to tune your alert to the right threshold. For example, an alert in APM can notify incident response teams if web transaction times deviate from historical performance for an allotted amount of time. alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds You can set this same kind of alert in Browser to catch sub-optimal performance. In the following example, we've set both a warning and a violation for throughput: alerts.newrelic.com > (selected alert policy) > (selected alert condition) > Define thresholds As you develop smaller, independent services running on increasingly ephemeral architectures, your environments become significantly more complex. Visibility into outliers can be an important tool for understanding likely performance issues. You should set alerts to automatically fire when you have an outlier, which can indicate misbehaving hosts, load balancers, or apps. For example, a load balancer divides web traffic across five different servers. You can set an alert based on a NRQL query and receive a notification if any server starts getting significantly more or less traffic than the other servers. Here is an example chart: And here's a sample NRQL query: SELECT average(cpuPercent) FROM SystemSample WHERE apmApplicationNames = 'MY-APP-NAME' FACET hostname Now you have set static, baseline, and outlier alerts. This can provide a comprehensive awareness of your ecosystem. Refer to the New Relic Alerts documentation for more details about optimizing your alerts. 3. Identify groups Identify groups to alert, set broadcasting methods, and assign first responders to team dashboards Alerting without the proper broadcasting methods leaves you vulnerable. Your alerting strategy should include a notification channel to ensure the appropriate teams are notified if your application or architecture encounters issues. New Relic has many notification integrations, but we recommend that you start simple and add more complexity later. We recommend that you first send alerts to a group chat channel (for example, using Slack or PagerDuty). Evaluate these alerts in real time for several weeks to understand which alerts are indicative of important or problematic issues. These are the types of alerts that warrant waking someone up. Recommendation: For each team dashboard, make sure: It has an owner who assumes responsibility for the health of the applications and features it monitors. There is no ambiguity about who is responsible for attending to and resolving an alert condition. This policy will vary between organizations depending on size, structure, and culture. For example, some teams may prefer to assign dashboards and alerts based on de-facto features or application ownership. Other teams may prefer to adopt an on-call rotation (often referred to as pager duty). In on-call rotations, designated team members handle all first-line incident responses, and they resolve or delegate responsibilities based on predetermined incident thresholds. 4. Determine thresholds Determine incident thresholds for alert conditions For each of your applications: Identify the thresholds for what is officially considered an incident. Make sure each set of threshold criteria is context-dependent. Document incident evaluation and known remediation procedures in runbooks. Include links to your runbooks when you define conditions and thresholds for your alert policies. For instance, a certain alert condition may be dismissable during low-traffic periods but require active remediation during peak hours. 5. Set notification channels Ensure alerts have auditable notification channels Make sure that communications during critical incidents take place in easily accessible and highly visible channels. A group chat room dedicated to incident communication is usually a great choice. This allows all stakeholders to participate or observe and provides a chronology of notifications, key decisions, and actions for postmortem analysis. Use any of the available notification channels in New Relic Alerts. For example, to set up a notification channel in Slack: Make sure your organization has completed New Relic's integration requirements with Slack. In the Slack app, select the dropdown in the top-left corner of the app, and select Customize Slack. Click Configure apps. From the list of app integrations, select New Relic. Expand the instructions for New Relic Alerts, and follow the steps to configure notifications from New Relic. 6. Automate resolution Automate triage and resolution steps Automation of simple or repeatable incident response tasks will increase efficiency and minimize the impact of incidents. With proper automation in place, you can disable or isolate faulty application components as soon as an alert threshold is reached, rather than after a notification has been issued. For example, a team managing an application for a digital media company wants to be able to remove commenting abilities from the website if the system has errors. In this case, they could: Add an endpoint to their front-end web application that will toggle a feature flag enabling or disabling the UI components associated with posting comments on an article. Create an alert policy with a threshold set on the sustained error rate in the commenting service. Assign a webhook notification channel that will send a POST request to this endpoint, as well as to the standard team notification channels. In this scenario, errors in the commenting system will trigger the webhook and remove the commenting UI from the website. Users can still use core functionality of the site without seeing errors generated by the commenting service. The application will maintain a stable but degraded state, allowing the team to focus on recovery without the pressure of preventing users from accessing the site. You can also use webhooks to create issues and action items in ticketing systems that have REST APIs, such as Zendesk. Use New Relic Alerts to create a webhook notification channel, and customize the webhook payload as needed. New Relic also provides integrations for common ticketing systems. You can use any of these integrations to file tickets from New Relic APM. 7. Establish reviews Establish a post mortem process After the incident has been resolved, key stakeholders and participants must capture accurate and thorough documentation of the incident. At a minimum, we recommend that the retro documentation includes: A root cause analysis A chronology and summary of remediation steps and their result, whether they were successful or not A measure of the impact to the business in terms of user experience and financial losses, if possible Recommendations for system or feature improvements to prevent a recurrence Recommendations for process and communication improvements Store post mortem reports in a highly visible, searchable repository, such as a shared drive folder or wiki. Culturally, it's essential that this process focuses on constructive learning and improvement rather than punishment or blame. Example post mortem report Here is a brief example of a post mortem report: Post mortem Comments Date March 1, 2018 Executive summary From approximately 1:45PM until 2:30PM, users could not add items to their carts, which prevented any checkouts from occurring during the incident period. Root cause We determined that a change was made to the CSS rules on the product detail page that effectively disabled the Add to cart button. Timeline 1:50PM: Successful checkouts < 10 for 5 minutes alert triggered; assigned to Alice. 1:55PM: After reviewing the ecommerce team dashboard, Alice determined that the threshold was breached immediately following a deploy by Bob. She notified him of the incident. 2:00PM: Alice and Bob began troubleshooting. Attempts at recreating the issue in production were successful. 2:20PM: Bob determined that his change to the CSS on the product detail page disabled the Add to cart button. He deployed a hotfix. 2:30PM: Functionality was restored and the incident was resolved. Impact No checkouts were completed during the duration of the incident. Our typical revenue for a Thursday during this timeframe is $30,000. Recommendations We have been discussing implementing New Relic Synthetics for awhile now. If we had a Synthetic check on the checkout process, this issue would have been detected immediately. We should also implement more thorough unit tests in the front-end web app. 8. Fine-tune process Fine-tune alerts and thresholds As you use New Relic to optimize your application and infrastructure performance, tighten your New Relic Alerts policy conditions to keep pace with your improved performance. When rolling out new code or modifications that could negatively impact performance over a period of time, loosen your threshold conditions to allow for these short-term changes. For instance, we recommend using pre-established baselines and thresholds to increase efficiency during high-impact times for your business, such as annual events and major releases. Fine-tuning gives you the flexibility you need to increase efficiencies and extend your notification channels. As noted earlier, we recommend you start with a group chat service when you first establish notifications. Once you've identified other tools you'd like to integrate with, set up a notification channel to maintain your momentum. Tools such as xMatters and PagerDuty provide popular integrations, but don't overlook simple methods, such as webhooks. The goal is to continuously improve your alerting scheme. Be sure to check your alerts and confirm that they're firing regularly and are still relevant for your customer satisfaction metrics. Use the New Relic platform to create dashboards centered around alerts and incidents for the most common policy conditions and violations. insights.newrelic.com > All dashboards > (selected dashboard) Use the New Relic query language and the Insights query API to create your dashboards. For detailed instructions, check out Sending alerts data to Insights. The dashboard above was created using the following NRQL queries. It's recommended you recreate them as needed for your alerting dashboards. Incidents by condition: SELECT count(*) FROM ALERT_NAME WHERE current_state = 'open' FACET condition_name SINCE 1 week ago Incidents by policy: SELECT count(*) FROM ALERT_NAME where current_state = 'open' FACET policy_name SINCE 60 MINUTES AGO TIMESERIES Alert trends over time: SELECT count(*) FROM ALERT_NAME WHERE current_state IS NOT NULL FACET policy_name SINCE 1 week ago TIMESERIES Incident details: SELECT timestamp, incident_id, policy_name, condition_name, details, severity FROM ALERT_NAME SINCE 1 week ago LIMIT 40 Visualizing this data provides a resource you can share with others to refine the alerts and thresholds you're using. Expert tip In addition to instrumenting and measuring application and infrastructure metrics, mature DevOps organizations often measure and optimize the efficiency of incident response processes. For example, you can use webhooks to send alert events to New Relic Insights. This allows you to supplement your team dashboards with New Relic Alerts data. For more help",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.70418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "5. Set <em>notification</em> <em>channels</em>",
        "body": " acceptable levels, as defined by your SLOs. You can set warning thresholds to <em>monitor</em> issues that may be approaching a critical severity but don&#x27;t yet warrant a pager <em>notification</em>. Setting thresholds for when alerts should notify teams can be challenging. Thresholds that are too tight will create"
      },
      "id": "5f5ac17764441ff9d5e067ec"
    }
  ],
  "/build-apps/set-up-dev-env": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-16T01:53:49Z",
      "updated_at": "2020-08-18T01:50:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 205.21431,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference To build a <em>New</em> <em>Relic</em> <em>One</em> app, you must install the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. The <em>CLI</em> helps you build, publish, and manage your <em>New</em> <em>Relic</em> app. We provide a variety of tools for building apps, including the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> (command line interface). This page explains how to use"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "category_2": "Trace API",
      "nodeid": 35381,
      "sections": [
        "Distributed tracing",
        "Get started",
        "Enable and configure",
        "Other requirements",
        "UI and data",
        "Trace API",
        "Troubleshooting",
        "Report traces via the Trace API (New Relic format)",
        "Example: Use your tool’s native sampling",
        "Example: Use Infinite Tracing",
        "JSON requirements and recommendations",
        "Attributes",
        "Required attributes",
        "Highly recommended attributes",
        "Reserved attributes",
        "Other attributes",
        "Explore more about distributed tracing:",
        "For more help"
      ],
      "title": "Report traces via the Trace API (New Relic format)",
      "category_0": "Understand dependencies",
      "type": "docs",
      "category_1": "Distributed tracing",
      "external_id": "ba16f3a71b78e24c23da821b64567398251bb217",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/Infinite_Tracing_GraphiQL_URL_Results_0_0.png",
      "url": "https://docs.newrelic.com/docs/understand-dependencies/distributed-tracing/trace-api/report-new-relic-format-traces-trace-api",
      "published_at": "2020-09-13T19:08:58Z",
      "updated_at": "2020-09-13T19:08:58Z",
      "breadcrumb": "Contents / Understand dependencies / Distributed tracing / Trace API",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic's Trace API: how to report traces using the New Relic format. ",
      "body": "You can send traces in the New Relic format to our Trace API without using a New Relic agent or integration. This is useful if you want to integrate with sources that emit tracing data and require a backend for trace storage. Since distributed systems can generate a lot of trace data, telemetry tools rely on data sampling (filtering) to find the most useful subset of that data. When you send us your trace data, you have two options related to sampling: Use your tool’s native sampling: This approach sends the telemetry data directly to the Trace API and assumes you are relying on your telemetry tool to sample the data before the integration passes the data to New Relic. Even though your tool may be sampling data before the New Relic integration sends it, our Trace API may randomly sample out traces that exceed your rate limit. Use Infinite Tracing (limited release): This approach assumes you turn off sampling in your telemetry tool and then send all your data to a New Relic trace observer in AWS. The trace observer selects the most important and actionable traces using tail-based sampling and then sends your traces to our UI. To send Zipkin-formatted data to the Trace API, see our Zipkin instructions. We'll look at two examples for sending your telemetry data to New Relic, as well as how to structure your data: Example: Use your tool’s native sampling Example: Use Infinite Tracing JSON requirements and recommendations Attributes Example: Use your tool’s native sampling If you are using a telemetry tool that is sampling your trace data, you can send the data directly to New Relic. The following procedure explains how to send a test payload to the Trace API using the newrelic format. For details about how to structure your data, see JSON requirements and recommendations. Get an Insert API key: Go to: one.newrelic.com > account dropdown > Account settings > API keys, and select Insights API keys. If you don't have a key, create a new one by selecting Insert keys +. Insert your Insert API key into the following JSON and then send the JSON to our endpoint. curl -i -H \"Content-Type: application/json\" \\ -H \"Api-Key: YOUR_INSERT_API_KEY\" \\ -H 'Data-Format: newrelic' \\ -H 'Data-Format-Version: 1' \\ -X POST \\ -d '[ { \"common\": { \"attributes\": { \"service.name\": \"Test Service A\", \"host\": \"host123.test.com\" } }, \"spans\": [ { \"trace.id\": \"123456\", \"id\": \"ABC\", \"attributes\": { \"duration.ms\": 12.53, \"name\": \"/home\" } }, { \"trace.id\": \"123456\", \"id\": \"DEF\", \"attributes\": { \"service.name\": \"Test Service A\", \"host\": \"host456.test.com\", \"duration.ms\": 2.97, \"name\": \"/auth\", \"parent.id\": \"ABC\" } } ] } ]' 'https://trace-api.newrelic.com/trace/v1' If you're sending more than one POST, change the trace.id to a unique value. Sending the same payload or span id multiple times for the same trace.id may result in fragmented traces in the UI. If your test returned HTTP/1.1 202 Accepted, go to our UI to see a query of your test data using the span attribute service.name = Test Service A. Traces may take up to one minute to be processed by both the trace observer and the Trace API. Example: Use Infinite Tracing Infinite Tracing can examine all of your data and find the most useful traces. To get the biggest benefit from Infinite Tracing, you should turn off sampling in your telemetry tool and send all your trace data to the trace observer. To start using Infinite Tracing, please go to our sign-up page. The following steps show you how to find or create a trace observer endpoint using GraphQL and how to send a test payload using the newrelic format. For details about how to structure your data, see JSON requirements and recommendations. If you send your data to a trace observer in one of our EU provider regions, you'll still need a US-based New Relic account because the tail-based sampling data is reported to data centers in the United States. If you have questions, contact your account representative. Step A. Open NerdGraph API explorer Prepare to execute some GraphQL: Open NerdGraph API explorer. In the API key dropdown next to Tools, select your personal API key for your account under one of these options: Select an existing API Key Create a new API Key Step B. See if anyone in your organization has already created a trace observer endpoint The following steps show you how to execute a GraphQL query to find out if you can use an existing trace observer in your AWS region. If one isn't available, you can go to Step C. Create a new one. Copy the following query into the middle pane of the NerdGraph API explorer and replace YOUR_ACCOUNT_ID with your account ID (the number next to your account name in NerdGraph API explorer): { actor { account(id: YOUR_ACCOUNT_ID) { edge { tracing { traceObservers { errors { message type } traceObservers { endpoints { agent { host port } endpointType https { host port url } status } id name providerRegion } } } } } } } Click the triangle button to execute the query or press Ctrl+Enter. Check the right pane showing the results: In traceObservers, if you see an AWS region (providerRegion) appropriate for your location, copy its associated https: url value to use later as YOUR_TRACE_OBSERVER_URL in Send test data to the trace observer. If you don't see any values in traceObservers as shown below, continue to Step C. Create a new one. Step C. If you can't find an existing trace observer endpoint, create a new one If you didn't find a trace observer after running the query in the previous section, you need to create one. To do this, you execute a GraphQL mutation that passes your configuration details. Copy the following into the middle pane of the NerdGraph API explorer. mutation { edgeCreateTraceObserver(accountId: YOUR_ACCOUNT_ID, traceObserverConfigs: {name: \"YOUR_DESCRIPTIVE_NAME\", providerRegion: YOUR_PROVIDER_REGION}) { responses { errors { message type } traceObserver { endpoints { agent { host port } endpointType https { host port url } status } id name providerRegion } } } } Insert your own values into the mutation: Value Description YOUR_ACCOUNT_ID Replace this with your account ID (the number next to your account name in NerdGraph API explorer). YOUR_DESCRIPTIVE_NAME Replace this with a name that describes the services that report to this trace observer (for example, production or query services). YOUR_PROVIDER_REGION Replace this with the provider region enum value for your location: AWS_EU_WEST_1 AWS_US_EAST_1 AWS_US_WEST_2 Click the triangle button to execute the mutation or press Ctrl+Enter. In the right pane showing the results, copy the value of https: url to a text file so you can use it later as YOUR_TRACE_OBSERVER_URL in Send test data to the trace observer: Step D. Send data to the trace observer Here's a test that includes a sample payload with one trace and two spans from the same service: Test Service A. Follow these steps to send a test request: Get or generate your Insert API key so you can use it later in the test. Copy the following curl request into a text editor: curl request curl -i -H \"Content-Type: application/json\" \\ -H \"Api-Key: YOUR_INSERT_API_KEY\" \\ -H 'Data-Format: newrelic' \\ -H 'Data-Format-Version: 1' \\ -X POST \\ -d '[ { \"common\": { \"attributes\": { \"environment\": \"staging\" } }, \"spans\": [ { \"trace.id\": \"123456\", \"id\": \"ABC\", \"attributes\": { \"duration.ms\": 12.53, \"host\": \"host123.test.com\", \"name\": \"/home\", \"service.name\": \"Test Service A\" } }, { \"trace.id\": \"123456\", \"id\": \"DEF\", \"attributes\": { \"duration.ms\": 2.97, \"host\": \"host456.test.com\", \"error.message\": \"Invalid credentials\", \"name\": \"/auth\", \"parent.id\": \"ABC\", \"service.name\": \"Test Service B\" } } ] } ]' \\ 'YOUR_TRACE_OBSERVER_URL' Insert your own values into the curl request: Value Description YOUR_INSERT_API_KEY Replace this with your Insert API key (not the same as your personal API key for NerdGraph API explorer) YOUR_TRACE_OBSERVER_URL Replace this with the value under https: url from above. Copy the content of the text editor into a terminal, and then execute the request. If the test does not return HTTP/1.1 202 Accepted indicating success, check the following and try again: Confirm that you substituted the url (not host) value for YOUR_TRACE_OBSERVER_URL. Confirm that you only have single quotes around the value you inserted for YOUR_TRACE_OBSERVER_URL. Check that you are using the Insert API Key (not a license). If your test returned HTTP/1.1 202 Accepted, go to our UI to see a query of your test data using the span attribute service.name = Test Service A. Because the sample payload contains an error attribute, the error sampler will mark it for keeping. If you modify the payload to remove the error attributes, the random sampler may not choose to keep this particular trace. Traces may take up to one minute to be processed by both the trace observer and the Trace API. JSON requirements and recommendations Requirements and guidelines for trace JSON using the newrelic format: Each JSON payload is an array of objects. Each object should contain a required spans key. Each object may contain an optional common key. Use this if you want share information across multiple spans in a object. Any keys on a span have precedence over the same key in the common block. The value for spans key is a list of span objects. Certain attributes are required, and must be included either in the optional common block, or in each span. Recommended and custom attributes may be optionally included in a list of key/value pairs under a key named attributes, in the optional common block and/or in each span. In the following example POST, there are two spans, both of which will have the trace.id 12345 and the custom attribute host: host123.test.com. The first span has no parent.id, so that is the root of the trace; the second span's parent.id points to the ID of the first. [ { \"common\": { \"attributes\": { \"host\": \"host123.test.com\" } }, \"spans\": [ { \"trace.id\": \"12345\", \"id\": \"abc\", \"attributes\": { \"user.email\": \"bob@newr.com\", \"service.name\": \"my-service\", \"duration.ms\": 750, \"name\": \"my-span\" } }, { \"trace.id\": \"12345\", \"id\": \"def\", \"attributes\": { \"parent.id\": \"abc\", \"service.name\": \"second-service\", \"duration.ms\": 750, \"name\": \"second-span\" } } ] } ] Attributes Review the sections below describing the attributes for the attributes block of a newrelic formatted JSON POST. Required attributes Requests without these attributes will be rejected, and an NrIntegrationError will be generated. These are the only attributes that don't belong under attributes. attribute description id string Unique identifier for this span. trace.id string Unique identifier shared by all spans within a single trace. timestamp long The span's start time in Epoch milliseconds. Defaults to the current time in UTC timezone. Highly recommended attributes While not required, these attributes should be included for the best experience with your data. They are included in the attributes section. attribute default description duration.ms float none Duration of this span in milliseconds. name string none The name of this span. parent.id string none The id of the caller of this span. Value is null if this is the root span. Traces without a root span will not displayed. service.name string none The name of the entity that created this span. Reserved attributes These attributes are currently reserved for internal New Relic usage. While they are not explicitly blocked, we recommend not using them. attribute default description entity.name string service.name This is derived from the service.name attribute. entity.type string service The entity type is assumed to be a service. entity.guid string None The entity.guid is a derived value that uniquely identifies the entity in New Relic's backend. Other attributes You can add any arbitrary attributes you want, with the exception of the restricted attributes. For example, you might want to add attributes like customer.id or user.id to help you analyze your trace data. To learn how to control how spans appear in New Relic (for example, adding errors or setting a span as a datastore span), see Decorate spans. Explore more about distributed tracing: Learn where Trace API data shows up in the UI. Learn how to decorate spans for a richer, more detailed UI experience. For example, you can have spans show up as datastore spans or display errors. Learn about general data limits, required metadata, and response validation. If you don't see your trace data, see Troubleshooting. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 130.15356,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report traces via the Trace <em>API</em> (<em>New</em> <em>Relic</em> format)",
        "sections": "Report traces via the Trace <em>API</em> (<em>New</em> <em>Relic</em> format)",
        "info": "For <em>New</em> <em>Relic&#x27;s</em> Trace <em>API</em>: how to report traces using the <em>New</em> <em>Relic</em> format. ",
        "category_2": "Trace <em>API</em>",
        "body": ". Get an Insert <em>API</em> <em>key</em>: Go to: <em>one</em>.newrelic.com &gt; <em>account</em> dropdown &gt; <em>Account</em> settings &gt; <em>API</em> keys, and select Insights <em>API</em> keys. If you don&#x27;t have a <em>key</em>, create a <em>new</em> <em>one</em> by selecting Insert keys +. Insert your Insert <em>API</em> <em>key</em> into the following JSON and then send the JSON to our endpoint. curl -i -H",
        "breadcrumb": "Contents &#x2F; Understand dependencies &#x2F; Distributed tracing &#x2F; Trace <em>API</em>"
      },
      "id": "5d89dc6028ccbc83ce9cb16f"
    },
    {
      "sections": [
        "Nerdpack file structure",
        "Generate Nerdpack components",
        "Nerdlet file structure",
        "index.js",
        "nr1.json",
        "styles.scss",
        "icon.png",
        "Launcher file structure"
      ],
      "title": "Nerdpack file structure",
      "type": "developer",
      "tags": [
        "New Relic One CLI",
        "nerdpack",
        "file structure",
        "nerdlets",
        "launchers"
      ],
      "external_id": "c97bcbb0a2b3d32ac93b5b379a1933e7b4e00161",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdpack-file-structure/",
      "published_at": "2020-09-16T01:49:54Z",
      "updated_at": "2020-08-14T01:49:25Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the Nerdpack File Structure",
      "body": "Nerdpack file structure A New Relic One application is represented by a Nerdpack folder, which can include one or more Nerdlet files, and (optionally) one or more launcher files. Here we explain: The file structure for a Nerdpack, a Nerdlet, and a launcher How to link a launcher file to a Nerdlet How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the New Relic One CLI command nr1 create and select Nerdpack to create a Nerdpack template that includes a Nerdlet and a launcher. Generate Nerdlet or launcher individually: Use the New Relic One CLI command nr1 create and choose either Nerdlet or launcher. This can be useful when adding Nerdlets to an existing Nerdpack. For documentation on generating and connecting Nerdpack components, see our app building guides and the New Relic One CLI command reference. Nerdpack file structure When you generate a Nerdpack template using the nr1 create command, it has the following file structure: my-nerdlet ├── README.md ├── launchers │   └── my-nerdlet-launcher │   ├── icon.png │   └── nr1.json ├── nerdlets │   └── my-nerdlet-nerdlet │   ├── index.js │   ├── nr1.json │   └── styles.scss ├── node_modules │   ├── js-tokens │   ├── loose-envify │   ├── object-assign │   ├── prop-types │   ├── react │   ├── react-dom │   ├── react-is │   └── scheduler ├── nr1.json ├── package-lock.json └── package.json Copy Nerdlet file structure A Nerdpack can contain one or more Nerdlets. A Nerdlet folder starts out with three default files, index.js, nr1.json, and styles.scss. Here is what the default files look like after being generated using the nr1 create command: index.js The JavaScript code of the Nerdlet. import React from 'react'; export default class MyAwesomeNerdpack extends React.Component { render() { return <h1>Hello, my-awesome-nerdpack Nerdlet!</h1>; } } Copy nr1.json The Nerdlet configuration file. { \"schemaType\": \"NERDLET\", \"id\": \"my-awesome-nerdpack-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\" } Copy Besides using the launcher as the access point for your application, you can also associate the application with a monitored entity to get it to appear in the entity explorer. To do this, add two additional fields to the config file of the first-launched Nerdlet: entities and actionCategory. In the following example, the Nerdlet has been associated with all Browser-monitored applications and will appear under the Monitor UI category : { \"schemaType\": \"NERDLET\", \"id\": \"my-nerdlet\", \"description\": \"Describe me\", \"displayName\": \"Custom Data\", \"entities\": [{ \"domain\": \"BROWSER\", \"type\": \"APPLICATION\" }], \"actionCategory\": \"monitor\" } Copy To see this application in the UI, you would go to the entity explorer, select Browser applications, and select a monitored application. styles.scss An empty SCSS file for styling your application. icon.png The launcher icon that appears on the Apps page in New Relic One when an application is deployed. Launcher file structure Launchers have their own file structure. Note that: A launcher is not required; as an alternative to using a launcher, you can associate your application with a monitored entity. An application can have more than one launcher, which might be desired for an application with multiple Nerdlets. After generating a launcher using the nr1 create command, its folder contains two files: nr1.json The configuration file. { \"schemaType\": \"LAUNCHER\", \"id\": \"my-awesome-nerdpack-launcher\", \"description\": \"Describe me\", \"displayName\": \"MyAwesomeNerdpack\", \"rootNerdletId\": \"my-awesome-nerdpack-nerdlet\" } Copy To connect a launcher to a Nerdlet, the rootNerdletId must match the id in the launched Nerdlet's nr1.json config file. For Nerdpacks with multiple Nerdlets, this needs to be done only for the first-launched Nerdlet. icon.png The icon displayed on the launcher for the app on the Apps page.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.2782,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>",
        "body": " How to link your application with a monitored entity For basic component definitions, see our component reference. Generate Nerdpack components There are two ways to generate a Nerdpack template: Generate a Nerdpack: Use the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> command nr1 create and select Nerdpack to create"
      },
      "id": "5efa989e196a671300766404"
    },
    {
      "sections": [
        "Get started with the New Relic CLI",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Get your application details",
        "Add a simple tag to your application",
        "Bonus step: Create a deployment marker",
        "Next steps"
      ],
      "title": "Get started with the New Relic CLI",
      "type": "developer",
      "tags": [
        "api key",
        "New Relic CLI",
        "Tags",
        "Entity",
        "Deployment markers"
      ],
      "external_id": "531f2f3985bf64bb0dc92a642445887095048882",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/get-started-new-relic-cli/",
      "published_at": "2020-09-16T01:49:54Z",
      "updated_at": "2020-08-08T01:41:47Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Learn the essentials of the New Relic CLI, from install and configuration to basic usage.",
      "body": "Get started with the New Relic CLI 20 min Access the New Relic platform from the comfort of your terminal: you can use the New Relic CLI to manage entity tags, define workloads, record deployment markers, and much more. Our CLI has been designed for automating common tasks in your DevOps workflow. This guide walks you through the essentials of New Relic CLI, from install and configuration to basic usage. Before you begin For this guide you just need: Your New Relic personal API Key, which you can create from the Account settings of your New Relic account An instrumented application in your New Relic account Step 1 of 10 Install the New Relic CLI The New Relic CLI can be downloaded via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 10 Create your New Relic CLI profile Now that you've installed the New Relic CLI, it's time to create your first profile. Profiles contain credentials and settings that you can apply to any CLI command, which is useful when switching between accounts. To create your first CLI profile, run the profiles add command. Note that you need to set the region of your New Relic account: use -r to set either us or eu (this is required). # Create the tutorial account for the US region newrelic profiles add -n tutorial --apiKey YOUR_NEW_RELIC_API_KEY -r YOUR_REGION # Set the profile as defaults newrelic profiles default -n tutorial Copy Step 3 of 10 Get your application details In this example, you are going to add tags to the application you've instrumented with New Relic. Tags are key-value pairs that can help you organize and filter your entities. An entity (for example, an application) can have a maximum of 100 key-value pairs tied to it. Before searching for your application using the New Relic CLI, write down or copy your Account ID and the name of your application in New Relic - you need both to find applications in the New Relic platform. Step 4 of 10 The New Relic CLI can retrieve your application details as a JSON object. To search for your APM application use the apm application search command. If you get an error, check that the account ID and application name you provided are correct. newrelic apm application search --accountId YOUR_ACCOUNT_ID --name NAME_OF_YOUR_APP Copy Step 5 of 10 If the account ID is valid, and the application name exists in your account, apm application search yields data similar to this example. When you've successfully searched for your application, look for the guid value. It's a unique identifier for your application. You should copy it or write it down. [ { accountId: YOUR_ACCOUNT_ID, applicationId: YOUR_APP_ID, domain: 'APM', entityType: 'APM_APPLICATION_ENTITY', guid: 'A_LONG_GUID', name: 'NAME_OF_YOUR_APP', permalink: 'https://one.newrelic.com/redirect/entity/A_LONG_GUID', reporting: true, type: 'APPLICATION', }, ]; Copy Step 6 of 10 Add a simple tag to your application Now that you have the GUID, you can point the New Relic CLI directly at your application. Adding a tag is the simplest way to try out the CLI capabilities (don't worry, tags can be deleted by using entity tags delete). Let's suppose that you want to add an environment tag to your application. Go ahead and add the dev:testing tag⁠ (or any other key-value pair) to your application using the entities tags create command. newrelic entity tags create --guid YOUR_APP_GUID --tag devkit:testing Copy Step 7 of 10 What if you want to add multiple tags? Tag sets come to the rescue! While tags are key-value pairs separated by colons, tag sets are comma separated lists of tags. For example: tag1:value1,tag2:value2 To add multiple tags at once to your application, modify and run the following snippet. newrelic entity tags create --guid YOUR_APP_GUID --tag tag1:test,tag2:test Copy Adding tags is an asynchronous operation: this means it could take a while for the tags to get created. Step 8 of 10 You've created and added some tags to your application, but how do you know they're there? You need to retrieve your application's tags. To retrieve your application's tags, use the entity tags get command. newrelic entity tags get --guid YOUR_APP_GUID All tags associated with your application are retrieved as a JSON array. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Step 9 of 10 Bonus step: Create a deployment marker Deployments of applications often go wrong. Deployment markers are labels that, when attached to your application data, help you track deployments and troubleshoot what happened. To create a deployment marker, run the apm deployment create command using the same Application ID from your earlier search. newrelic apm deployment create --applicationId YOUR_APP_ID --revision $(git describe --tags --always) Copy Step 10 of 10 Notice that the JSON response includes the revision and timestamp of the deployment. This workflow could be built into a continuous integration or continuous deployment (CI/CD) system to help indicate changes in your application's behavior after deployments. Here is an example. { \"id\": 37075986, \"links\": { \"application\": 204261368 }, \"revision\": \"v1.2.4\", \"timestamp\": \"2020-03-04T15:11:44-08:00\", \"user\": \"Developer Toolkit Test Account\" } Copy Next steps Have a look at all the available commands. For example, you could create a New Relic workflow using workload create If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.35859,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "sections": "Get started with the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Learn the essentials of the <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage.",
        "tags": "<em>New</em> <em>Relic</em> <em>CLI</em>",
        "body": ". This guide walks you through the essentials of <em>New</em> <em>Relic</em> <em>CLI</em>, from install and configuration to basic usage. Before you begin For this guide you just need: Your <em>New</em> <em>Relic</em> personal <em>API</em> <em>Key</em>, which you can create from the <em>Account</em> settings of your <em>New</em> <em>Relic</em> <em>account</em> An instrumented application in your"
      },
      "id": "5efa999c196a67c4e1766461"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Note",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-09-16T01:49:54Z",
      "updated_at": "2020-08-14T01:45:08Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). # Create the tutorial account for the US region newrelic profiles add -n tutorial --apiKey API_KEY -r us # Set the profile as default newrelic profiles default -n tutorial Copy Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. # Change the `name` to match any of your existing entities newrelic entity search --name \"test\" Copy Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Note Adding tags is an asynchronous operation: it could take a little while for the tags to get created. # Adding a single tag newrelic entity tags create --guid GUID --tag key:value # Adding multiple tags newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Copy Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.12738,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " <em>CLI</em> to add multiple tags to <em>one</em> of your entities. Before you begin For this guide you need your <em>New</em> <em>Relic</em> personal <em>API</em> <em>Key</em>: Create it at the <em>Account</em> settings screen for your <em>account</em>. Step 1 of 6 Install the <em>New</em> <em>Relic</em> <em>CLI</em> You can download the <em>New</em> <em>Relic</em> <em>CLI</em> via Homebrew (macOS), Scoop (Windows"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    }
  ],
  "/build-apps/permission-manage-apps": [
    {
      "category_2": "Original users and roles",
      "nodeid": 1101,
      "sections": [
        "Original accounts and billing",
        "Original product-based pricing",
        "Original users and roles",
        "Original data retention",
        "Original pricing plan usage",
        "Users and roles (original user model)",
        "View and manage users",
        "User types: basic user and full user",
        "Account roles",
        "Add-on roles",
        "Account permissions",
        "Alert permissions",
        "APM permissions",
        "Browser permissions",
        "Infrastructure permissions",
        "Insights permissions",
        "Mobile permissions",
        "Synthetics permissions",
        "Workloads",
        "For more help"
      ],
      "title": "Users and roles (original user model)",
      "category_0": "New Relic accounts",
      "type": "docs",
      "category_1": "Original accounts and billing",
      "external_id": "39c7440fe944f68b4de943d2c9619cbcc85408d2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/accounts/original-accounts-billing/original-users-roles/users-roles-original-user-model",
      "published_at": "2020-09-16T05:47:15Z",
      "updated_at": "2020-09-10T07:06:50Z",
      "breadcrumb": "Contents / New Relic accounts / Original accounts and billing / Original users and roles",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic original user model: explanation of how to manage users, and how user roles work. ",
      "body": "Original user model This doc contains information about how to manage users on our original user model. Not sure which pricing plan or user model you're on? See Overview of pricing plan and user models. View and manage users To see the users on your New Relic account and their current roles: select the account dropdown, select Account settings, and select Users and roles. Some features in the UI are visible only to account Owners and Admins. User types: basic user and full user On the Users and roles UI page, users are categorized as either full users or basic users. This only affects your account if you've switched to the New Relic One pricing plan, released July 2020. Once you've changed your pricing plan, the number of full users is a factor in your billing. To learn more, see Transition to new pricing. You can also bulk update changes to user type. Account roles A New Relic account can have only one Owner. To share an account with other users in your organization, create Admins, Users, or Restricted Users. Account role Description Owner The person who initially creates the New Relic account and receives all billing queries. The Owner has complete access to all of the account information. The Owner can also install and configure the New Relic agent, and they can enable or set up features. Admins One or more individuals who can add, edit, and delete account users. Admins can also install and configure the New Relic agent, and they can enable or set up features. Users One or more individuals who use (and optionally set up) the available New Relic features. In general, Admins take responsibility for setting up features, and Users and Restricted Users can use them. Restricted Users One or more individuals who can view (but not set up or change) any New Relic features. The Restricted User role is useful, for example, for demos. You can change your New Relic session settings so that Restricted User logins do not time out, and then set the user interface to Kiosk mode. Add-on roles With add-on roles, you can grant variable levels of access to all users in your account, across the entire platform of New Relic products. This allows you to tailor your account permissions levels to suit the needs of Users and Restricted Users within your account. Giving a User or Restricted User add-on manager access to a product grants them the equivalent of Admin capabilities within the product. They will continue to have User or Restricted User capabilities for all other New Relic products. For example, you could make a software engineer in your company a User in most products, but assign Admin-level access to APM. For another example, you might assign the Nerdpack manager role to a user, and that gives them the ability to subscribe and unsubscribe New Relic One applications to an account. There are two types of add-on roles: Add-on Manager roles are available to grant permissions on a per-product basis. Giving a User or Restricted User managed add-on access to a product grants them the equivalent of Admin capabilities within the product. Custom add-on roles can grant feature-specific permissions across different New Relic products. For example, a group of Users could have the ability to acknowledge incidents and close violations in New Relic Alerts, but not have the ability to modify your existing alert preferences. Individuals on a master account that has sub-accounts automatically have the same level of access for all sub-accounts. Below are options for managing both managed add-on roles and custom add-on roles: View roles To view the list of individuals assigned to your account and their current roles: Go to account dropdown > Account settings > Users and roles. Assign a managed role Owner and Admins Managed add-on roles are available by default for each New Relic product. Adding a managed role for a user grants them Admin-level permissions for the assigned product. They cannot be edited or deleted. To assign a managed add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles. From the list of users associated with your account, select their name. Under Add-on roles, select the type of manager role for the user. To understand which capabilities may be added, use the Capabilities preview chart. Features in the Capabilities preview chart may not exactly match what features are available for your subscription level. You can also add, update, or delete users in bulk by using a CSV file. Create a custom role To create a custom add-on role for your account: Go to account dropdown > Account settings > Users and roles > Roles. Select plus-circle New custom add-on role. Select the capabilities necessary for the new custom role, then Create role. Assign a custom role Owners and Admins You must create a custom role before assigning it to a user. To assign a custom add-on role for a User or Restricted User in your account: Go to account dropdown > Account settings > Users and roles > Users. From the list of users associated with your account, select their name ]. Under Add-on roles, select a custom role for the user. Click Update user. Edit or delete a custom role Owners and Admins You cannot edit or delete New Relic's default roles. However, you can edit or delete custom add-on roles for your account: Go to account dropdown > Account settings > Users and roles > Roles. From the Add-on roles list, select the custom add-on role, then select pencil Edit role or trash-o Delete role as appropriate. Account permissions Here is a summary of basic user rights for your New Relic account. Individuals on a master account with sub-accounts automatically have the same level of access for all sub-accounts. However, they will not receive email notifications for alerts or weekly reports for sub-accounts unless they are explicitly granted permission on these sub-accounts. Function Owner Admin User Restricted Maintain billing information. fa-check Change the account Owner. fa-check Add, update, and delete account Admins, Users, and Restricted Users. When the account Owner and Admins add individuals to the account, New Relic automatically sends them an email message. fa-check fa-check Update users' job titles and roles from Account settings in the New Relic UI. fa-check fa-check Create, modify and delete sub-accounts from Account settings in the New Relic UI. fa-check fa-check Update your own account information (name, password change or password reset request, default account, email preferences, etc.) from User preferences in the New Relic UI. fa-check fa-check fa-check fa-check Change someone else's password. You cannot reset passwords for anyone else on the account, even if you are an Owner or Admin. Instead, follow standard procedures to request a password reset from New Relic. View the list of individuals on the account from (account dropdown) > Account settings > Account > Summary in the New Relic UI. fa-check fa-check fa-check fa-check Manage flexible data retention. fa-check Subscribe and unsubscribe applications to New Relic One fa-check fa-check Alert permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Alerts. To allow a User or Restricted User to execute any of these functions in New Relic Alerts, assign an Alerts add-on manager role. Admin and manager capabilities for Alerts include: Create or name alert policies. Specify incident preferences. Disable or define alert conditions. Provide runbook instructions. Select product targets. Alter alert condition thresholds. Create, modify, or delete notification channels. APM permissions Here is a summary of Admin and Add-on manager capabilities with New Relic APM. To allow a User or Restricted User to execute any of these functions in New Relic APM, assign an APM add-on manager role. Admin and manager capabilities for APM include: Remove applications from the New Relic UI. Delete app traces and error traces. Browser permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Browser. To allow a User or Restricted User to execute any of these functions in New Relic Browser, assign a Browser add-on manager role. Admin and manager capabilities for Browser include: Add, rename, or delete applications. Manage whitelists. Manage domain conditions. Infrastructure permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Infrastructure. To allow a User or Restricted User to execute any of these functions in New Relic Infrastructure, assign an Infrastructure manager role. Admin and manager capabilities for Infrastructure include: Create alert conditions in New Relic Infrastructure, including conditions for host not reporting. Add or modify integrations. Insights permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Insights. To allow a User or Restricted User to execute any of these functions in New Relic Insights, assign an Insights manager role. These functions include: Create, view, modify, or delete Query API keys or Insert API keys. New Relic Insights includes permission levels to share your Insights dashboards with others. Mobile permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Mobile. To allow a User or Restricted User to execute any of these functions in New Relic Mobile, assign a Mobile manager role. Admin and manager capabilities for Mobile include: Delete a mobile application from New Relic. Install New Relic Mobile for Android or iOS. Synthetics permissions Here is a summary of Admin and Add-on manager capabilities with New Relic Synthetics. To allow a User or Restricted User to execute any of these functions in New Relic Synthetics, assign a Synthetics add-on manager role. Admin and manager capabilities for Synthetics include: Create, edit, or delete monitors. Edit monitor scripts. Create, edit, or delete private locations. Create, edit, or delete monitor downtimes. Create, view, edit, or delete secure credentials. For more information, see User roles in Synthetics. Workloads Here's a summary of Admin and Add-on manager capabilities with New Relic One workloads: Create, duplicate, modify, or delete workloads. Link dashboards to workloads and save filters. To allow a User or Restricted User to execute these functions, assign the workloads manager add-on role. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.41366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Account <em>permissions</em>",
        "info": "For New Relic original user model: explanation of how to <em>manage</em> users, and how user roles work. ",
        "body": ", assign an APM add-on <em>manager</em> role. Admin and <em>manager</em> capabilities for APM include: Remove applications from the New Relic UI. Delete <em>app</em> traces and error traces. Browser <em>permissions</em> Here is a summary of Admin and Add-on <em>manager</em> capabilities with New Relic Browser. To allow a User or Restricted User"
      },
      "id": "5f3e194028ccbc18c7f56de3"
    },
    {
      "sections": [
        "Serve, publish, and deploy your New Relic One app",
        "Before you begin",
        "Serve your app locally",
        "Add images and metadata to your apps",
        "screenshots folder",
        "documentation.md",
        "additionalInfo.md",
        "config.json",
        "Publish your app",
        "Tip",
        "Deploy your app",
        "Subscribe or unsubsribe apps",
        "Handle duplicate applications"
      ],
      "title": "Serve, publish, and deploy your New Relic One app",
      "type": "developer",
      "tags": [
        "publish apps",
        "deploy apps",
        "subscribe apps",
        "add metadata apps"
      ],
      "external_id": "63283ee8efdfa419b6a69cb8bd135d4bc2188d2c",
      "image": "https://developer.newrelic.com/static/175cc6506f7161ebf121129fa87e0789/0086b/apps_catalog.png",
      "url": "https://developer.newrelic.com/build-apps/publish-deploy/",
      "published_at": "2020-09-16T01:55:54Z",
      "updated_at": "2020-09-02T02:05:55Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Start sharing and using the custom New Relic One apps you build",
      "body": "Serve, publish, and deploy your New Relic One app 30 min When you build a New Relic One app, chances are you'll want to share it with others in your organization. You might even want to share it broadly through our open source channel. But first, you probably want to try it out locally to make sure it's working properly. From the New Relic One Apps page, you can review available apps and subscribe to the ones you want for accounts you manage. The Your apps section shows launchers for New Relic apps, as well as any third-party apps that you subscribe to. The New Relic One catalog provides apps that you haven't subscribed to, some developed by New Relic engineers to provide visualizations we think you'll want, like Cloud Optimizer, which analyzes your cloud environment, or PageView Map, which uses Browser events to chart performance across geographies. Your apps in the catalog are created by third-party contributors and are submitted via opensource.newrelic.com. All are intended to help you visualize the data you need, the way you want it. Here, you learn to: Serve your app locally Add images and metadata to your app Publish it Subscribe and unsubscribe accounts you manage to the app Handle duplicate applications Before you begin This guide requires the following: A New Relic One app or Nerdpack New Relic One CLI A Nerdpack manager role for publishing, deploying, and subscribing apps. Serve your app locally You can locally serve the app you create to New Relic One to test it out. Step 1 of 1 In the parent root folder of your Nerdpack, run nr1 nerdpack:serve. Go to one.newrelic.com/?nerdpacks=local. The ?nerdpacks=local URL suffix will load any locally served Nerdpacks that are available. When you make a change to a locally served Nerdpack, New Relic One will automatically reload it. Add images and metadata to your apps Application creators can include a description of what their apps do and how they're best used when they build an app. They can also include screenshots, icons, and metadata that help to make them easy to spot amongst other applications. Some metadata is added automatically when an app is published: Related entities, listed if there are any. Origin label to indicate where the app comes from: local, custom, or public. The New Relic One CLI enables you to provide the information and images you want to include with your application. Then it's a matter of kicking off a catalog command that validates the information and saves it to the catalog. Step 1 of 3 Update the New Relic One CLI to ensure you're working with the latest version. nr1 update Copy Step 2 of 3 Add catalog metadata and screenshots. Run nr1 create and then select catalog to add a catalog folder to your New Relic One project. The folder contains the following empty files and folder. Add the information as described in the following sections for the process to succeed. screenshots folder A directory that must contain no more than 6 images and meet these criteria: 3:2 aspect ratio PNG format landscape orientation 1600 to 2400 pixels wide documentation.md A markdown file that presents usage information pulled into the Documentation tab for the application in the catalog. additionalInfo.md An optional markdown file for any additional information about using your application. config.json A JSON file that contains the following fields: tagline: A brief headline for the application. Must not exceed 30 characters. repository: The URL to the GitHub repo for the application. Must not exceed 1000 characters. details: Describes the purpose of the application and how to use it. Information must not exceed 1000. Use carriage returns for formatting. Do not include any markdown or HTML. support: An object that contains: issues: A valid URL to the GitHub repository's issues list, generally the GitHub Issues tab for the repo. email: A valid email address for the team supporting the application. community: URL to a support thread, forum, or website for troubleshooting and usage support. whatsNew: A bulleted list of changes in this version. Must not exceed 500 characters. Use carriage returns for formatting. Do not include markdown or HTML. Example: { \"tagline\": \"Map your workloads &amp; entities\", \"repository\": \"https://github.com/newrelic/nr1-workload-geoops.git\", \"details\": \"Describe, consume, and manage Workloads and Entities in a geographic \\n model that supports location-specific KPI's, custom metadata, drill-down navigation into Entities \\n and Workloads, real-time configuration, and configuration via automation using the newrelic-cli.\", \"support\": { \"issues\": { \"url\": \"https://github.com/newrelic/nr1-workload-geoops/issues\" }, \"email\": { \"address\": \"opensource+nr1-workload-geoops@newrelic.com\" }, \"community\": { \"url\": \"https://discuss.newrelic.com/t/workload-geoops-nerdpack/99478\" } }, \"whatsNew\": \"\\n-Feat: Geographic mapping of Workloads and Entities\\n -Feat: Programmatic alerting rollup of underlying Entities\\n -Feat: Custom KPI measurement per location\\n -Feat: Empty-state edit workflow\\n -Feat: JSON file upload format\\n-Feat: Published (in open source docs) guide to automating configuration using the newrelic-cli\" } Copy Step 3 of 3 Save the metadata and screenshots to the catalog. This validates the information you added to the catalog directory against the criteria described in the previous step, and saves it to the catalog. nr1 catalog:submit Copy Publish your app Publishing places your Nerdpack in New Relic One. To publish or deploy, you must be a Nerdpack manager. New Relic One requires that only one version (following semantic versioning) of a Nerdpack can be published at a time. Tip If you know what channel you want to deploy to (as described in the Deploy your app section that follows), you can run nr1 nerdpack:publish --channel=STABLE or nr1 nerdpack:publish --channel=BETA. Step 1 of 2 Update the version attribute in the app's package.json file. This follows semantic versioning, and must be updated before you can successfully publish. Step 2 of 2 To publish your Nerdpack, run nr1 nerdpack:publish. Deploy your app Deploying is applying a Nerdpack version to a specific channel (for example, BETA, or STABLE). A channel can only have one Nerdpack version deployed to it at one time. If a channel has an existing Nerdpack associated with it, deploying a new Nerdpack version to that channel will undeploy the previous one. Channels are meant to be an easier way to control application version access than having to be concerned with specific version numbers. Step 1 of 1 To deploy an application, run nr1 nerdpack:deploy. Subscribe or unsubsribe apps Whether you want to subscribe accounts to an app you've created or to apps already available in the catalog, the process is the same. Note that if you subscribe to an app in the catalog, you'll automatically get any updates that are added to the app. To learn about the appropriate permissions for subscribing, see Permissions for managing applications. Step 1 of 2 Subscribe accounts to an application. Select an application you want to add to your New Relic account. Click Add this app. Note that this button says Manage access if the app has already been subscribed to an account you manage. On the Account access page listing the accounts you can subscribe to an application: Select the accounts you want to subscribe the app to. Choose the channel you want to subscribe the app to, Stable or Dev. This can only be Stable for the public apps created by New Relic. Click the update button. Now you and members of the accounts you have subscribed to the app can launch it from New Relic One. Step 2 of 2 Unsubsribe from an application. On the Apps page, open the app you want to unsubscribe. Click Manage access. Clear the check box for any accounts you want to unsubscribe, and then click the update button. The application is no longer listed in the Your apps section of the Apps page, and you have unsubscribed. Handle duplicate applications You might end up with duplicate applications on your New Relic One Apps page. This can happen when you subscribe to the same app using both the CLI and the catalog. Or if you clone an app, modify, and deploy it, but keep the original name. You can manage duplicates with the catalog. Good to know before you start: You need a user role with the ability to manage Nerdpacks for accounts that you want to unsubscribe and undeploy from applications. You can't remove the public apps. When a duplicate application has no accounts subscribed to it, you undeploy it. For applications that have accounts subscribed to them, you unscubscribe and undeploy. The unsubscribe and undeploy process happens in a batch. To remove an account from an application, but ensure that other accounts continue to be subscribed, select the checkbox, Resubscribe these accounts to the new application. Step 1 of 1 Remove duplicates. In the New Relic One catalog, click a public application that has one or more duplicates. (You can only manage duplicates from the public version of the application.) On the application information page, select Clean up applications. Review the information about the application that's open, as well as any duplicates. Click Manage app for duplicates you want to remove. If needed, select Resubscribe these accounts to the new application. Click Unsubscribe and undeploy, and agree to the terms and conditions.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.22337,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Serve, publish, and deploy your New Relic One <em>app</em>",
        "sections": "Add images and metadata to your <em>apps</em>",
        "info": "Start sharing and using the custom New Relic One <em>apps</em> you build",
        "tags": "publish <em>apps</em>",
        "body": " to the <em>app</em> Handle duplicate applications Before you begin This guide requires the following: A New Relic One <em>app</em> or <em>Nerdpack</em> New Relic One CLI A <em>Nerdpack</em> <em>manager</em> role for publishing, deploying, and subscribing <em>apps</em>. Serve your <em>app</em> locally You can locally serve the <em>app</em> you create to New Relic One to test"
      },
      "id": "5efa999de7b9d283e67bab8f"
    },
    {
      "image": "https://cc.sj-cdn.net/instructor/1h7ahmdd447dx-new-relic/courses/2g790g7la1iot/promo-image.1573253956.png",
      "url": "https://learn.newrelic.com/live-learncast-new-relic-one-programmability",
      "sections": [
        "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications.",
        "About this Learncast",
        "Prerequisites",
        "Virtual Training Session List"
      ],
      "published_at": "2020-09-16T01:39:11Z",
      "title": "Live Learncast: New Relic One Programmability",
      "updated_at": "2020-07-31T01:40:49Z",
      "type": "",
      "external_id": "053510b559767dbde34e3f1ee9a73bbf813a5a83",
      "popularity": 1,
      "body": "Sign In Live Learncast: New Relic One Programmability Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. Not currently available Available until July 10, 2020, 3:30 p.m. PDT. Already registered? Sign In About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably.   During this session we will review the following topics:   1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites   This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.   Must have:   Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) About this Learncast The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic University facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably.   During this session we will review the following topics:   1. Installation of New Relic CLI and Environment setup 2. Familiarization with New Relic One Application component model and lifecycle 3. Advanced UI construction and data processing 4. Individual self paced experimentation and Open Source example deployment Prerequisites   This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.   Must have:   Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests Virtual Training Session List Virtual Training Session List Live Training Sessions Recorded Learncast Part 1 - Introduction (55 min) Part 2 - Advanced (38 min) © 2020 powered by",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.14254,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic <em>Applications</em>.",
        "body": " A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> roll to deploy   Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials"
      },
      "id": "5dc618cbe7b9d2a0a8e4649c"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-16T01:51:15Z",
      "title": "Build apps",
      "updated_at": "2020-09-16T01:51:15Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.12125,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "<em>Permissions</em> for <em>managing</em> <em>applications</em>",
        "body": "   <em>Permissions</em> for <em>managing</em> applications Learn about <em>permissions</em> for subscribing to <em>apps</em> 20 min Set up your development environment Prepare to build <em>apps</em> and contribute to this site 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "image": "https://newrelic.com/dam/new-relic/opengraph/newrelic_og_image.png",
      "url": "https://newrelic.com/resources/webinars/NR-One-Programmability-191126",
      "sections": [
        "During this session we will review the following topics:",
        "Related Links",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-09-13T14:28:25Z",
      "title": "New Relic One Programmability Online Training",
      "updated_at": "2020-09-03T03:22:32Z",
      "type": "storefront",
      "external_id": "f583edb88ca2d2430ca297364eac839705311616",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Video New Relic One Programmability Online Training 46:59   Join us for this exclusive 90-minute introduction to the fundamentals of New Relic One Programmability. This training will introduce you to the key concepts and walk you through developing New Relic Applications. The training is based on the self-paced material freely available on New Relic GitHub and delivered by a New Relic facilitator who will guide you through the introduction of the first 3 of the 10 labs available. This session allows for active questions and answers and facilitated troubleshooting when code or environments act unpredictably. Prerequisites This New Relic One training assumes no specific software engineering or developer experience; each lab comes with a fully completed functional solution that participants can copy into the lab repo to complete the activity. The labs are designed to promote experimentation by changing variables, layouts, data access methods, and UI components allowing each participant to comfortably experiment with the material to gain familiarity. Whether you are new to or rusty at programming or JavaScript, or happen to be an expert React.js developer; this training will provide important context to start you on the journey of developing New Relic Applications.  Must have: Permissions to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) Nerdpack manager role to deploy Technical exercises include exposure to the following technical topics: Installing the New Relic command-line interface (CLI) on local workstation Setting New Relic API developer access credentials Accessing GitHub repositories and cloning existing NR1 applications Executing New Relic CLI commands Making GraphQL and Web Service requests JavaScript layouts   During this session we will review the following topics: Installation of New Relic CLI and Environment setup Familiarisation with New Relic One Application component model and lifecycle Advanced UI construction and data processing Individual self paced experimentation and Open Source example deployment Request a Demo Related Links Case Study La plus grande brasserie au monde se tourne vers New Relic pour que la bière continue de couler à flots dans l’ère numérique Webinar Introduction to Custom Apps on New Relic One eBook Understanding the 3 Phases of DevOps Maturity Article Black Friday Is Coming: Are Your Sites and Apps Ready? eBook DevOps – so geht es richtig : Best Practices zur Überwindung von Erfolgshindernissen eBook DevOps Done Right: Best Practices to Knock Down Barriers to Success eBook Creating a Framework for Digital Media Success Article 7 Requirements for Monitoring Cloud Apps and Infrastructure COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.93086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "; this training will provide important context to start you on the journey of developing New Relic Applications.  Must have: <em>Permissions</em> to install  Git installed Node installed A text editor or IDE of your choice (we will be using VS Code) <em>Nerdpack</em> <em>manager</em> role to deploy Technical exercises include exposure"
      },
      "id": "5ece92cb28ccbc3012c1356a"
    }
  ],
  "/automate-workflows/get-started-new-relic-cli": [
    {
      "image": "https://developer.newrelic.com/static/nerd-days-cd32e6ce7bce9feb13142801151df03c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-16T01:45:36Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-16T01:37:52Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 27 Days : 15 Hours : 1 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 323.22028,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "<em>New</em> <em>Relic</em> developer champions",
        "body": " source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-16T01:52:28Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-16T01:52:28Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 303.15512,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Set up <em>New</em> <em>Relic</em> using Helm charts",
        "body": " it is to leverage automation in your DevOps environment! 20 min Automate common tasks Use the <em>New</em> <em>Relic</em> <em>CLI</em> to <em>tag</em> apps and create <em>deployment</em> <em>markers</em> 20 min Set up <em>New</em> <em>Relic</em> using the Kubernetes operator Learn how to provision <em>New</em> <em>Relic</em> resources using the Kubernetes operator 20 min Set up <em>New</em> <em>Relic</em> using Terraform Learn how to provision <em>New</em> <em>Relic</em> resources using Terraform"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "sections": [
        "Quickly tag a set of resources",
        "Before you begin",
        "Install the New Relic CLI",
        "Linux",
        "macOS",
        "Windows",
        "Create your New Relic CLI profile",
        "Search for an entity",
        "Add tags and tag lists to your entity",
        "Note",
        "Check that the tags are there",
        "Tip",
        "Next steps"
      ],
      "title": "Quickly tag a set of resources",
      "type": "developer",
      "tags": [
        "tags",
        "new relic CLI"
      ],
      "external_id": "c7c374812f8295e409a9b06d552de51ceefc666b",
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/5-mins-tag-resources/",
      "published_at": "2020-09-16T01:49:54Z",
      "updated_at": "2020-08-14T01:45:08Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add tags to applications you instrument for easier filtering and organization.",
      "body": "Quickly tag a set of resources 5 min Tags help you group, search, filter, and focus the data about your entities, which can be anything from applications to hosts to services. Tagging entities using the New Relic CLI is a good candidate for automation. In this 5-minute guide, you use the New Relic CLI to add multiple tags to one of your entities. Before you begin For this guide you need your New Relic personal API Key: Create it at the Account settings screen for your account. Step 1 of 6 Install the New Relic CLI You can download the New Relic CLI via Homebrew (macOS), Scoop (Windows), and Snapcraft (Linux). You can also download pre-built binaries for all platforms, including .deb and .rpm packages, and our Windows x64 .msi installer. Linux With Snapcraft installed, run: sudo snap install newrelic-cli macOS With Homebrew installed, run: brew install newrelic-cli Windows With Scoop installed, run: scoop bucket add newrelic-cli https://github.com/newrelic/newrelic-cli.git scoop install newrelic-cli Step 2 of 6 Create your New Relic CLI profile New Relic CLI profiles contain credentials and settings that you can apply to any CLI command. To create your first CLI profile, run the profiles add command. Don't forget to set the region of your New Relic account: use -r to set either us or eu (this is required). # Create the tutorial account for the US region newrelic profiles add -n tutorial --apiKey API_KEY -r us # Set the profile as default newrelic profiles default -n tutorial Copy Step 3 of 6 Search for an entity Your New Relic account might have hundreds of entities: Have a quick look by opening the Entity explorer. In the terminal, run entity search to retrieve a list of entities from your account as JSON. In the example, you're searching for all entities with \"test\" in their name. # Change the `name` to match any of your existing entities newrelic entity search --name \"test\" Copy Step 4 of 6 If there are matching entities in your account, the query yields data in JSON format, similar to this workload example. Select an entity from the results and look for its guid value; the guid is the unique identifier of the entity. Write it down. { \"accountId\": 123456789, \"domain\": \"NR1\", \"entityType\": \"WORKLOAD_ENTITY\", \"guid\": \"F7B7AE59FDED4204B846FB08423DB18E\", \"name\": \"Test workload\", \"reporting\": true, \"type\": \"WORKLOAD\" }, Copy Step 5 of 6 Add tags and tag lists to your entity With your entity guid, you can add tags right away. You can do so by invoking the entities tags create command. What if you want to add multiple tags? You can use tag sets for that: While tags are key-value pairs separated by colons, tag sets are comma-separated lists of tags. For example: tag1:value1,tag2:value2 Note Adding tags is an asynchronous operation: it could take a little while for the tags to get created. # Adding a single tag newrelic entity tags create --guid GUID --tag key:value # Adding multiple tags newrelic entity tags create --guid GUID --tag tag1:test,tag2:test Copy Step 6 of 6 Check that the tags are there To make sure that the tags have been added to your entities, retrieve them using the entity tags get command. All tags associated with your entity are retrieved as a JSON array. newrelic entity tags get --guid GUID Tip Tags can be deleted at any time by invoking the entity tags delete command followed by the same arguments you used to create them. [ { Key: 'tag1', Values: ['true'], }, { Key: 'tag2', Values: ['test'], }, { Key: 'tag3', Values: ['testing'], }, // ... ]; Copy Next steps Have a look at all the New Relic CLI commands. For example, you could create a New Relic workflow using workload create. If you'd like to engage with other community members, visit our New Relic Explorers Hub page. We welcome feature requests or bug reports on GitHub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 195.6832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Quickly <em>tag</em> a set of resources",
        "sections": "Install the <em>New</em> <em>Relic</em> <em>CLI</em>",
        "info": "Add <em>tags</em> to applications you instrument for easier filtering and organization.",
        "tags": "<em>new</em> <em>relic</em> <em>CLI</em>",
        "body": " by invoking the <em>entity</em> <em>tags</em> delete command followed by the same arguments you used to create them. [ { <em>Key</em>: &#x27;<em>tag</em>1&#x27;, Values: [&#x27;true&#x27;], }, { <em>Key</em>: &#x27;<em>tag</em>2&#x27;, Values: [&#x27;test&#x27;], }, { <em>Key</em>: &#x27;<em>tag</em>3&#x27;, Values: [&#x27;testing&#x27;], }, &#x2F;&#x2F; ... ]; Copy Next steps Have a look at all the <em>New</em> <em>Relic</em> <em>CLI</em> commands. For example"
      },
      "id": "5efa999d64441fa74a5f7e2d"
    },
    {
      "category_2": "Trace API",
      "nodeid": 35381,
      "sections": [
        "Distributed tracing",
        "Get started",
        "Enable and configure",
        "Other requirements",
        "UI and data",
        "Trace API",
        "Troubleshooting",
        "Report traces via the Trace API (New Relic format)",
        "Example: Use your tool’s native sampling",
        "Example: Use Infinite Tracing",
        "JSON requirements and recommendations",
        "Attributes",
        "Required attributes",
        "Highly recommended attributes",
        "Reserved attributes",
        "Other attributes",
        "Explore more about distributed tracing:",
        "For more help"
      ],
      "title": "Report traces via the Trace API (New Relic format)",
      "category_0": "Understand dependencies",
      "type": "docs",
      "category_1": "Distributed tracing",
      "external_id": "ba16f3a71b78e24c23da821b64567398251bb217",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/Infinite_Tracing_GraphiQL_URL_Results_0_0.png",
      "url": "https://docs.newrelic.com/docs/understand-dependencies/distributed-tracing/trace-api/report-new-relic-format-traces-trace-api",
      "published_at": "2020-09-13T19:08:58Z",
      "updated_at": "2020-09-13T19:08:58Z",
      "breadcrumb": "Contents / Understand dependencies / Distributed tracing / Trace API",
      "document_type": "page",
      "popularity": 1,
      "info": "For New Relic's Trace API: how to report traces using the New Relic format. ",
      "body": "You can send traces in the New Relic format to our Trace API without using a New Relic agent or integration. This is useful if you want to integrate with sources that emit tracing data and require a backend for trace storage. Since distributed systems can generate a lot of trace data, telemetry tools rely on data sampling (filtering) to find the most useful subset of that data. When you send us your trace data, you have two options related to sampling: Use your tool’s native sampling: This approach sends the telemetry data directly to the Trace API and assumes you are relying on your telemetry tool to sample the data before the integration passes the data to New Relic. Even though your tool may be sampling data before the New Relic integration sends it, our Trace API may randomly sample out traces that exceed your rate limit. Use Infinite Tracing (limited release): This approach assumes you turn off sampling in your telemetry tool and then send all your data to a New Relic trace observer in AWS. The trace observer selects the most important and actionable traces using tail-based sampling and then sends your traces to our UI. To send Zipkin-formatted data to the Trace API, see our Zipkin instructions. We'll look at two examples for sending your telemetry data to New Relic, as well as how to structure your data: Example: Use your tool’s native sampling Example: Use Infinite Tracing JSON requirements and recommendations Attributes Example: Use your tool’s native sampling If you are using a telemetry tool that is sampling your trace data, you can send the data directly to New Relic. The following procedure explains how to send a test payload to the Trace API using the newrelic format. For details about how to structure your data, see JSON requirements and recommendations. Get an Insert API key: Go to: one.newrelic.com > account dropdown > Account settings > API keys, and select Insights API keys. If you don't have a key, create a new one by selecting Insert keys +. Insert your Insert API key into the following JSON and then send the JSON to our endpoint. curl -i -H \"Content-Type: application/json\" \\ -H \"Api-Key: YOUR_INSERT_API_KEY\" \\ -H 'Data-Format: newrelic' \\ -H 'Data-Format-Version: 1' \\ -X POST \\ -d '[ { \"common\": { \"attributes\": { \"service.name\": \"Test Service A\", \"host\": \"host123.test.com\" } }, \"spans\": [ { \"trace.id\": \"123456\", \"id\": \"ABC\", \"attributes\": { \"duration.ms\": 12.53, \"name\": \"/home\" } }, { \"trace.id\": \"123456\", \"id\": \"DEF\", \"attributes\": { \"service.name\": \"Test Service A\", \"host\": \"host456.test.com\", \"duration.ms\": 2.97, \"name\": \"/auth\", \"parent.id\": \"ABC\" } } ] } ]' 'https://trace-api.newrelic.com/trace/v1' If you're sending more than one POST, change the trace.id to a unique value. Sending the same payload or span id multiple times for the same trace.id may result in fragmented traces in the UI. If your test returned HTTP/1.1 202 Accepted, go to our UI to see a query of your test data using the span attribute service.name = Test Service A. Traces may take up to one minute to be processed by both the trace observer and the Trace API. Example: Use Infinite Tracing Infinite Tracing can examine all of your data and find the most useful traces. To get the biggest benefit from Infinite Tracing, you should turn off sampling in your telemetry tool and send all your trace data to the trace observer. To start using Infinite Tracing, please go to our sign-up page. The following steps show you how to find or create a trace observer endpoint using GraphQL and how to send a test payload using the newrelic format. For details about how to structure your data, see JSON requirements and recommendations. If you send your data to a trace observer in one of our EU provider regions, you'll still need a US-based New Relic account because the tail-based sampling data is reported to data centers in the United States. If you have questions, contact your account representative. Step A. Open NerdGraph API explorer Prepare to execute some GraphQL: Open NerdGraph API explorer. In the API key dropdown next to Tools, select your personal API key for your account under one of these options: Select an existing API Key Create a new API Key Step B. See if anyone in your organization has already created a trace observer endpoint The following steps show you how to execute a GraphQL query to find out if you can use an existing trace observer in your AWS region. If one isn't available, you can go to Step C. Create a new one. Copy the following query into the middle pane of the NerdGraph API explorer and replace YOUR_ACCOUNT_ID with your account ID (the number next to your account name in NerdGraph API explorer): { actor { account(id: YOUR_ACCOUNT_ID) { edge { tracing { traceObservers { errors { message type } traceObservers { endpoints { agent { host port } endpointType https { host port url } status } id name providerRegion } } } } } } } Click the triangle button to execute the query or press Ctrl+Enter. Check the right pane showing the results: In traceObservers, if you see an AWS region (providerRegion) appropriate for your location, copy its associated https: url value to use later as YOUR_TRACE_OBSERVER_URL in Send test data to the trace observer. If you don't see any values in traceObservers as shown below, continue to Step C. Create a new one. Step C. If you can't find an existing trace observer endpoint, create a new one If you didn't find a trace observer after running the query in the previous section, you need to create one. To do this, you execute a GraphQL mutation that passes your configuration details. Copy the following into the middle pane of the NerdGraph API explorer. mutation { edgeCreateTraceObserver(accountId: YOUR_ACCOUNT_ID, traceObserverConfigs: {name: \"YOUR_DESCRIPTIVE_NAME\", providerRegion: YOUR_PROVIDER_REGION}) { responses { errors { message type } traceObserver { endpoints { agent { host port } endpointType https { host port url } status } id name providerRegion } } } } Insert your own values into the mutation: Value Description YOUR_ACCOUNT_ID Replace this with your account ID (the number next to your account name in NerdGraph API explorer). YOUR_DESCRIPTIVE_NAME Replace this with a name that describes the services that report to this trace observer (for example, production or query services). YOUR_PROVIDER_REGION Replace this with the provider region enum value for your location: AWS_EU_WEST_1 AWS_US_EAST_1 AWS_US_WEST_2 Click the triangle button to execute the mutation or press Ctrl+Enter. In the right pane showing the results, copy the value of https: url to a text file so you can use it later as YOUR_TRACE_OBSERVER_URL in Send test data to the trace observer: Step D. Send data to the trace observer Here's a test that includes a sample payload with one trace and two spans from the same service: Test Service A. Follow these steps to send a test request: Get or generate your Insert API key so you can use it later in the test. Copy the following curl request into a text editor: curl request curl -i -H \"Content-Type: application/json\" \\ -H \"Api-Key: YOUR_INSERT_API_KEY\" \\ -H 'Data-Format: newrelic' \\ -H 'Data-Format-Version: 1' \\ -X POST \\ -d '[ { \"common\": { \"attributes\": { \"environment\": \"staging\" } }, \"spans\": [ { \"trace.id\": \"123456\", \"id\": \"ABC\", \"attributes\": { \"duration.ms\": 12.53, \"host\": \"host123.test.com\", \"name\": \"/home\", \"service.name\": \"Test Service A\" } }, { \"trace.id\": \"123456\", \"id\": \"DEF\", \"attributes\": { \"duration.ms\": 2.97, \"host\": \"host456.test.com\", \"error.message\": \"Invalid credentials\", \"name\": \"/auth\", \"parent.id\": \"ABC\", \"service.name\": \"Test Service B\" } } ] } ]' \\ 'YOUR_TRACE_OBSERVER_URL' Insert your own values into the curl request: Value Description YOUR_INSERT_API_KEY Replace this with your Insert API key (not the same as your personal API key for NerdGraph API explorer) YOUR_TRACE_OBSERVER_URL Replace this with the value under https: url from above. Copy the content of the text editor into a terminal, and then execute the request. If the test does not return HTTP/1.1 202 Accepted indicating success, check the following and try again: Confirm that you substituted the url (not host) value for YOUR_TRACE_OBSERVER_URL. Confirm that you only have single quotes around the value you inserted for YOUR_TRACE_OBSERVER_URL. Check that you are using the Insert API Key (not a license). If your test returned HTTP/1.1 202 Accepted, go to our UI to see a query of your test data using the span attribute service.name = Test Service A. Because the sample payload contains an error attribute, the error sampler will mark it for keeping. If you modify the payload to remove the error attributes, the random sampler may not choose to keep this particular trace. Traces may take up to one minute to be processed by both the trace observer and the Trace API. JSON requirements and recommendations Requirements and guidelines for trace JSON using the newrelic format: Each JSON payload is an array of objects. Each object should contain a required spans key. Each object may contain an optional common key. Use this if you want share information across multiple spans in a object. Any keys on a span have precedence over the same key in the common block. The value for spans key is a list of span objects. Certain attributes are required, and must be included either in the optional common block, or in each span. Recommended and custom attributes may be optionally included in a list of key/value pairs under a key named attributes, in the optional common block and/or in each span. In the following example POST, there are two spans, both of which will have the trace.id 12345 and the custom attribute host: host123.test.com. The first span has no parent.id, so that is the root of the trace; the second span's parent.id points to the ID of the first. [ { \"common\": { \"attributes\": { \"host\": \"host123.test.com\" } }, \"spans\": [ { \"trace.id\": \"12345\", \"id\": \"abc\", \"attributes\": { \"user.email\": \"bob@newr.com\", \"service.name\": \"my-service\", \"duration.ms\": 750, \"name\": \"my-span\" } }, { \"trace.id\": \"12345\", \"id\": \"def\", \"attributes\": { \"parent.id\": \"abc\", \"service.name\": \"second-service\", \"duration.ms\": 750, \"name\": \"second-span\" } } ] } ] Attributes Review the sections below describing the attributes for the attributes block of a newrelic formatted JSON POST. Required attributes Requests without these attributes will be rejected, and an NrIntegrationError will be generated. These are the only attributes that don't belong under attributes. attribute description id string Unique identifier for this span. trace.id string Unique identifier shared by all spans within a single trace. timestamp long The span's start time in Epoch milliseconds. Defaults to the current time in UTC timezone. Highly recommended attributes While not required, these attributes should be included for the best experience with your data. They are included in the attributes section. attribute default description duration.ms float none Duration of this span in milliseconds. name string none The name of this span. parent.id string none The id of the caller of this span. Value is null if this is the root span. Traces without a root span will not displayed. service.name string none The name of the entity that created this span. Reserved attributes These attributes are currently reserved for internal New Relic usage. While they are not explicitly blocked, we recommend not using them. attribute default description entity.name string service.name This is derived from the service.name attribute. entity.type string service The entity type is assumed to be a service. entity.guid string None The entity.guid is a derived value that uniquely identifies the entity in New Relic's backend. Other attributes You can add any arbitrary attributes you want, with the exception of the restricted attributes. For example, you might want to add attributes like customer.id or user.id to help you analyze your trace data. To learn how to control how spans appear in New Relic (for example, adding errors or setting a span as a datastore span), see Decorate spans. Explore more about distributed tracing: Learn where Trace API data shows up in the UI. Learn how to decorate spans for a richer, more detailed UI experience. For example, you can have spans show up as datastore spans or display errors. Learn about general data limits, required metadata, and response validation. If you don't see your trace data, see Troubleshooting. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.80371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Report traces via the Trace <em>API</em> (<em>New</em> <em>Relic</em> format)",
        "sections": "Report traces via the Trace <em>API</em> (<em>New</em> <em>Relic</em> format)",
        "info": "For <em>New</em> <em>Relic&#x27;s</em> Trace <em>API</em>: how to report traces using the <em>New</em> <em>Relic</em> format. ",
        "category_2": "Trace <em>API</em>",
        "body": "You can send traces in the <em>New</em> <em>Relic</em> format to our Trace <em>API</em> without using a <em>New</em> <em>Relic</em> agent or integration. This is useful if you want to integrate with sources that emit tracing data and require a backend for trace storage. Since distributed systems can generate a lot of trace data, telemetry",
        "breadcrumb": "Contents &#x2F; Understand dependencies &#x2F; Distributed tracing &#x2F; Trace <em>API</em>"
      },
      "id": "5d89dc6028ccbc83ce9cb16f"
    },
    {
      "sections": [
        "Explore NerdGraph using the API Explorer",
        "Before you begin",
        "Build a query to retrieve your name",
        "Click the play button to see the result",
        "Add more fields to your query",
        "Experiment with mutations",
        "Tip",
        "Try your NerdGraph query in the terminal",
        "Next steps"
      ],
      "title": "Explore NerdGraph using the API Explorer",
      "type": "developer",
      "tags": [
        "nerdgraph",
        "mutations",
        "nerdgraph query terminal"
      ],
      "external_id": "df1f04edc2336c69769d946edbaf263a5339bc92",
      "image": "https://developer.newrelic.com/static/0ce8c387a290d7fbd6be155322be9bce/bc8d6/create-account.png",
      "url": "https://developer.newrelic.com/collect-data/get-started-nerdgraph-api-explorer/",
      "published_at": "2020-09-16T01:49:54Z",
      "updated_at": "2020-08-21T01:47:54Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Explore NerdGraph, our GraphQL API, and build the queries you need.",
      "body": "Explore NerdGraph using the API Explorer 25 min NerdGraph is New Relic's GraphQL API. It allows you to get all the information you need in a single request. With NerdGraph API Explorer you don't need to know the query format: using the Query Builder you can browse our entire graph and compose queries just by selecting the items you want and filling out their required values. Before you begin Go to api.newrelic.com/graphiql and log in using your New Relic user ID and password: the NerdGraph API Explorer loads up. Make sure you have a valid New Relic API key. You can create one directly from the NerdGraph API Explorer. Step 1 of 5 Build a query to retrieve your name Time for your first NerdGraph query. Search for your name in the New Relic database: Erase everything in the query editor. Select the following fields in the query explorer in this order: actor, user, name. This GraphQL snippet appears in the editor. { actor { user { name } } } Copy Step 2 of 5 Click the play button to see the result With this query, you're telling NerdGraph to retrieve your name. You're asking for the name field, which is nested within the user field. This refers to the user who owns the API key, which in turn is nested within actor. Click the play button to see the result: It has almost the same shape as the request. All the fields in the Query Builder make up what's called the GraphQL schema, which describes all the available data types and their attributes. To learn more about each field, click the Docs button, or hover over a field in the editor. Step 3 of 5 Add more fields to your query Now you can try adding more fields to your query. The simplest way is clicking the fields in the Query Builder: The API Explorer knows where the attributes should go in the query. In the example, you add the account id and email fields. Once again, running the GraphQL query results in just the data you need, without over or under-fetching data. Notice that the id field has an argument: passing arguments is a powerful way of customizing your NerdGraph queries. Every field and object can contain arguments, so instead of running multiple queries, you just compose the one that you need. { actor { user { name email } account(id: 12345678) } } Copy Step 4 of 5 Experiment with mutations In GraphQL, mutations are a way to execute queries with side effects that can alter the data by creating, updating, or deleting objects (Commonly referred to as CRUD operations in REST APIs). Ready for your first mutation? Erase what's in the editor. Scroll down the Query Builder and expand mutation. Select the fields in the following screenshot: In this case, you're trying to add a custom tag to an entity. Notice that the editor complains if you don't select errors: mutations must have a way of telling you how the operation performed in the backend (failed requests result in null responses). Tip Unlike REST, GraphQL APIs like NerdGraph can return partial responses. For example, if you try adding tags to multiple entities, some mutations can fail and others succeed; all is logged in the GraphQL response you get. Step 5 of 5 Try your NerdGraph query in the terminal Let's say that you've built a NerdGraph query you're happy with and you want to test it elsewhere. To capture code-ready queries and mutations: Select the Tools menu. Copy the query as a curl call or as a New Relic CLI command. # curl version curl https://api.newrelic.com/graphql \\ -H 'Content-Type: application/json' \\ -H 'API-Key: API_KEY_REDACTED' \\ --data-binary '{\"query\":\"{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id: 12345678)\\n }\\n}\\n\", \"variables\":\"\"}' # New Relic CLI version newrelic nerdgraph query '{ actor { user { name email } account(id: 12345678) } } ' Copy Next steps Now you know the basics of composing and testing NerdGraph queries, but how do you turn them into client or server code? Solutions such as GraphQL Code Generator can help you turn the NerdGraph queries into code for your implementation. Try creating more complex queries by clicking fields and expanding objects in the Query Builder (be careful with mutations though, since they could write data to your account). For more information on NerdGraph and explore other projects from the developer community, check out the threads on the Explorer’s Hub.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.35184,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Explore NerdGraph using the <em>API</em> Explorer",
        "sections": "Explore NerdGraph using the <em>API</em> Explorer",
        "info": "Explore NerdGraph, our GraphQL <em>API</em>, and build the queries you need.",
        "body": " and mutations: Select the Tools menu. Copy the query as a curl call or as a <em>New</em> <em>Relic</em> <em>CLI</em> command. # curl version curl https:&#x2F;&#x2F;<em>api</em>.newrelic.com&#x2F;graphql \\ -H &#x27;Content-Type: application&#x2F;json&#x27; \\ -H &#x27;<em>API</em>-<em>Key</em>: <em>API_KEY</em>_REDACTED&#x27; \\ --data-binary &#x27;{&quot;query&quot;:&quot;{\\n actor {\\n user {\\n name\\n email\\n }\\n account(id"
      },
      "id": "5efa9973196a6791f4766402"
    }
  ],
  "/automate-workflows/kubernetes-helm-deployment": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-16T01:52:28Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-16T01:52:28Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 6213.056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em>",
        "body": " solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min <em>Set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em> Learn how to <em>set</em> <em>up</em> <em>New</em> <em>Relic</em> <em>using</em> <em>Helm</em> <em>charts</em> 30 min Automatically tag a simple &quot;Hello World&quot; Demo across the entire stack See how easy"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "category_2": "Private locations",
      "nodeid": 23821,
      "sections": [
        "Synthetic monitoring",
        "Getting started",
        "Guides",
        "Using monitors",
        "Monitor scripting",
        "Administration",
        "Private locations",
        "UI pages",
        "Synthetics API",
        "Troubleshooting",
        "Install containerized private minions (CPMs)",
        "General private minion features",
        "Kubernetes-specific features",
        "System requirements and compatibility",
        "Private location key",
        "Sandboxing and Docker dependencies",
        "Install and update CPM versions",
        "Start the CPM",
        "Stop or delete the CPM",
        "Show help and examples",
        "Show license information",
        "Configure CPM",
        "Networks",
        "Security, sandboxing, and running as non-root",
        "Docker image repository",
        "Additional considerations for CPM connection",
        "For more help"
      ],
      "title": "Install containerized private minions (CPMs)",
      "category_0": "Synthetic monitoring",
      "type": "docs",
      "category_1": "Synthetic monitoring",
      "external_id": "63c77c4ba313098967f23929294f2cbc2f8d31d3",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/img-integration-k8s@2x.png",
      "url": "https://docs.newrelic.com/docs/synthetics/synthetic-monitoring/private-locations/install-containerized-private-minions-cpms",
      "published_at": "2020-09-16T06:07:31Z",
      "updated_at": "2020-08-13T23:22:19Z",
      "breadcrumb": "Contents / Synthetic monitoring / Synthetic monitoring / Private locations",
      "document_type": "page",
      "popularity": 1,
      "info": "Install New Relic's Docker-based private minion that accepts and runs the jobs assigned to your private locations",
      "body": "You may not modify any CPM files and New Relic is not liable for any modifications you make. For more information, contact your account representative or a New Relic technical sales rep. Read on to learn about the New Relic containerized private minion (CPM), a Docker container-based private minion that accepts and executes synthetic monitors against your private locations. The CPM can operate in a Docker container system environment or a Kubernetes container orchestration system environment. The CPM will auto-detect its environment to select the appropriate operating mode. General private minion features Because the CPM operates as a container instead of a virtual machine, it delivers many features: Easy to install, start, and update Runs on: Linux macOS Windows Enhanced security and support for non-root user execution Ability to leverage a Docker container as a sandbox environment Customizable monitor check timeout Custom provided modules for scripted monitor types Kubernetes-specific features Also, the CPM delivers the following features in a Kubernetes environment: Integrates with the Kubernetes API to delegate runtime lifecycle management to Kubernetes Does not require privileged access to the Docker socket Supports hosted and on-premise Kubernetes clusters Supports various container engines such as Docker and Containerd Deployable via Helm charts as well as configuration YAMLs Allows job (ping vs. non-ping checks) based resource allocation for optimum resource management Observability offered via the New Relic One Kubernetes cluster explorer System requirements and compatibility To host CPMs, your system must meet the minimum requirements for the chosen system environment. Docker container system environment requirements Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Memory 2.5 GB of RAM per CPU core (dedicated) Disk space A minimum of 10 GB per host Docker version Docker 17.12.1-ce or higher Private location key You must have a private location key Kubernetes container orchestration system environment requirements (CPM v3.0.0 or higher) Compatibility for Requirements Operating system Linux kernel: 3.10 or higher macOS: 10.11 or higher Windows: Windows 10 64-bit or higher Processor A modern, multi-core CPU Minion pod CPU (vCPU/Core): 0.5 up to 0.75 Memory: 800 Mi up to 1.6 Gi Resources allocated to a Minion pod are user configurable. Runner pod CPU (vCPU/Core): 0.5 up to 1 Memory: 1.25 Gi up to 3 Gi For a Scripted API check, 1.25 Gi will be requested with a limit of 2.5 Gi. For a Simple Browser or Scripted Browser check, 2 Gi will be requested with a limit of 3 Gi. Additional considerations: Resources allocated to a Runner pod are not user configurable. The maximum limit-request resource ratio for both CPU and Memory is 2. Disk space Persistent volume (PV) of at least 10 Gi in size Note that if a ReadWriteOnce (RWO) PV is provided to the minion, an implicit node affinity will be established to ensure the minion and the runner containers are scheduled on the same node. This is required to allow the minion and the associated runners access to the PV, as an RWO PV can be accessed only by a single node in the cluster. Kubernetes version We recommend that your Kubernetes cluster supports Kubernetes v1.15. Private location key You must have a private location key Helm Follow installation instructions for Helm v3 for your OS. Kubectl Follow installation instructions for Kubectl for your OS. To view versions, dependencies, default values for how many runner pods start with each minion, the Persistent volume access mode, and more, please see Show help and examples below. Private location key Before launching CPMs, you must have a private location key. Your CPM uses the key to authenticate against New Relic and run monitors associated with that private location. To find the key for existing private location: Go to one.newrelic.com > Synthetics > Private locations. In the Private locations index, locate the private location you want your CPM to be assigned to. Note the key associated with the private location with the key key icon. Sandboxing and Docker dependencies Sandboxing and Docker dependencies are applicable to the CPM in a Docker container system environment. Docker dependencies The CPM runs in Docker and is able to leverage Docker as a sandboxing technology. This ensures complete isolation of the monitor execution, which improves security, reliability, and repeatability. Every time a scripted or browser monitor is executed, the CPM creates a brand new Docker container to run it in called a runner. The minion container needs to be configured to communicate with the Docker engine in order to spawn additional runner containers. Each spawned container is then dedicated to run a check associated with the synthetic monitor running on the private location the minion container is associated with. There are two crucial dependencies at launch. To enable sandboxing, ensure that: Your writable and executable directory is mounted at /tmp. The writable directory can be any directory you want the CPM to write into, but New Relic recommends the system's own /tmp to make things easy. Your writable Docker UNIX socket is mounted at /var/run/docker.sock or DOCKER_HOST environment variable. For more information, see Docker's Daemon socket option. Core count on the host determines how many runner containers the CPM can run concurrently on the host. Since memory requirements are scaled to the expected count of runner containers, we recommend not running multiple CPMs on the same host to avoid resource contention. For additional information on sandboxing and running as a root or non-root user, see Security, sandboxing, and running as non-root. Install and update CPM versions Both installing and updating the CPM use the same command to pull the latest Docker image from the Quay.io repository where the CPM Docker image is hosted. Go to quay.io/repository/newrelic/synthetics-minion for a list of all the releases. CPM images are also hosted on Docker Hub. Go to hub.docker.com/r/newrelic/synthetics-minion/tags for a list of all the releases. Start the CPM To start the CPM, follow the applicable Docker or Kubernetes instructions. Docker start procedure Locate your private location key. Ensure you've enabled Docker dependencies for sandboxing and installed CPM on your system. Run the appropriate script for your system. Tailor the common defaults for /tmp and /var/run/docker.sock in the following examples to match your system. Linux/macOS: docker run \\ --name YOUR_CONTAINER_NAME \\ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" \\ -v /tmp:/tmp:rw \\ -v /var/run/docker.sock:/var/run/docker.sock:rw \\ quay.io/newrelic/synthetics-minion:latest Windows: docker run ^ --name YOUR_CONTAINER_NAME ^ -e \"MINION_PRIVATE_LOCATION_KEY=YOUR_PRIVATE_LOCATION_KEY\" ^ -v /tmp:/tmp:rw ^ -v /var/run/docker.sock:/var/run/docker.sock:rw ^ quay.io/newrelic/synthetics-minion:latest When a message similar to Synthetics Minion is ready and servicing location YOUR_PRIVATE_LOCATION_LABEL appears, your CPM is up and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. Set up the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy the Helm charts from the New Relic Helm repo. If you are copying the charts for the first time: helm repo add YOUR_REPO_NAME https://helm-charts.newrelic.com/charts If you previously copied the Helm charts from the New Relic Helm repo, then get the latest: helm repo update Install the CPM with the following Helm command: For a fresh installation of the CPM: helm install YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY To update an existing CPM installation: helm upgrade YOUR_CPM_NAME YOUR_REPO_NAME/synthetics-minion -n YOUR_NAMESPACE --set synthetics.privateLocationKey=YOUR_PRIVATE_LOCATION_KEY Check if the minion pod is up and running: kubectl get -n YOUR_NAMESPACE pods Once the status attribute of each pod is shown as running, your CPM is up and ready to run monitors assigned to your private location. Stop or delete the CPM On a Docker container system environment, use the Docker stop procedure to stop the CPM from running. On a Kubernetes container orchestration system environment, use the Kubernetes delete procedure to stop the CPM from running. Docker stop procedure You can stop a Docker container either by the container name, or the container ID. Container name stop for Linux, macOS, and Windows: docker stop YOUR_CONTAINER_NAME docker rm YOUR_CONTAINER_NAME Container ID stop for Linux/macOS: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. CONTAINER_ID=$(docker ps -aqf name=YOUR_CONTAINER_NAME) docker stop $CONTAINER_ID docker rm $CONTAINER_ID Container ID stop for Windows: In the examples the container is stopped and removed. To only stop the container, omit docker rm $CONTAINER_ID. FOR /F \"tokens=*\" %%CID IN ('docker ps -aqf name=YOUR_CONTAINER_NAME') do (SET CONTAINER_ID=%%CID) docker stop %CONTAINER_ID% docker rm %CONTAINER_ID% Kubernetes delete procedure Get the MINION_POD_INSTALLATION_NAME of the minion pod you want to delete: helm list -n YOUR_NAMESPACE Delete the minion pod: helm uninstall -n YOUR_NAMESPACE MINION_POD_INSTALLATION_NAME Delete the namespace set up for the CPM in your Kubernetes cluster: kubectl delete namespace YOUR_NAMESPACE Show help and examples Use these options as applicable: To get a list of the most commonly used run options directly in the command line interface, run the show help command. To show CPM usage examples as well as the list of all the available run options, run this command: docker run quay.io/newrelic/synthetics-minion:latest help To keep track of Docker logs and verify the health of your monitors, see Containerized private minion (CPM) maintenance and monitoring. For a CPM in the Kubernetes container orchestration system environment, the following Helm show commands can be used to view the chart.yaml and the values.yaml, respectively: helm show chart YOUR_REPO_NAME/synthetics-minion helm show values YOUR_REPO_NAME/synthetics-minion Show license information To show the licensing information for the open source software that we use in the CPM, run the LICENSE command. Run this command to view license information for CPM versions 2.2.27 or higher: docker run quay.io/newrelic/synthetics-minion:latest LICENSE Some of our open-source software is listed under multiple software licenses, and in that case we have listed the license we've chosen to use. Our license information is also available in the our licenses documentation. Configure CPM You can configure the containerized private minion with custom npm modules, preserve data between launches, use environment variables, and more. For more information, see CPM configuration. Networks For both Docker and Kubernetes, the CPM and its runner containers will inherit network settings from the host. For an example of this on a Docker container system environment, see the Docker site. A new bridge network is created for each runner container. This means networking command options like --network and --dns passed to the CPM container at launch (such as through Docker run commands on a Docker container system environment) are not inherited or used by the runner containers. When these networks are created, they pull from the default IP address pool configured for daemon. For an example of this on a Docker container system environment, see the Docker site. Typically, the runner network is removed after the check is completed. However, if a CPM exits while a check is still running, or exits in another unexpected circumstance, these networks may get orphaned. This can potentially use up IP address space that is available to the Docker daemon. If this happens, you may see INTERNAL ENGINE ERROR code: 31 entries in your CPM logging when trying to create a new runner container. To clean these up in Docker container system environments only, run docker network prune. Security, sandboxing, and running as non-root By default, the software running inside a CPM is executed with root user privileges. This is suitable for most scenarios, as the execution is sandboxed. In a Docker container system environment: To change the default AppArmor profile used by containers that CPM spawns to run monitors, see the environment variable MINION_RUNNER_APPARMOR (CPM version 3.0.3 or higher) or MINION_DOCKER_RUNNER_APPARMOR (CPM version up to v3.0.2). To run the CPM as a non-root user, additional steps are required: Run as non-root user for Docker For more information, see Docker's official documentation about security and AppArmor security profiles. If your environment requires you to run the CPM as a non-root user, follow this procedure. In the following example, the non-root user is my_user. Ensure that my_user can use the Docker engine on the host: Verify that my_user belongs to the \"docker\" system group. OR Enable the Docker TCP socket option, and pass the DOCKER_HOST environment variable to CPM. Verify that my_user has read/write permissions to all the directories and volumes passed to CPM. To set these permission, use the chmod command. Get the uid of my_user for use in the run command: id -u my_user. Once these conditions are met, use the option \"-u <uid>:<gid>\" when launching CPM: docker run ... -u 1002 ... OR docker run ... -u 1002 -e DOCKER_HOST=http://localhost:2375 ... Docker image repository A single CPM Docker image serves both the Docker container system environment and Kubernetes container orchestration system environment. The Docker image is hosted on quay.io. To make sure your Docker image is up-to-date, see the quay.io newrelic/synthetics-minion repository. Additional considerations for CPM connection Connection Description CPMs without Internet access A CPM can operate without access to the internet, but with some exceptions. The public internet health check can be disabled using the environment variables named MINION_NETWORK_HEALTHCHECK_DISABLED for a Docker container system environment or synthetics.minionNetworkHealthCheckDisabled for a Kubernetes container orchestration system environment. The CPM needs to be able to contact the \"synthetics-horde.nr-data.net\" domain. This is necessary for it to report data to New Relic and to receive monitors to execute. Ask your network administration if this is a problem and how to set up exceptions. Communicate with Synthetics via a proxy To set up communication with New Relic by proxy, use the environment variables named MINION_API_PROXY*. Arguments passed at launch This applies to a Docker container environment only. Arguments passed to the CPM container at launch do not get passed on to the containers spawned by the CPM. Docker has no concept of \"inheritance\" or a \"hierarchy\" of containers, and we don't copy the configuration that is passed from CPM to the monitor-running containers. The only shared configuration between them is the one set at the Docker daemon level. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.29817,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Using</em> monitors",
        "info": "Install <em>New</em> <em>Relic&#x27;s</em> Docker-based private minion that accepts and runs the jobs assigned to your private locations",
        "body": " appears, your CPM is <em>up</em> and ready to run monitors assigned to that location. Kubernetes start procedure Locate your private location key. <em>Set</em> <em>up</em> the a namespace for the CPM in your Kubernetes cluster: kubectl create namespace YOUR_NAMESPACE Copy the <em>Helm</em> <em>charts</em> from the <em>New</em> <em>Relic</em> <em>Helm</em> repo. If you"
      },
      "id": "5f31d981196a678103fbd731"
    },
    {
      "category_2": "Get started",
      "nodeid": 27301,
      "sections": [
        "Kubernetes integration",
        "Get started",
        "Installation",
        "Understand and use data",
        "Link apps and services",
        "Kubernetes events",
        "Logs",
        "Troubleshooting",
        "Introduction to the Kubernetes integration",
        "Get started: Install the Kubernetes integration",
        "Why it matters",
        "Navigate all your Kubernetes events",
        "Bring your cluster logs to New Relic",
        "Check the source code",
        "For more help"
      ],
      "title": "Introduction to the Kubernetes integration",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Kubernetes integration",
      "external_id": "4ad996d529753d173874d752239ece44c8e6d43f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/kubernetes-integration/get-started/introduction-kubernetes-integration",
      "published_at": "2020-09-16T01:53:05Z",
      "updated_at": "2020-08-05T01:57:55Z",
      "breadcrumb": "Contents / Integrations / Kubernetes integration / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "New Relic's Kubernetes integration: features, requirements, and getting started. ",
      "body": "New Relic's Kubernetes integration gives you full observability into the health and performance of your environment, no matter whether you run Kubernetes on-premises or in the cloud. With our cluster explorer, you can cut through layers of complexity to see how your cluster is performing, from the heights of the control plane down to applications running on a single pod. one.newrelic.com > Kubernetes cluster explorer: The cluster explorer is our powerful, fully visual answer to the challenges associated with running Kubernetes at a large scale. You can see the power of the Kubernetes integration in the cluster explorer, where the full picture of a cluster is made available on a single screen: nodes and pods are visualized according to their health and performance, with pending and alerting nodes in the innermost circles. Predefined alert conditions help you troubleshoot issues right from the start. Clicking each node reveals its status and how each app is performing. Get started: Install the Kubernetes integration We have an automated installer to help you with many types of installations: servers, virtual machines, and unprivileged environments. It can also help you with installations in managed services or platforms, but you'll need to review a few preliminary notes before getting started. Here's what the automated installer does: Asks for the cluster name and namespace of the integration. Asks for additional setup options, such as Kube state metrics. Asks for the installation method: manifest file or Helm. Generates either the manifest or Helm chart. Read the install docs Start the installer If your New Relic account is in the EU region, access the automated installer from one.eu.newrelic.com. Why it matters Governing the complexity of Kubernetes can be challenging; there's so much going on at any given moment, with containers being created and deleted in a matter of minutes, applications crashing, and resources being consumed unexpectedly. Our integration helps you navigate Kubernetes abstractions across on-premises, cloud, and hybrid deployments. In New Relic, you can build your own charts and query all your Kubernetes data, which our integration collects by instrumenting the container orchestration layer. This gives you additional insight into nodes, namespaces, deployments, replica sets, pods, and containers. one.newrelic.com > Dashboards: Using the chart builder you can turn any query on Kubernetes data to clear visuals. With the Kubernetes integration you can also: Link your APM data to Kubernetes to measure the performance of your web and mobile applications, with metrics such as request rate, throughput, error rate, and availability. Monitor services running on Kubernetes, such as Apache, NGINX, Cassandra, and many more (see our tutorial for monitoring Redis on Kubernetes). Create new alert policies and alert conditions based on your Kubernetes data, or extend the predefined alert conditions. These features are in addition to the data New Relic already reports for containerized processes running on instrumented hosts. Navigate all your Kubernetes events The Kubernetes events integration, which is installed separately, watches for events happening in your Kubernetes clusters and sends those events to New Relic. Events data is then visualized in the cluster explorer. To set it up, check the Kubernetes events box in step 3 of our install wizard, or follow the instructions. one.newrelic.com > Kubernetes cluster explorer > Events: Browse and filter all your Kubernetes events, and dig into application logs and infrastructure data. Bring your cluster logs to New Relic Our Kubernetes plugin for log monitoring can collect all your cluster's logs and send them to our platform, so that you can set up new alerts and charts. To set it up, check the Log data box in step 3 of our install wizard, or follow the instructions. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or you can create your own fork and build it. For more information, see the README. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.21873,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Bring your cluster logs to <em>New</em> <em>Relic</em>",
        "info": "<em>New</em> <em>Relic&#x27;s</em> Kubernetes integration: features, requirements, and getting started. ",
        "body": " data. Bring your cluster logs to <em>New</em> <em>Relic</em> Our Kubernetes plugin for log monitoring can collect all your cluster&#x27;s logs and send them to our platform, so that you can <em>set</em> <em>up</em> <em>new</em> alerts and <em>charts</em>. To <em>set</em> it <em>up</em>, check the Log data box in step 3 of our install wizard, or follow the instructions. Check"
      },
      "id": "5cf9564164441f8f472a9169"
    },
    {
      "image": "https://developer.newrelic.com/static/kubecon-europe-2020-b989ec0e7b4ed71a89666c35fe934433.jpg",
      "url": "https://developer.newrelic.com/kubecon-europe-2020/",
      "sections": [
        "KubeCon and CloudNativeCon Europe 2020",
        "New Relic welcomes you at Virtual Kubecon and CloudNativeCon Europe 2020!",
        "Attend one of our lightning talks",
        "Note",
        "We handle Prometheus, you keep Grafana",
        "How to use and customize Helm charts",
        "Kubernetes observability with context",
        "What is OpenTelemetry and how to get started?",
        "OpenTelemetry Architecture",
        "Kubernetes in the wild: best practices",
        "Want some action now? Check out the following videos!",
        "How to use the Kubernetes cluster explorer",
        "What is OpenTelemetry?",
        "Connecting Prometheus and Grafana to New Relic"
      ],
      "published_at": "2020-09-16T01:49:54Z",
      "title": "New Relic Developers",
      "updated_at": "2020-08-15T01:43:38Z",
      "type": "developer",
      "external_id": "53cb6afa4f4062ba359559e9fb3bb2406ece2ad4",
      "document_type": "page",
      "popularity": 1,
      "body": "KubeCon and CloudNativeCon Europe 2020 New Relic welcomes you at Virtual Kubecon and CloudNativeCon Europe 2020! Learn more about the New Relic One platform, the only observability platform that provides open, connected and programmable observability for cloud-native environments. Join us to dive into the New Relic One platform and our Kubernetes cluster explorer. Register here Attend one of our lightning talks Note Go to the virtual expo tab, and find New Relic in Silver Hall B to attend a lightning talk. We handle Prometheus, you keep Grafana Mon Aug 17 @ 14:35 CEST Samuel Vandamme How to use and customize Helm charts Mon Aug 17 @ 16:25 CEST Douglas Camata Kubernetes observability with context Tue Aug 18 @ 15:05 CEST Stijn Polfliet What is OpenTelemetry and how to get started? Tue Aug 18 @ 17:15 CEST Lavanya Chockaligam How to use and customize Helm charts Wed Aug 19 @ 15:05 CEST Douglas Camata OpenTelemetry Architecture Wed Aug 19 @ 16:25 CEST John Watson Kubernetes in the wild: best practices Thu Aug 20 @ 15:05 CEST Martin Fuentes Kubernetes observability with context Thu Aug 20 @ 16:50 CEST Stijn Polfliet Want some action now? Check out the following videos! How to use the Kubernetes cluster explorer What is OpenTelemetry? Connecting Prometheus and Grafana to New Relic",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.01899,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> Developers",
        "sections": "How to <em>use</em> and customize <em>Helm</em> <em>charts</em>",
        "body": " to <em>use</em> and customize <em>Helm</em> <em>charts</em> Mon Aug 17 @ 16:25 CEST Douglas Camata Kubernetes observability with context Tue Aug 18 @ 15:05 CEST Stijn Polfliet What is OpenTelemetry and how to get started? Tue Aug 18 @ 17:15 CEST Lavanya Chockaligam How to <em>use</em> and customize <em>Helm</em> <em>charts</em> Wed Aug 19 @ 15:05 CEST"
      },
      "id": "5f373dcae7b9d20949909274"
    },
    {
      "nodeid": 16176,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Plan your cloud adoption",
        "Optimize your cloud native environment",
        "Optimize your cloud spend",
        "1. Deploy the New Relic Infrastructure agent",
        "2. Create dashboard charts for cloud performance",
        "3. Configure the Amazon AWS integration",
        "4. Set up billing budgets in AWS",
        "5. Add cloud spend and budget widgets to Insights dashboard",
        "6. Create dashboards for every level of your organization",
        "7. Set up alerts",
        "For more help"
      ],
      "title": "Optimize your cloud spend",
      "type": "docs",
      "external_id": "2f064e99493b6d1ee5b3684b6be93f466ec74929",
      "image": "https://docs.newrelic.com/sites/default/files/styles/inline_660px/public/thumbnails/image/CloudPerformanceForAppXwSpend.png?itok=ODnQ9YW4",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/optimize-your-cloud-spend",
      "published_at": "2020-09-13T22:36:58Z",
      "updated_at": "2020-09-10T10:13:47Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Plan your cloud adoption",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic to keep control of your cloud spending costs, and get your teams alerted when you go over your budgets.",
      "body": "Now that you are using cloud-hosted infrastructure and services, it is important to start looking very early and very closely at your cloud spend: Make sure that your assumptions about your cloud spend are playing out as expected. Quickly catch and correct any unexpected spikes in spending. Start fine-tuning the usage of your cloud-based resources. For example, if you have a set of 20 instances all running at 10% CPU, you can think about using smaller instances or consolidating more work onto those instances. This kind of thinking about your cloud spend helps you optimize and save money quickly. New Relic can help you monitor all this. From a data perspective, it is really just another metric that our platform can collect for you. As with any other metric, you can visualize, report, and alert on your cloud spend data, just like you can with any data New Relic can help you collect. Using the New Relic applied intelligence platform is a great way to help you learn about your cloud spending or about any of your performance data. 1. Deploy the New Relic Infrastructure agent Review the requirements for the New Relic Infrastructure agent and follow the documentation for instructions on installing the agent. After you install the Infrastructure agent on your hosts, you immediately have access to the broad spectrum of metrics that the agent receives automatically. Then, you can set up the cloud integration to start collecting billing information. 2. Create dashboard charts for cloud performance New Relic Dashboards is the product that you use to write powerful custom queries about your data, and then visualize the results in charts that you collect on a dashboard. You can also feed the results of your dashboard queries directly into New Relic Alerts, where you can get notifications on any deviations that you specify. Include charts for various Infrastructure metrics related to performance and usage; for example: CPU Memory Disk Database You may also want to include charts that represent the application using this cloud infrastructure. In this way you can correlate the cloud infrastructure performance with that of the application. As you right-size your cloud infrastructure, you will want to monitor application performance to make sure you are achieving any targets. Here is an example of an Insights dashboard for cloud performance. Break out data by cloud performance and application metrics The following dashboard shows several charts that present key cloud infrastructure metrics and an associated application metric. Every one of these charts represents the result of a query. [Downs: Updated image based on New Relic One can be found at: https://www.dropbox.com/s/rjq7tqrswxwtte9/Tutorial-Run-OptimizeCloudSpen... Image caption: one.newrelic.com > Dashboards: Create dashboards that include both cloud infrastructure and application metrics.] insights.newrelic.com: Create dashboards that include both cloud infrastructure and application metrics. 3. Configure the Amazon AWS integration New Relic Infrastructure comes with several types of integrations, including Amazon Web Services (AWS), Microsoft Azure, and on-host integrations. This tutorial focuses on the AWS Billing integration. First, configure the integration with your AWS account, and then you can set up the AWS Billing integration. 4. Set up billing budgets in AWS The Amazon AWS Billing integration requires some additional configuration on the AWS side. Specifically, you need to go into your AWS Billing dashboard and set up Budgets. Our documentation and the blog post Show Me (Where I’m Spending) the Money! AWS Billing Comes to New Relic Insights provide walk-throughs of this process. When creating Budgets, be sure to: Fill in an application name. Decide whether you are doing cost or service-based budgeting. Decide if your budget is open-ended or has a definite ending date. 5. Add cloud spend and budget widgets to Insights dashboard New Relic Insights is the product that you use to write powerful custom queries about your data, and then visualize the results in widgets that you collect on a dashboard. You can also feed the results of your Insights queries directly into New Relic Alerts, where you can get notifications on any deviations that you specify. Here are some examples of ways to use Insights dashboards to visualize your AWS cloud spend data. Break out data by application and by AWS budget The following dashboard shows several widgets that present key information about an AWS budget vs. actual spending, with data broken out by an application AWS budget. Every one of these widgets represents the result of an Insights query, and the data in the supporting Insights tables is the data that our integration automatically receives from AWS. [Downs: Updated image based on New Relic One can be found at: https://www.dropbox.com/s/ecp5mrnkezh6hjh/Tutorial-Run-OptimizeCloudSpen... Image caption: one.newrelic.com > Dashboards: Add charts that include AWS cloud and budgets data.] [Downs: put this 'code' section below the image please. Here is the query to create the Application X Cloud Cost budget chart in this dashboard example: SELECT latest(`provider.actualAmount`) as '$ Actual', latest(`provider.forecastedAmount`) as '$ Forecast', max(`provider.limitAmount`) as '$ Limit' FROM FinanceSample WHERE provider = 'BillingBudget' AND `provider.budgetName` = 'NAME_OF_YOUR_CLOUD_BUDGET' ] insights.newrelic.com: Create dashboards that include AWS cloud and budgets. 6. Create dashboards for every level of your organization Whether you are a developer, in DevOps, or an executive, having information about your cloud spend can help you optimize your cloud environment. Here are a few ways dashboards can help at each level of your organization: Dashboards for developers Understanding how much applications cost to run helps developers properly configure applications to use more efficient services. For example, could developers save cloud costs using Amazon AWS Lambda or properly sized instances instead of randomly selecting an instance? Dashboards for DevOps Monitoring application costs allows operators to catch possible overruns due to misconfigured services. For example, is the DevOps team’s auto-scaling configuration not scaling down properly? Are they spending money on instances that are not being used? Dashboards for executives An overall view of both forecasted and actual cloud spends for individual applications on a per region basis, as well as total costs, helps executives make better business decisions. Use New Relic to keep control of your cloud spending costs, and get your teams alerted when you go over your budgets. 7. Set up alerts After you write queries on your data in Insights, you can easily use them to create alert conditions. New Relic gives you the ability to write baseline queries against your data. A baseline query is a query that you write without setting hard limits on the results and instead let New Relic Applied Intelligence “machine-learn” your performance data. New Relic alerts you when you go too far outside of your baseline numbers. Configure a baseline query using the forecasted amount Configuring a baseline query using a forecasted amount is a great starting point for monitoring any cloud budget, as you grow to understand what your cloud spend will be over time. New Relic notifies you if something spikes beyond your forecasted trend. That query looks like this: SELECT latest(`provider.forecastedAmount`) FROM FinanceSample WHERE provider = 'BillingBudget' and `provider.budgetName` = 'NAME_OF_YOUR_CLOUD_BUDGET' When you create a baseline query and alert on it, you decide how restrictively Applied Intelligence should analyze your data using a simple slider and visualization based on your recent performance. The slider either increases or decreases the gray band around your budget threshold (the blue line): alerts.newrelic.com > Alert policies > (select a policy) > Alert conditions: Create alert conditions based on your NRQL queries and Insights data. This example would have resulted in zero violations based on recent data, and that is exactly what you are looking for. However, if that blue line spikes up out of the gray band, New Relic notifies you. For more detailed information about creating, managing, and using alerts, view these New Relic University tutorials: Intro to alerting Alert policies Alerting incident lifecycle Notification channels For more help",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.646835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>New</em> <em>Relic</em> solutions",
        "info": "<em>Use</em> <em>New</em> <em>Relic</em> to keep control of your cloud spending costs, and get your teams alerted when you go over your budgets.",
        "body": " cloud spending costs, and get your teams alerted when you go over your budgets. 7. <em>Set</em> <em>up</em> alerts After you write queries on your data in Insights, you can easily <em>use</em> them to create alert conditions. <em>New</em> <em>Relic</em> gives you the ability to write baseline queries against your data. A baseline query",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; Plan your cloud adoption"
      },
      "id": "5f59fc5b196a672f27ce6a45"
    }
  ],
  "/explore-docs/query-and-store-data": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-16T01:48:56Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.69963,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "nerdstorage <em>components</em>",
        "body": " and EntityStorage<em>Mutation</em> Each of these <em>components</em> can operate declaratively (for example, as part of your React rendering <em>methods</em>) or imperatively (by using the <em>static</em> <em>methods</em> for <em>query</em> and <em>mutation</em>). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "category_2": "Java agent release notes",
      "nodeid": 11976,
      "sections": [
        "APM agent release notes",
        "Go agent release notes",
        "Java agent release notes",
        ".NET agent release notes",
        "Node.js agent release notes",
        "PHP agent release notes",
        "Python agent release notes",
        "Ruby agent release notes",
        "C SDK release notes",
        "Java Agent 3.36.0",
        "Improvements",
        "Fixes"
      ],
      "title": "Java Agent 3.36.0",
      "category_0": "Release notes",
      "type": "docs",
      "category_1": "APM agent release notes",
      "external_id": "f94f5c53e522a9835ea42514e90d9a39e81fd050",
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/java-release-notes/java-agent-3360",
      "published_at": "2020-09-13T20:56:09Z",
      "updated_at": "2018-04-14T23:39:35Z",
      "breadcrumb": "Contents / Release notes / APM agent release notes / Java agent release notes",
      "document_type": "release_notes",
      "popularity": -2,
      "body": "[RSS] Released on:  Wednesday, February 15, 2017 - 09:55 Download Improvements APIs This release adds a number of APIs that will allow you to instrument and get expanded visibility into frameworks, libraries, and any custom code that New Relic does not automatically instrument. In addition to instrumenting your web frameworks, you can also instrument calls to and from messaging systems, database calls, and external calls! By passing context about your code to the APIs, you will get the same reporting, including cross application tracing, that you get with New Relic’s built-in instrumentation. Solr This release adds support for Solr versions 5 and 6 (up to and including version 6.3.0). Fixes Fixes a bug that prevents an application from starting up when a JAX-RS annotated method contains more than 8 parameters. Fixes an issue that affected Spring and JAX-RS applications compiled with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using static methods. The agent now reports WildFly dispatcher name and version. Fixes a bug in which Queue Time could be misreported on the Overview page for customers injecting the X-Queue-Start or X-Request-Start HTTP headers. This fix brings the Java Agent into compliance with the behavior of other New Relic Agents. Fixes an issue in which custom Hystrix Commands that are subclassed multiple times in Groovy cause an application to throw an exception on startup.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 47.629112,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " with the Java 8 flag javac -parameters. The issue would cause the application to throw a java.lang.reflect.MalformedParametersException exception. Fixes bug that affected applications implementing JAX-RS endpoints using <em>static</em> <em>methods</em>. The agent now reports WildFly dispatcher name and version. Fixes a bug"
      },
      "id": "58a53cf38e9c0f755a81db4e"
    },
    {
      "category_2": "API guides",
      "nodeid": 11521,
      "sections": [
        "Java agent",
        "Getting started",
        "Installation",
        "Additional installation",
        "Heroku",
        "Configuration",
        "Attributes",
        "Features",
        "Instrumentation",
        "Custom instrumentation",
        "API guides",
        "Async instrumentation",
        "Troubleshooting",
        "Guide to using the Java agent API",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Implement distributed tracing",
        "Implement cross application tracing",
        "Obtain references to New Relic entities",
        "Additional API functionality",
        "Additional API usage examples",
        "For more help"
      ],
      "title": "Guide to using the Java agent API ",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "Java agent",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "external_id": "a31c751c7c29dd46effac2e568f7c0a92b033b18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api",
      "published_at": "2020-09-13T21:01:13Z",
      "updated_at": "2020-09-03T11:06:02Z",
      "breadcrumb": "Contents / APM agents / Java agent / API guides",
      "document_type": "page",
      "popularity": 1,
      "info": "A goal-focused guide to New Relic's Java agent API, with links to relevant sections of the complete API documentation on GitHub.",
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 3.36.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Implement distributed tracing These APIs require distributed tracing to be enabled. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() For more on obtaining references to the current transaction and other entities, see Obtain references. Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) For more on obtaining references to the current transaction and other entities, see Obtain references. Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Implement cross application tracing To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Also refer to the information in this document about using Transaction to obtain references to New Relic entities. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic entities. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic entities. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic entities. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic entities. Obtain references to New Relic entities Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events to Insights. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the first call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic entities. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 41.5464,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: <em>Static</em> <em>methods</em> on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "5a3137f4e621f4576cf1e35f"
    },
    {
      "category_2": "PHP agent API",
      "nodeid": 11821,
      "sections": [
        "PHP agent",
        "Getting started",
        "Installation",
        "Advanced installation",
        "Configuration",
        "API guides",
        "PHP agent API",
        "Attributes",
        "Features",
        "Frameworks and libraries",
        "Troubleshooting",
        "newrelic_add_custom_tracer",
        "Requirements",
        "Description",
        "Parameters",
        "Return value(s)",
        "Example(s)",
        "Instrument a function",
        "Instrument a method within a class",
        "Instrument a method within a namespaced class",
        "For more help"
      ],
      "title": "newrelic_add_custom_tracer (PHP agent API)",
      "category_0": "APM agents",
      "type": "docs",
      "category_1": "PHP agent",
      "external_id": "12242c1e6fe8cb70e2d42ff670cad04c01e9317e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/php-agent-api/newrelic_add_custom_tracer",
      "published_at": "2020-09-13T22:17:22Z",
      "updated_at": "2019-09-30T22:55:59Z",
      "breadcrumb": "Contents » APM agents / PHP agent / PHP agent API",
      "document_type": "api_doc",
      "popularity": 1,
      "info": "New Relic PHP agent API call to add custom instrumentation to particular methods in your app code. ",
      "body": "newrelic_add_custom_tracer(string $function_name) Specify functions or methods for the agent to instrument with custom instrumentation. Requirements Compatible with all agent versions. Description Specify functions or methods for the agent to target for custom instrumentation. This is the API equivalent of the newrelic.transaction_tracer.custom setting. You cannot apply custom tracing to internal PHP functions. Parameters Parameter Description $function_name string Required. The name can be formatted either as function_name for procedural functions, or as \"ClassName::method\" for methods. Both static and instance methods will be instrumented if the method syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return value(s) Returns true if the tracer was added successfully. Example(s) Instrument a function function example_function() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"example_function\"); } } Instrument a method within a class class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"ExampleClass::example_method\"); } } } Instrument a method within a namespaced class namespace Foo\\Bar; class ExampleClass { function example_method() { if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(\"Foo\\\\Bar\\\\ExampleClass::example_method\"); } } } Alternatively, on PHP 5.5 or later, the ::class syntax can be used instead: namespace Foo\\Bar { class ExampleClass { function example_method() { // ... } } } namespace { use Foo\\Bar; if (extension_loaded('newrelic')) { // Ensure PHP agent is available newrelic_add_custom_tracer(Bar::class . \"::example_method\"); } } }",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 26.718744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Instrument a <em>method</em> within a class",
        "info": "New Relic PHP agent API call to add custom instrumentation to particular <em>methods</em> in your app code. ",
        "body": " <em>static</em> and instance <em>methods</em> will be instrumented if the <em>method</em> syntax is used, and the class name must be fully qualified: it must include the full namespace if the class was defined within a namespace. Return value(s) Returns true if the tracer was added successfully. Example(s) Instrument"
      },
      "id": "58ca4191e621f45edd466e7a"
    },
    {
      "nodeid": 9691,
      "sections": [
        "Introduction to New Relic Mobile (Unity)",
        "Contents",
        "Monitor mobile app performance",
        "Install and configure",
        "Use Unity SDK API",
        "Send custom events and attributes to Insights",
        "Track custom network requests",
        "Uninstall plugin",
        "Unity release notes",
        "For more help"
      ],
      "title": "Introduction to New Relic Mobile (Unity)",
      "type": "docs",
      "external_id": "9e03a54ec6df360532302d4dfe7484070f8ba80c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/introduction-new-relic-mobile-unity",
      "published_at": "2020-09-13T14:53:30Z",
      "updated_at": "2020-07-25T00:44:01Z",
      "breadcrumb": "Contents",
      "document_type": "page",
      "popularity": 1,
      "body": "Legacy feature This document is for historical reference. Unity is no longer supported for new customers. Contents Monitor mobile app performance The New Relic Unity plugin allows Unity developers to embed a New Relic Mobile agent (iOS or Android) in a Unity app build for mobile devices to monitor your app's performance. The plugin is written in C#, but it includes the native iOS and Android agents that embed the appropriate files for your build. Features New Relic Mobile Features Comprehensive performance data View your mobile app's performance Overview page for summary information about active sessions, or drill down to detailed information, including (note limitations below): Interaction times and trace details Crash reporting Devices Operating systems Detailed network views Available by using the API to track custom network requests For iOS apps, receive automatic instrumentation for networking for any parts of the app that are native and non-Unity (using standard Apple networking components such as NSURLConnection) Examine HTTP errors and network failures (such as DNS lookups, timeouts, SSL errors, etc.) and server error traces. Usage details at a glance Compare performance between versions of your app with detailed information for memory, CPU (iOS only), interaction speed, network requests per minute, and network failures. View a monthly report with a bar chart tracking the number of devices running your app for each month over the last year. Mobile SDK API options Use the Unity API to: Create and complete interactions Record custom metrics Send custom events to Insights Track custom network requests Known limitations The New Relic Unity plugin does not automatically instrument interactions. You must use the Unity API to track specific interactions. The New Relic Unity plugin does not automatically instrument network requests. You must use the Unity API to track network calls. Android builds: Unity still generates an Eclipse project, but Android Studio can import the Eclipse project. Install and configure The Unity plugin includes iOS and Android agent files that will embed the appropriate files for your build. To instrument interactions and network requests, you must use the Unity API to manually instrument your code. Install the Unity plugin As part of the installation process, New Relic Mobile automatically generates an application token. This is a 40-character hexadecimal string for authenticating each mobile project you monitor in New Relic Mobile. For Admins with existing New Relic accounts, follow these steps to install and configure your Unity application. (If you do not have a New Relic account, see New Relic Mobile.) Go to rpm.newrelic.com/mobile. From the mobile apps index, select Add a new app. From the Get started page, select Unity as the platform for mobile monitoring. Type a name for your mobile project, then select Continue. Continue with the procedures to configure the Unity plugin. Configure the Unity plugin These procedures to configure your app also appear on the Get started page in the New Relic UI. Install NewRelic-Unity-Plugin.unitypackage into your project by going to Assets > Import package > Custom package... and selecting NewRelic-Unity-Plugin.unitypackage. Create a new GameObject in your project's initial scene by going to GameObject > Create empty and naming it NewRelicAgent. Add NewRelicAgent.cs script (located in Assets/Plugins) to the NewRelicAgent GameObject: Drag it on top of NewRelicAgent in the Hierarchy tab. OR Click Add Component button, then select New Relic Agent from the Scripts option. In the Inspector tab, set the iOS or Android application token from your New Relic Mobile apps. (Recommendation: Keep New Relic Mobile apps on separate platforms.) Build for your platform (iOS or Android), then open the resulting project (Xcode or Eclipse). For Eclipse, import the generated project into Android Studio. Android only: Ensure that your app requests the INTERNET permission through the Player Settings inspector window. In Other Settings, Configuration, ensure the Internet access dropdown is set to Required. This will result in the following permission added to the app's manifest: <uses-permission android:name=\"android.permission.INTERNET\" /> Run your app in an emulator or device to generate data. Check New Relic Mobile to ensure the data is reporting to your account. Configure crash reporting The New Relic Unity plugin cannot automatically upload dSYMs for iOS crash reporting. You must manually upload dSYMs once your iOS unity app is built for release. If the application is bitcode enabled, follow the procedures for bitcode enabled apps once the your iOS app is submitted to Apple. If you are building an Android app with ProGuard enabled, you must follow similar steps. The ProGuard mapping must be uploaded to New Relic so crash reports can be de-obfuscated. For more information, see Android agent crash reporting. Optional: Change the logging level Six logging levels are available for mobile apps monitoring: NONE ERROR WARNING INFO VERBOSE DEBUG Recommendation: Set the logging level from the Unity Inspector tab. Use Unity SDK API Use the New Relic Unity SDK API to further configure and extend the plugin's instrumentation. Create and complete interactions To start an interaction: string interactionIdentifier = NewRelicAgent.StartInteractionWithName(\"new interaction\"); To stop the current interaction: NewRelicAgent.StopCurrentInteraction(interactionIdentifier); Interactions work in conjuction with method tracing. To trace a method insert startTracingMethod, insert at the start of the method to trace, and insert endTracingMethodWithTimer at each exit point of the method. To start tracing a method: Timer methodTimer = new Timer(); NewRelicAgent.StartTracingMethod(\"MethodName\",\"ClassName\",methodTimer,NewRelicAgent.NRTraceType.None); To end tracing a method, use the same timer as the startTracingMethod:> NewRelicAgent.EndTracingMethodWithTimer(methodTimer); Set a custom build identifier Custom build identifiers are set as the Application Build property in the inspector pane for the NewRelicAgent game object, under the New Relic Agent (Script) settings. Execute a demo crash If you have trouble getting your project to crash, use the New Relic Unity plugin API to execute a demo crash. Recommendation: Add this line of code to a button click event handler as applicable: NewRelicAgent.CrashNow(\"message\")> Record custom metrics With the custom metric API, you can record arbitrary numerical data and named events. Custom metrics can help to track high level events specific to your application. You can use several API calls to record custom metrics that provide different levels of detail. To create a custom metric, use this method: NewRelicAgent.RecordMetricWithName(String name, String category) The name parameter is the textual name of the metric that will appear in the user interface for New Relic Mobile. Using clear, concise metric names will help you get the most out of the metrics. The guidelines for naming a custom metric include: Use case and white space characters appropriate for display in the user interface. Metric names are rendered as-is. Capitalize the metric name. Avoid using the characters / ] [ | * when naming things. Avoid multi-byte characters. If you want to specify more details about a custom metric, three other API methods are available: NewRelicAgent.RecordMetricWithName(String name, String category, double value) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits) NewRelicAgent.RecordMetricWithName(string name, string category, double value, string valueUnits, string countUnits) With these methods, you can record additional details: Parameter Description count The number of times the event has happened totalValue The total value of the recording exclusiveValue The exclusive value of the recording; for example, if the total value contains measurements accounted for elsewhere countUnit Unit of measurement for the metric count, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS valueUnit Unit of measurement for the metric value, including PERCENT, BYTES, SECONDS, BYTES_PER_SECOND, or OPERATIONS To view the custom metrics you collect, follow standard procedures to create custom dashboards. Send custom events and attributes to Insights The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following static methods in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. Methods that return boolean results return true if they succeed, or false if the operation did not complete. The following methods are available for custom attributes and events: RecordEvent (name, attributes) NewRelicAgent.RecordEvent (string name, string dictionary attributes) Records a custom Insights event. Includes a list of attributes specified as a map. SetAttribute (name, value) NewRelicAgent.SetAttribute (string name, string value) NewRelicAgent.SetAttribute (string name, double value) Creates an attribute with the specified text name and text/float value. SetAttribute overwrites its previous value and type each time it is called. Examples boolean attributeSet = NewRelicAgent.SetAttribute(\"username\", \"SampleUserName\"); boolean attributeSet = NewRelicAgent.SetAttribute(\"rate\", 9999.99); IncrementAttribute (name [, value]) public static boolean IncrementAttribute(String name); public static boolean incrementAttribute(String name, double value) If value is not specified, this method increments the count for the specified attribute by 1. If the attribute does not exist, it creates the attribute with a value of 1. If value is specified, the method will increment the attribute by the specified amount. Examples boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\"); boolean incremented = NewRelicAgent.IncrementAttribute(\"rate\", 9999.99, false); RemoveAttribute (name) NewRelicAgent.RemoveAttribute(String name) Removes the specified attribute. Example boolean attributeRemoved = NewRelicAgent.RemoveAttribute(\"rate\"); removeAllAttributes NewRelicAgent.removeAllAttributes() Removes all attributes from the session. Example boolean attributesRemoved = NewRelicAgent.RemoveAllAttributes(); Track custom network requests New Relic Mobile's API provides several methods to track network requests and network failures. For example, use the noticeHttpTransaction family of methods to record HTTP transactions with several available levels of detail. If a network request fails, you can record details about the failure with noticeNetworkFailure. NoticeNetworkRequest NewRelicAgent.NoticeNetworkRequest (\"http://newrelic.com\", \"GET\", timer, null, 200, 1024, 8192, bytes, httpParameters); Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST statusCode The statusCode of the HTTP response, such as 200 for OK timer A timer created when the network request was started bytesSent The number of bytes sent in the request bytesReceived The number of bytes received in the response responseBody The response body of the HTTP response. The response body will be truncated and included in an HTTP Error metric if the HTTP transaction is an error. params Additional parameters included in an HTTP Error metric if the HTTP transaction is an error. NoticeNetworkFailure NewRelicAgent.NoticeNetworkFailure(String url, String httpMethod, Timer timer, NewRelicAgent.NetworkFailureCode failureCode, String message) Parameter Description url The URL of the request httpMethod The HTTP method used, such as GET or POST timer A timer created when the network request was started exception The exception that occurred. New Relic Mobile can automatically translate many common exceptions into network failure types. failure The type of network failure that occurred. If an exception cannot be resolved to a network failure automatically, this method can be used to categorize the failure accurately. The values are defined by the NetworkFailure enum. Valid values include Unknown, BadURL, TimedOut, CannotConnectToHost, DNSLookupFailed, BadServerResponse, and SecureConnectionFailed. Uninstall plugin To uninstall the Unity plugin, use the project console to remove all related files and resources that were installed with the Unity package: Delete NewRelicAgent object from the Hierarchy pane of the Unity project console. From All Scripts, delete all the scripts that start with newrelic. Then do the following as applicable: From Assets > Plugin > iOS, delete the NewRelicIos, NewRelicUnityPlugin, post-build, and restore-framework files. Then remove the mod_pbxproj and NewRelicAgent.framework directories. From Assets > Plugin > Android, delete the newrelic.android and NewRelicAndroid files. Then remove the LICENSE and README directories. Unity release notes These release notes are for historical reference. Unity is no longer supported for new customers. Unity plugin 1.2.0 Released on: Monday, March 13, 2017 - 13:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.2.0.zip Notes: Updated Unity plugin to iOS agent 5.9.0 and Android agent 5.9.0 Unity plugin 1.1.0 Released on: Tuesday, September 6, 2016 - 14:53 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.1.0.zip Notes: Updated Unity plugin to iOS agent 5.8.0 and Android agent 5.7.1 Unity plugin 1.0.1 Released on: Monday, August 8, 2016 - 14:00 Download URL: https://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.1.zip Notes: Bundle Android class rewriter JAR file (version 5.6.1) into the Unity package. Unity plugin 1.0.0 Released on: Wednesday, May 25, 2016 - 14:00 Download URL: http://download.newrelic.com/unity/NewRelic-Unity-Plugin_1.0.0.zip Notes: This plugin provides New Relic Mobile agent support for iOS and Android applications built with Unity. It also gives Unity developers access to New Relic crash reporting. It provides information about app performance, sessions, devices, operating systems, and more. It also includes APIs for custom instrumentation to gain deeper insights into specific areas of your app. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 18.44682,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " The SDK can store up to 64 user-defined attributes at a time. If you attempt to store more than 64 attributes, the SDK returns false. Use the following <em>static</em> <em>methods</em> in the NewRelicAgent namespace to send custom attributes and events to New Relic Insights. <em>Methods</em> that return boolean results return"
      },
      "id": "5c52cbec8e9c0f0b286080ec"
    }
  ],
  "/automate-workflows/automated-tagging": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/automate-workflows/",
      "sections": [
        "Automate workflows",
        "Guides to automate workflows",
        "Quickly tag resources",
        "Set up New Relic using Helm charts",
        "Automatically tag a simple \"Hello World\" Demo across the entire stack",
        "Automate common tasks",
        "Set up New Relic using the Kubernetes operator",
        "Set up New Relic using Terraform"
      ],
      "published_at": "2020-09-16T01:52:28Z",
      "title": "Automate workflows",
      "updated_at": "2020-09-16T01:52:28Z",
      "type": "developer",
      "external_id": "d4f408f077ed950dc359ad44829e9cfbd2ca4871",
      "document_type": "page",
      "popularity": 1,
      "body": "Automate workflows When building today's complex systems, you want an easy, predictable way to verify that your configuration is defined as expected. This concept, Observability as Code, is brought to life through a collection of New Relic-supported orchestration tools, including Terraform, AWS CloudFormation, and a command-line interface. These tools enable you to integrate New Relic into your existing workflows, easing adoption, accelerating deployment, and returning focus to your main job — getting stuff done. In addition to our Terraform and CLI guides below, find more automation solutions in our Developer Toolkit. Guides to automate workflows 5 min Quickly tag resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically tag a simple \"Hello World\" Demo across the entire stack See how easy it is to leverage automation in your DevOps environment! 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 20 min Set up New Relic using the Kubernetes operator Learn how to provision New Relic resources using the Kubernetes operator 20 min Set up New Relic using Terraform Learn how to provision New Relic resources using Terraform",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 207.90033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Automate</em> workflows",
        "sections": "<em>Automatically</em> <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em>",
        "body": " solutions in our Developer Toolkit. Guides to <em>automate</em> workflows 5 min Quickly <em>tag</em> resources Add tags to apps for easy filtering 20 min Set up New Relic using Helm charts Learn how to set up New Relic using Helm charts 30 min Automatically <em>tag</em> a simple &quot;Hello World&quot; Demo across the <em>entire</em> <em>stack</em> See how easy"
      },
      "id": "5efa999c196a67dfb4766445"
    },
    {
      "image": "https://newrelic.com/content/dam/component-assets/p03-product-image/common/throughput-requests-per-minute.jpeg",
      "url": "https://newrelic.com/resources/ebooks/3-phased-approach-to-observability",
      "sections": [
        "Instrument and tune",
        "Establish baselines and set fundamental alerts",
        "Set SLOs to align teams",
        "Optimize your alerting strategy",
        "Alert Basics",
        "Improve incident response",
        "Enable fast feedback loops ",
        "SLO trend analysis",
        "Visualize the relationships among developers, operations, and customers",
        "Automate instrumentation",
        "10 Observability Best Practices",
        "Reactive phase",
        "Proactive phase",
        "Data-driven phase",
        "Ready to get started on your observability journey?",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-09-15T01:40:22Z",
      "title": "A Three-Phased Approach to Observability",
      "updated_at": "2020-09-15T01:40:22Z",
      "type": "storefront",
      "external_id": "0c965ca049d65dc4eebde832b00cdad9aca501cc",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon EBOOK A Three-Phased Approach to Observability How to improve the customer experience by moving from reactive to data-driven behaviors Introduction Observability Maturity: Reactive Phase Observability Maturity: Proactive Phase Observability Maturity: Data-Driven Phase Observability in New Relic Download PDF Introduction Your customers—regardless if you’re in high tech, manufacturing, healthcare, or financial services—expect a seamless experience each time they engage with you. Customer loyalty is precarious at best, and in response, every company is figuring out how to play offense with software. After all, research shows that highly engaged customers buy 90% more frequently, spend 60% more per purchase, and have three times more annual value than average customers. That’s why you need your infrastructure to scale to your busiest day while continuously delivering delightful, differentiating experiences. But here’s the paradox: How do you support these cutting-edge customer experiences without inadvertently compromising customer experience? The importance of excellent customer experience has been well documented. Bad customer experiences are more powerful than good customer experiences. We’ve all seen the headlines about how a few hours of downtime can cost millions in revenue and more in goodwill. The good news: Pushing new code and leveraging modern infrastructure doesn’t have to be a high-risk proposition. A well-run observability practice enables you to deliver excellent customer experiences with software despite the complexity of the modern digital enterprise.   New Relic defines three phases of observability maturity to chart your path—reactive, proactive, and data-driven. The ultimate goal of any observability practice is an automated, self-healing system that allows your developers to understand the effect of updates on the end user’s digital experience in real time and helps your engineers know not just that a failure occurred, but why.  This ebook dives into each phase of your observability journey and explains the activities and key performance indicators (KPIs) inherent in each. Observability Maturity: Reactive Phase   REACTIVE BEHAVIORS AND RECOMMENDATIONS Instrument and tune Establish baselines and set foundational alerts KPIs: Errors, throughput, latency, traffic, saturation, utilization, Apdex   We’ve all heard the phrase “You can’t improve what you can’t measure.” Accordingly, a strong observability practice starts with putting instrumentation in place to aggregate as much telemetry data about your systems as possible. From there, teams can prioritize eliminating obvious problems. Instrument and tune When choosing what to monitor, involve business stakeholders and digital leaders from your organization. Your goal is to monitor what matters to your business and not to overload your teams with noise. Metrics, events, logs, and traces (or MELT for short) are the essential data types of observability. Aggregating data from disparate sources, including logs, and storing it in one place, gives you the ability to analyze, visualize, and troubleshoot your systems from a single platform. This ability to instrument any data type from any source (proprietary or open source) is critical for observability, as it allows you to get telemetry quickly, no matter the data type, and resolve issues dynamically as they arise. The Four Golden Signals (as laid out in the Google SRE Handbook)—a useful starting point as you baseline your applications.   With all your business-critical observability data in one place, you can reduce the operational burden—and expense—of maintaining other systems for storing, querying, viewing, and alerting on that data. Establish baselines and set fundamental alerts Gathering metrics and performance statistics about your application and infrastructure helps you identify bottlenecks and errors that can lead to instability in your software (and frustration for your users). Remediate your apps by addressing your slowest transactions and the most common errors. Then you can establish a baseline of what “normal” is for your services and systems. Analyze obvious errors to create baseline alert conditions and adjust sensitivity as needed. Mapping service boundary transaction performance to product features is critical to breaking silos between product, operations, engineering, and service owner teams. Observability Maturity: Proactive Phase PROACTIVE BEHAVIORS AND RECOMMENDATIONS Set SLOs Optimize alerting strategy Improve incident response Enable fast feedback loops KPIs: Availability, errors, latency, traffic, saturation, utilization, deploy frequency, lead time for changes, MTTD, MTTR, MTBF, page load time With so many different signals coming from multiple tools, it’s difficult to determine and address the root cause of incidents quickly, let alone detect and respond to issues proactively. Increased complexity in your tech and processes leads to the challenge of investigating and interpreting thousands of “unknown unknowns.” This stage aligns teams by setting SLOs and optimizing your processes to balance system reliability with speed and address issues before they affect your customers. Set SLOs to align teams Service level objectives (SLOs) provide a powerful mechanism to codify a team’s goals in ways that can be measured and shared. They also provide clear boundaries on service expectations that help teams achieve greater velocity and freedom in experimenting with new approaches. If you’re unsure where to start, the four golden signals (latency, traffic, errors, and saturation) as laid out in Google’s SRE handbook can help expose issues. Then, find one or two high-level service level indicators (SLIs) representing the overall health of your services. For example, video-streaming services use time to first frame, the time between a user selecting a movie and when the first frame appears. Optimize your alerting strategy With data aggregation in place and team objectives clearly defined, you’ll need a systematic and reliable way to mobilize on-call teams when things go wrong. Well-defined alerts help you understand your systems’ health so that you can respond to performance problems quickly. Not every SLO needs to become an alert. A strong alert strategy takes SLOs and creates a set of simple, actionable alerts. Many mature organizations set fewer alerts in general and focus those alerts on a core set of metrics that indicate when their customer experience is truly degraded. DevOps teams often use Apdex as part of their alerting strategy to align alerts with signs of degraded user satisfaction. Alert Basics As you design your alert strategy, keep this question in mind: “If the customer isn’t impacted, is it worth waking someone up?” Questions Metrics and KPIs Are we open for business? Set up automated pings and alert on availability. How’s our underlying infrastructure? Manage and troubleshoot your hosts and containers. How’s the health of our application? Use real end-user metrics to understand the backend. Use metric and trace data from open source tools, and display that information alongside all the other systems and services data you’re managing. How do I troubleshoot a system error? Search and investigate the root cause of an issue across your application and infrastructure logs. How’s the overall quality of our application? Use an Apdex score to access an application’s quality quickly. How are our customers doing? Monitor frontend and mobile user experiences. How’s our overall business doing? Focus on key transactions within an application, and tie that to expected business outcomes to illustrate the correlation between your application and business performance. Improve incident response Every minute you spend manually interpreting your telemetry data to diagnose and resolve problems affects your company’s reputation and bottom line. That’s why you need to empower your IT operations teams with intelligence and automation that proactively detects and resolves incidents faster. Leverage deployment markers to quickly understand how code changes impact reliability.   Assign responsibility for the health of the application and services to a person or team. They will be the first responder for an incident. Make sure that communications during critical incidents take place in easily accessible and highly visible channels. For instance, if your teams are used to communicating with a tool such as Slack, make sure that incident alerts can be sent to Slack. Enable fast feedback loops  Fast feedback loops for releases reduce mean time to resolution (MTTR) and reliability risks associated with frequent application updates. It’s important to track deployments and how the impact of code and infrastructure changes affect customer experience. Tracking deployments is a valuable way to determine the root cause of immediate, long-term, or gradual degradations in your application. Fast feedback loops are also critical for modern release practices such as canary or blue/green deploys.  Observability Maturity: Data-Driven Phase   DATA-DRIVEN BEHAVIORS AND RECOMMENDATIONS SLO trend analysis Visualize the relationship between dev, ops, and customer Automate instrumentation KPIs: Number and MTTR of change-related incidents, developer satisfaction, customer satisfaction, SLO and SLA compliance, utilization, error rate, active alerts, number of support tickets   Ultimately, the goal of observability is to enable teams to take action with shared data. Connect people with processes and technology performance across the entire organization and tie it to specific business outcomes. To keep your observability data flowing, automate instrumentation for new apps and services. Then, you’ll be able to move fast with confidence as a data-driven organization.  SLO trend analysis Defining and measuring SLOs allows you to decompose your software into a set of key indicators that you can use to validate the expected behavior of services and track how incidents affect service delivery. Leverage the work you’ve done to define SLOs (above in the proactive phase) to find hot spots that need focus. Team dashboards are a good reference point for describing SLO attainment over time. Connect the dots to understand how application and infrastructure performance impact business outcomes.   Visualize the relationships among developers, operations, and customers A curated business performance dashboard will give your teams an overview of how users are experiencing your app. Knowing how your customers use—or abandon—your apps will help you triage future work. A strong observability culture democratizes data beyond the typical backend users, making it available to groups such as customer service, support, product, sales, marketing, and business executives. Having this data front and center are powerful motivators for teams. Automate instrumentation Automation can make you faster, and it helps to eliminate fat-finger errors—and, more important, it improves observability. You'll spend less time instrumenting systems and reduce toil as your application and infrastructure stacks inevitably grow. To instill this discipline, consider putting a 40% cap on the aggregate \"ops\" work for all SREs, such as tickets, on-call, and manual tasks. An SRE team must spend the remaining time developing apps. Over time, your SRE team should end up with very little operational load and almost entirely engage in development tasks, because the service runs and repairs itself. Leverage observability strategies that enable your teams to minimize toil and maximize automation.  10 Observability Best Practices 1. COLLECT DATA: Aggregate as much telemetry data about your systems as possible—metrics, events, logs, and traces, whether open source or proprietary—and store that data in a single platform. Goal: Collect and explore all of your telemetry data in a unified platform. 2. ESTABLISH BASELINES: Analyze obvious errors to create baseline alert conditions and adjust sensitivity as needed. Goal: Put out obvious fires and build a foundation to prioritize action. 3. CREATE SLOs: Set SLOs, perhaps starting with the four golden signals of latency, traffic, errors, and saturation and a few relevant metrics that measure end-user experiences. Goal: Codify team goals in a way that can be measured. 4. SET ALERTS: Define a simple alert strategy that prioritizes a core set of metrics indicating the customer experience is degraded. Goal: Focus on alerts for the most critical SLOs. 5. SPEED UP INCIDENT RESPONSE: Empower your IT operations teams with intelligence and automation that proactively detect and resolve incidents faster. Goal: Optimize the feedback loop between issue detection and resolution. 6. TRACK DEPLOYMENTS: Monitor application deployments so you can assess the impact of code changes on performance. Goal: Determine the root cause of immediate, long-term, or gradual degradations in your application. 7. AUTOMATE: Keep telemetry data flowing by automating instrumentation for new apps and services. Goal: With shared telemetry data, your teams can move fast with confidence. 8. ANALYZE: Create dashboards to measure SLO attainment over time. Goal: Validate service delivery expectations and find hot spots that need focus. 9. BE CUSTOMER-CENTRIC: Give your teams an overview of how customers use—or abandon—your apps. Goal: Improve how you triage and prioritize future work. 10. MINIMIZE TOIL: Instill the discipline of automation by capping SRE “maintenance work” at 40%. Goal: SRE teams end up with very little operational load and engage in development tasks because the service largely runs and repairs itself. Observability in New Relic Now that you’ve learned about the three phases of observability maturity, here are some hands-on tips for getting started in New Relic. Reactive phase Install the appropriate monitoring agents for applications, the infrastructure that supports them, and the frontend user experiences they enable. Collect data from popular cloud-based services, including Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform, and critical telemetry data from any source, including OpenTelemetry, Envoy, Dropwizard, Prometheus, and more. Access on-host integrations through the Infrastructure agent. Establish key transactions in New Relic APM, giving you a custom level of monitoring, or unique alert policies. Proactive phase Set up New Relic Synthetics to interact with the entire system as an external user would, giving your teams high-level checks for performance, availability, and user experience. Implement New Relic AI to streamline and enhance your production incidents. Use the New Relic APM deployment markers feature to record deployments for each application. Deployment markers in team dashboards enable you to analyze the before-and-after impact software releases have on performance. Data-driven phase Take advantage of the SLO/R application in New Relic One to help define SLIs and set SLO targets. Consider reporting the SLO attainment. Your teams should use how you’re tracking against your SLO target as an indicator of when you need to slow down to focus on reliability work and push on new features. You can also use SLO trends to facilitate better organizational decision making. Use this tutorial to learn how your customers experience your apps across different cohorts, such as by geographic location or device type. Segment and assess end-user cohorts and ensure you are optimizing customer experience in-line with overall business strategy. Use New Relic One dashboards to build flexible, interactive visualizations from data anywhere in the New Relic One platform. Use the Synthetics REST API to create and manage New Relic Synthetics monitors. Configure alert settings and set up alert conditions. Write a build script or plugin that captures dependencies and tasks to complete the agent install and provide them with sensible default configurations. Ready to get started on your observability journey? Sign up for a free New Relic account. COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.40458,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Automate</em> instrumentation",
        "body": " performance across the <em>entire</em> organization and tie it to specific business outcomes. To keep <em>your</em> observability data flowing, <em>automate</em> instrumentation for new apps and services. Then, you’ll be able to move fast with confidence as a data-driven organization.  SLO trend analysis Defining and measuring"
      },
      "id": "5f2275e864441fd75e2a4912"
    },
    {
      "image": "https://newrelic.com/dam/new-relic/opengraph/newrelic_og_image.png",
      "url": "https://newrelic.com/resources/articles/aws-monitoring-tips",
      "sections": [
        "Here are five best practices that can help you boost end-user experiences, simplify performance management, and optimize your AWS environment to suit your applications.",
        "Links",
        "1. Right-size your AWS instances",
        "2. Monitor all the (AWS) things",
        "3. Set up auto-scaling alerts and dashboards",
        "4. Automate your setup",
        "5. Keep an eye on the entire stack",
        "Performance monitoring for AWS",
        "COMPANY",
        "CONNECT",
        "international"
      ],
      "published_at": "2020-09-13T14:28:25Z",
      "title": "Tips and Tricks for Monitoring AWS with New Relic",
      "updated_at": "2020-09-03T03:58:52Z",
      "type": "storefront",
      "external_id": "acb339bf22ae7152efd7d58a16b9edc2e274cdc5",
      "popularity": 1,
      "body": "logo-newrelic Search Products Pricing Solutions Help Center About New Relic for iOS or Android    New Relic Insights App for iOS Search icon Sign Up Log In Products New Relic One Platform Overview Telemetry Data Platform Full-Stack Observability Applied Intelligence Solutions By Topic DevOps Cloud Adoption Cloud Native Digital Customer Experience By Industry E-commerce and Retail Media Public Sector By Technology Amazon Web Services Pivotal Cloud Foundry Microsoft Azure Google Cloud Platform Kubernetes Help Center Learn Docs Build on New Relic Explore open source projects Training Get help Community forum Global technical support Expert services About Our Customers Over 17,000 customers love New Relic, from Fortune 500 enterprises to small businesses around the globe. Our Blog The latest news, tips, and insights from the world of New Relic and digital intelligence. Our Company About Us Leadership Meetups and Events Resources   Investor Relations Newsroom Partner Program Contact Us logo-newrelic Want to use our logo? There's a page for that, including instructions and different styles and formats. Sorry about grabbing your right-click. Just trying to be helpful. You can also go home. Back to top icon Article Tips and Tricks for Monitoring AWS with New Relic Here are five best practices that can help you boost end-user experiences, simplify performance management, and optimize your AWS environment to suit your applications. Links Download PDF Whether you’re a seasoned New Relic user or are just starting to understand how the New Relic platform works, there’s always a new tip or trick you can use to improve the performance of your cloud-hosted applications. Here are five best practices that can help you boost end-user experiences, simplify performance management, and optimize your AWS environment to suit your applications: 1. Right-size your AWS instances The transient nature of EC2 instances can make it difficult to get an accurate view of your AWS ecosystem. Your company may have many different individuals or groups who are spinning up EC2 instances for various purposes. Because of this, a complete view of the current state of your AWS environment is essential. A decommissioned host is not a “dead” server; rather, it has merely served its purpose. Using New Relic Infrastructure, you instantly get an accurate snapshot of your EC2 instances, which allows you to then dissect them by the AWS tags you already use. Ultimately, this 360-degree view of your infrastructure allows you to optimize (or right-size) your AWS instances for maximum ROI. 2. Monitor all the (AWS) things While EC2 powers most AWS workloads, it’s by no means the only AWS service used to power modern applications. To fully understand how your AWS ecosystem is performing, you need to monitor the other services you use. New Relic Infrastructure Professional allows you to monitor the performance health of many popular AWS services, such as CloudFront, DynamoDB, EBS, ElastiCache, Elastic Load Balancing (ELB), IAM, Kinesis, RDS, SNS, SQS, and VPC, to name just a few of the services New Relic can monitor. To use these services effectively, you need context. For example, AWS ELB automatically distributes incoming application traffic across multiple Amazon EC2 instances, which you don’t always have visibility into. But by tracking ELB requests per second as well as write and read volume in New Relic Insights, you can understand exactly how that load is being balanced to make sure you’re using the service as effectively as possible. 3. Set up auto-scaling alerts and dashboards Ops teams depend on critical alerts and custom dashboards to tell the whole story about infrastructure performance. That’s why New Relic makes it easy for you to set thresholds for alerts on various metrics relating to your applications, servers, and key transactions. As EC2 instances come and go, your alerts and dashboards need to auto-scale with them. You can manage alerts by creating specified user groups and by leveraging New Relic’s integrated alert channels, including OpsGenie, PagerDuty, Slack, VictorOps, and Campfire. If you’re using a different alerting solution, use our Webhook feature to send a JSON Object anywhere you choose. New Relic also gives you the option to create customized dashboards for a curated view of what you care about most when running your applications in an AWS ecosystem. 4. Automate your setup When you’re operating in a dynamic AWS environment, your underlying infrastructure is constantly shifting. While AWS CloudFormation takes care of provisioning the resources, it raises the obvious question of how your application software is deployed, configured, and executed on your Amazon EC2 instances. That’s why you should consider using an automation solution like Chef or Puppet, which can automatically configure your systems and apps that sit on top of your infrastructure. Both tools make life easier by allowing you to automate your entire deployment and management process. When these config management tools are combined with New Relic Infrastructure, you get an instant view of your EC2 metrics, as well as the change events associated with their configuration. 5. Keep an eye on the entire stack The great thing about using New Relic to monitor your AWS applications is that it doesn’t just give you visibility into a certain portion of your application stack, but lets you see the entire thing—even if you’re running in a hybrid cloud, on-premise, or both. If you spot a performance problem in New Relic APM, for example, you can easily correlate to issues with your infrastructure using New Relic Infrastructure. You can test your application from outside the firewall using New Relic Synthetics, see what’s going on at the interaction level using New Relic Browser, and also organize, query, and visualize all this data using New Relic Insights to answer key questions about application and customer experience—all in real time. Performance monitoring for AWS Build, migrate, and deploy your applications and infrastructure faster with AWS monitoring from New Relic. Get Started COMPANY Careers and Culture Partner Program Investor Relations NewRelic.org Suppliers Portal CONNECT Contact Us Request Demo Events international newrelic.co.jp (日本語) newrelic.fr (Français) newrelic.de (Deutsch) newrelic.co.kr (한국어) Terms of Service DMCA Policy Privacy Policy Cookie Policy UK Slavery Act of 2015 ©2008-20 New Relic, Inc. All rights reserved",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 99.97032,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "4. <em>Automate</em> <em>your</em> setup",
        "body": " like Chef or Puppet, which can automatically configure <em>your</em> systems and apps that sit on top of <em>your</em> infrastructure. Both tools make life easier by allowing you to <em>automate</em> <em>your</em> <em>entire</em> deployment and management process. When these config management tools are combined with New Relic Infrastructure"
      },
      "id": "5ece930ee7b9d2bb5cc7071a"
    },
    {
      "image": "https://developer.newrelic.com/static/nerd-days-cd32e6ce7bce9feb13142801151df03c.png",
      "url": "https://developer.newrelic.com/",
      "sections": [
        "Mark your calendar for Nerd Days 1.0",
        "Get coding",
        "Create custom events",
        "Add tags to apps",
        "Build a Hello, World! app",
        "Get inspired",
        "Add a table to your app",
        "Collect data - any source",
        "Automate common tasks",
        "Create a custom map view",
        "Add a time picker to your app",
        "Add custom attributes",
        "New Relic developer champions",
        "New Relic Podcasts"
      ],
      "published_at": "2020-09-16T01:45:36Z",
      "title": "New Relic Developers",
      "updated_at": "2020-09-16T01:37:52Z",
      "type": "developer",
      "external_id": "214583cf664ff2645436a1810be3da7a5ab76fab",
      "document_type": "page",
      "popularity": 1,
      "body": "Mark your calendar for Nerd Days 1.0 Nerd Days is a FREE engineering conference that kicks off October 13 (Dates vary by region). Focused on building more perfect software, our goal is to spend less time looking at slides that tell you what software can do and more time on getting your hands on the software to solve problems efficiently. 27 Days : 15 Hours : 1 Minutes : 8 Seconds Register Get coding Create a free account 5 min Create custom events Define, visualize, and get alerts on the data you want using custom events Start the guide 7 min Add tags to apps Add tags to applications you instrument for easier filtering and organization Start the guide 12 min Build a Hello, World! app Build a Hello, World! app and publish it to your local New Relic One Catalog Start the guide Get inspired 30 min Add a table to your app Add a table to your New Relic One app 15 min Collect data - any source APIs, agents, OS emitters - get any data 20 min Automate common tasks Use the New Relic CLI to tag apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to your app Add a time picker to a sample application   Add custom attributes Use custom attributes for deeper analysis Show 20 more guides Looking for more inspiration? Check out the open source projects built by the New Relic community. New Relic developer champions New Relic Champions are solving big problems using New Relic as their linchpin and are recognized as experts and leaders in the New Relic technical community. Nominate a developer champion Learn more about developer champions New Relic Podcasts We like to talk, especially to developers about developer things. Join us for conversations on open source, observability, software design and industry news. Listen",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 98.50707,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Automate</em> common tasks",
        "body": " source APIs, agents, OS emitters - get any data 20 min <em>Automate</em> common tasks Use the New Relic CLI to <em>tag</em> apps and create deployment markers 30 min Create a custom map view Build an app to show page view data on a map 20 min Add a time picker to <em>your</em> app Add a time picker to a sample application   Add"
      },
      "id": "5d6fe49a64441f8d6100a50f"
    },
    {
      "category_2": "Examples",
      "nodeid": 34236,
      "sections": [
        "NerdGraph",
        "Get started",
        "Examples",
        "NerdGraph tagging API tutorial",
        "Read tags for an entity",
        "Add tags for an entity",
        "Remove a tag from an entity",
        "Delete specific tag values for an entity",
        "Replace all tag values for an entity",
        "For more help"
      ],
      "title": "NerdGraph tagging API tutorial",
      "category_0": "APIs",
      "type": "docs",
      "category_1": "NerdGraph",
      "external_id": "c4b8fbf4f75b862f2b6e3caad723935febb89815",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-tagging-api-tutorial",
      "published_at": "2020-09-14T04:01:55Z",
      "updated_at": "2020-07-26T05:41:24Z",
      "breadcrumb": "Contents / APIs / NerdGraph / Examples",
      "document_type": "page",
      "popularity": 1,
      "info": "Use New Relic's NerdGraph (our GraphQL API) to manage tags attached to your entities.  ",
      "body": "New Relic One provides unified access to all the entities you monitor with New Relic. Tags are used to organize and group all your entities in a way that's useful for troubleshooting and understanding your environment. To add, delete, or modify your tags, use the NerdGraph GraphiQL explorer. NerdGraph allows you to tag your entities with a key and an associated list of values. You can also use NerdGraph to query entities. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to find the entity and then fetch its tags. Use NerdGraph's tag API to read the existing tags and their values. In this example, our entity is a browser app called Cookie Checkout: { actor { entitySearch (query: \"name like 'Cookie Checkout'\") { results { entities { tags { key values } } } } } } The actual values vary depending on your data. Use the New Relic GraphiQL explorer to experiment with queries. Add tags for an entity To add new tags for an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity you want to tag. Use the taggingAddTagsToEntity mutation to add a tag with a value to the entity. In this example, we have a browser application called Cookie Checkout owned by a UI team. We want to add a team tag with a ui value to this instance. Once the tag is added, we can filter by the tag team:ui and find the Cookie Checkout app in the New Relic One UI. mutation { taggingAddTagsToEntity ( guid: \"ENTITY_GUID\", tags: { key: \"team\", values: [\"ui\"]}) { errors { message } } } Remove a tag from an entity To delete a tag and all of its associated values from an entity: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagFromEntity mutation. The following example mutation removes the team tag from an entity: mutation { taggingDeleteTagFromEntity ( guid: \"ENTITY_GUID\", tagKeys: [\"team\"]) { errors { message } } } Delete specific tag values for an entity Instead of deleting an entire tag and all of its values, you can delete a single tag value. Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingDeleteTagValuesFromEntity mutation. The following example mutation deletes the ui value from the tag key: mutation { taggingDeleteTagValuesFromEntity ( guid: \"ENTITY_GUID\", tagValues : [{key: \"team\" value: \"ui\"}]) { errors { message } } } Because tagValues is an array, you can delete multiple specific values from a single entity in one mutation. Replace all tag values for an entity To replace all the existing values for a tag with new ones: Go to the NerdGraph GraphiQL explorer at https://api.newrelic.com/graphiql. Use entitySearch() to locate the GUID for the entity with the tag you want to remove. Use the taggingReplaceTagsOnEntity mutation. In this example, the Cookie Checkout browser application was transferred from the ui team to the cookie-dev team. You can replace the tag values for team with the following mutation: mutation { taggingReplaceTagsOnEntity ( guid: \"ENTITY_GUID\", tags: {key: \"team\" values: [\"cookie-dev\"]}) { errors { message } } } For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 90.93214,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "NerdGraph <em>tagging</em> API tutorial",
        "sections": "NerdGraph <em>tagging</em> API tutorial",
        "info": "Use New Relic&#x27;s NerdGraph (our GraphQL API) to manage <em>tags</em> attached to <em>your</em> entities.  ",
        "body": ". NerdGraph allows you to <em>tag</em> <em>your</em> entities with a key and an associated list of values. You can also use NerdGraph to query entities. Read tags for an entity To construct these queries and see responses: Go to the NerdGraph GraphiQL explorer at https:&#x2F;&#x2F;api.newrelic.com&#x2F;graphiql. Use entitySearch() to find"
      },
      "id": "5d8024fc28ccbcc5e9499cf1"
    }
  ],
  "/collect-data/query-data-nrql": [
    {
      "category_2": "Alert conditions",
      "nodeid": 9231,
      "sections": [
        "New Relic Alerts",
        "Get started",
        "Alert policies",
        "Alert conditions",
        "Alert violations",
        "Alert Incidents",
        "Alert notifications",
        "Troubleshooting",
        "Rules, limits, and glossary",
        "Alerts and Nerdgraph",
        "REST API alerts",
        "Create NRQL alert conditions",
        "Create NRQL alert condition",
        "Alert threshold types",
        "NRQL alert syntax",
        "Sum of query results (limited or intermittent data)",
        "Offset the query time window",
        "NRQL alert threshold examples",
        "Create a description",
        "For more help"
      ],
      "title": "Create NRQL alert conditions",
      "category_0": "Alerts and Applied intelligence",
      "type": "docs",
      "category_1": "New Relic Alerts",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "external_id": "956a7a0b84d2afac5e6236df3143085ebc4f7459",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions",
      "published_at": "2020-09-14T05:05:47Z",
      "updated_at": "2020-09-03T23:54:56Z",
      "breadcrumb": "Contents / Alerts and Applied intelligence / New Relic Alerts / Alert conditions",
      "document_type": "page",
      "popularity": 1,
      "info": "How to define thresholds that trigger alert notifications based on your NRQL queries.",
      "body": "You can create alert conditions using NRQL queries. Create NRQL alert condition To create a NRQL alert condition: When you start to create a condition, where it prompts you to Select a product, click NRQL. Tips for creating and using a NRQL condition: Topic Tips Condition types NRQL condition types include static, baseline, and outlier. Create a description For some condition types, you can create a Description. Query results Queries must return a number. The condition works by evaluating that returned number against the thresholds you set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Condition settings Use the Condition settings to: Configure whether and how open violations are force-closed. Adjust the evaluation offset. Create a concise and descriptive condition name. (NerdGraph API Only) Provide a text description for the condition that will be included in violations and notifications. Troubleshooting procedures Optional: To include your organization's procedures for handling the incident, add the runbook URL to the condition. Limits on conditions See the maximum values. Health status NRQL alert conditions do not affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type, except you cannot use a FACET clause. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. NRQL alert syntax Here is the basic syntax for creating all NRQL alert conditions. Depending on the threshold type, also include a FACET clause as applicable. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Optional Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Static: Optional Baseline: Not allowed Outlier: Required Including a FACET clause in your NRQL syntax depends on the threshold type: static, baseline, or outlier. Use the FACET clause to separate your results by attribute and alert on each attribute independently. Faceted queries can return a maximum of 5000 values for static conditions and a maximum of 500 values for outlier conditions. If the query returns more than this number of values, the alert condition cannot be created. If you create the condition and the query returns more than this number later, the alert will fail. Sum of query results (limited or intermittent data) Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of the one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum, and the preview chart will update accordingly. Offset the query time window Every minute, we evaluate the NRQL query in one-minute time windows. The start time depends on the value you select in the NRQL condition's Advanced settings > Evaluation offset. Example: Using the default time window to evaluate violations With the Evaluation offset at the default setting of three minutes, the NRQL time window applied to your query will be: SINCE 3 minutes ago UNTIL 2 minutes ago If the event type is sourced from an APM language agent and aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend evaluating data from three minutes ago or longer. An offset of less than 3 minutes will trigger violations sooner, but you might see more false positives and negatives due to data latency. For cloud data, such as AWS integrations, you may need an offset longer than 3 minutes. Check our AWS polling intervals documentation to determine your best setting. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction SELECT percentile(databaseDuration, 75) FROM Transaction Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction SELECT average(duration) FROM Transaction Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Create a description You can define a description that passes useful information downstream for better violation responses or for use by downstream systems. For details, see Description. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.58419,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create <em>NRQL</em> alert conditions",
        "sections": "<em>NRQL</em> alert <em>syntax</em>",
        "info": "How to define thresholds that trigger alert notifications based on your <em>NRQL</em> queries.",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;alerts-applied-intelligence&#x2F;new-relic-alerts&#x2F;alert-conditions&#x2F;create-<em>nrql</em>-alert-conditions",
        "body": " for handling the incident, add the runbook URL to the condition. Limits on conditions See the maximum values. Health status <em>NRQL</em> alert conditions do not affect an entity&#x27;s health status display. Examples For more information, see: Expected <em>NRQL</em> <em>syntax</em> Examples of <em>NRQL</em> condition queries Alert threshold"
      },
      "id": "5f2d992528ccbc489d88dfc1"
    },
    {
      "category_2": "View and query data",
      "nodeid": 35946,
      "sections": [
        "Prometheus integrations",
        "Get started",
        "Install and configure remote write",
        "Install and configure OpenMetrics",
        "View and query data",
        "Troubleshooting",
        "Translate PromQL queries to NRQL",
        "Prometheus and New Relic metric types",
        "Mapping between NRQL and our PromQL-style queries",
        "Filter examples",
        "PromQL-style to NRQL query examples",
        "For more help"
      ],
      "title": "Translate PromQL queries to NRQL",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Prometheus integrations",
      "external_id": "52b85f6dd4fabb2919dfc07bacd9b3bb4c76ca73",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/PROMQL-query-2.png",
      "url": "https://docs.newrelic.com/docs/integrations/prometheus-integrations/view-query-data/translate-promql-queries-nrql",
      "published_at": "2020-09-14T02:56:37Z",
      "updated_at": "2020-09-14T02:56:37Z",
      "breadcrumb": "Contents / Integrations / Prometheus integrations / View and query data",
      "document_type": "page",
      "popularity": 1,
      "info": "Examples of how to convert some common PromQL queries for your Prometheus OpenMetrics integration to an equivalent NRQL metric query in New Relic.",
      "body": "Do you have a PromQL query you’d like to convert to NRQL? This document provides examples that show you how to convert some common PromQL queries to NRQL queries. You can use our PromQL-style query language to explore your Prometheus OpenMetrics integration data along with other data sent to New Relic. To run PromQL-style queries in New Relic One, go to the query builder advanced PromQL-style mode. Prometheus and New Relic metric types The different metric types supported by Prometheus and New Relic are related to each other: New Relic Prometheus Description Count Counter The Prometheus counter is a cumulative sum while the New Relic count is a delta sum. For example, if you see 2 requests in the first reporting period and 3 requests in the second reporting period. The Prometheus counter will report 2 and then 5, while the New Relic count will report 2 and then 3. Gauge Gauge A Prometheus gauge is similar to a New Relic gauge. Multiple counts Histogram Prometheus automatically maps a histogram to a set of counters. In New Relic, these counters should be changed to deltas and reported as counts. Gauges and counts Summary Prometheus automatically maps a summary to a set of counters and gauges. These can be translated to New Relic counts and gauges. Summary (No equivalent in Prometheus) New Relic has a distinct metric type called a summary that is different than the Prometheus summary. It is designed for reporting aggregated discrete events so that you can query the count, sum, min, max, and average values. Mapping between NRQL and our PromQL-style queries To see how New Relic translates PromQL-style queries to NRQL, write a query in the query builder PromQL-style tab, then switch to the NRQL tab. This table shows the mapping between NRQL and our PromQL-style queries when exploring data. For more contextual information, see the examples. Description Mapping between NRQL and PromQL-style queries Search for attributes: Explore the attributes on the container_memory_usage_bytes metric. PromQL: container_memory_usage_bytes NRQL: FROM Metric SELECT keyset() WHERE metricName = 'container_memory_usage_bytes' Find attribute's value: Explore the current value of the container_memory_usage_bytes metric for unique id attributes. PromQL: sum(container_memory_usage_bytes) by (id) NRQL: FROM Metric SELECT latest(container_memory_usage_bytes) FACET id Visualize the attribute's value: Chart the value of the container_memory_usage_bytes metric with the given id attribute value. PromQL: container_memory_usage_bytes{id=\"/\"} NRQL: FROM Metric SELECT latest(container_memory_usage_bytes) WHERE id = '/' TIMESERIES PromQL-style query example 1. Start your query. When exploring your data for a particular metric in PromQL, such as memory by container usage in bytes, you can start with a query such as: container_memory_usage_bytes This will chart all the unique metric timeseries for the input metric. 2. Filter the query results. Looking at the data, you can add more query parameters to filter down the number of metric timeseries. For example, if you only want timeseries where the id is /, the PromQL-style query will be: container_memory_usage_bytes{id=\"/\"} PromQL-style example: To filter the data, run this PromQL-style query: container_memory_usage_bytes{id=\"/\"}. NRQL query example 1. Query available metrics. To explore your data, start by looking at all the available metrics. Use the following NRQL query: FROM Metric SELECT uniques(metricName) 2. Find unique attributes. Once you have found the metric you want to review, such as container_memory_usage_bytes, you can find the unique attributes with the following query: FROM Metric SELECT keyset() WHERE metricName = 'container_memory_usage_bytes' The results will show each available attribute key and the value type (string, boolean, or number). 3. Aggregate and chart the metrics. To chart metrics using NRQL, you first need an aggregation function. For example, you can use latest for gauges, sum for counts, and average for summaries. As the following chart shows, all the unique timeseries are aggregated into one unique timeseries by default: one.newrelic.com > Query your data: This example shows the data you see after running FROM Metric SELECT keyset() WHERE metricName = 'container_memory_usage_bytes'. 4. View metrics by ID. To view the unique metric timeseries with various id values, run the following query: FROM Metric SELECT latest(container_memory_usage_bytes) FACET id one.newrelic.com > Query your data: This example shows the data you see after running FROM Metric SELECT latest(container_memory_usage_bytes) FACET id. 5. Add the selected ID to the query. Next you can select an id value and put it in the NRQL where clause. FROM Metric SELECT latest(container_memory_usage_bytes) WHERE id = \"/\" timeseries one.newrelic.com > Query your data: This example shows the data displayed after running From Metric select latest(container_memory_usage_bytes) where id = \"/\" timeseries. Filter examples Both our PromQL-style query language and NRQL provide syntax to filter down the number of unique metric timeseries. PromQL-style uses brackets to filter. NRQL uses a WHERE clause. Here are some example queries: Description PromQL-style and NRQL queries Select data with specific values. PromQL: go_memstats_heap_alloc_bytes{job=\"apiserver\", instance=\"1234\"}) NRQL: To only select data with specific values in NRQL, use the WHERE clause with =. In this example, all data must have the selected value for job and handler. FROM Metric SELECT latest(go_memstats_heap_alloc_bytes) WHERE job = 'apiserver' AND instance = '1234' TIMESERIES Select data with multiple values. PromQL: go_memstats_heap_alloc_bytes{environment=~\"staging|testing|development\",method!=\"GET\"} NRQL: In NRQL use the in clause to select multiple values for an attribute and the != sign to select all values but the one listed. In this example, the environment can be staging, testing, or development, and the method cannot be GET. FROM Metric SELECT latest(go_memstats_heap_alloc_bytes) WHERE environment IN ('staging', 'testing', 'development') AND method != 'GET' TIMESERIES Select data using partial string values. PromQL: go_memstats_heap_alloc_bytes{job=~\"api.*\"} NRQL: In NRQL use the LIKE clause to match part of a string value. In this example, all data will be returned where the job attributes start with api. FROM Metric SELECT latest(go_memstats_heap_alloc_bytes) WHEREe job LIKE 'api%' TIMESERIES PromQL-style to NRQL query examples You can simulate the following PromQL-style queries with NRQL queries: Description PromQL-style and NRQL queries Measure the per second rate over the last minute of the http_request_total metric. PromQL: sum(rate(http_requests_total[1m])) NRQL: FROM Metric SELECT rate(sum(http_request_total), 1 second) TIMESERIES 1 minute Chart the difference of the two metrics, then divide by 1024. PromQL: (instance_memory_limit_bytes - instance_memory_usage_bytes) / 1024 NRQL: FROM Metric SELECT (latest(instance_memory_limit_bytes) - latest(instance_memory_usage_bytes)) / 1024 TIMESERIES Provide the summed rate per 30-second interval by each handler. PromQL: sum(rate(http_requests_total[30s])) by (handler) NRQL: FROM Metric SELECT rate(sum(http_requests_total), 30 seconds) FACET handler TIMESERIES Chart the difference in the two metrics where the instance is named foo and the fstype is either ext4 or xfs. PromQL: (node_filesystem_free_bytes{instance='foo',fstype=~\"ext4|xfs\"} / node_filesystem_size_bytes{instance='foo',fstype=~\"ext4|xfs\"}) NRQL: FROM Metric SELECT latest(node_filesystem_free_bytes) / latest(node_filesystem_size_bytes) WHERE instance = 'foo' AND fstype IN ('ext4', 'xfs') For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.438156,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Translate PromQL queries to <em>NRQL</em>",
        "sections": "View and query <em>data</em>",
        "info": "Examples of how to convert some common PromQL queries for your Prometheus OpenMetrics integration to an equivalent <em>NRQL</em> metric query in New Relic.",
        "category_2": "View and query <em>data</em>",
        "body": " = &quot;&#x2F;&quot; timeseries one.newrelic.com &gt; Query your <em>data</em>: This example shows the <em>data</em> displayed after running From Metric select latest(container_memory_usage_bytes) where id = &quot;&#x2F;&quot; timeseries. Filter examples Both our PromQL-style query language and <em>NRQL</em> provide <em>syntax</em> to filter down the number of unique",
        "breadcrumb": "Contents &#x2F; Integrations &#x2F; Prometheus integrations &#x2F; View and query <em>data</em>"
      },
      "id": "5de402cce7b9d2929f902151"
    },
    {
      "category_2": "Explore data",
      "nodeid": 1131,
      "sections": [
        "Use Insights UI",
        "Getting started",
        "Explore data",
        "Guides",
        "Manage account data",
        "Manage dashboards",
        "Time settings",
        "Export data",
        "Troubleshooting",
        "Query page: Create and edit NRQL queries",
        "Use NRQL query history",
        "For more help"
      ],
      "title": "Query page: Create and edit NRQL queries",
      "category_0": "Insights",
      "type": "docs",
      "category_1": "Use Insights UI",
      "external_id": "e00d2b865680d15c361b4058e22270fe5103aa8e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/insights/use-insights-ui/manage-account-data/query-page-create-edit-nrql-queries",
      "published_at": "2020-09-13T21:14:58Z",
      "updated_at": "2020-07-26T08:08:39Z",
      "breadcrumb": "Contents / Insights / Use Insights UI / Explore data",
      "document_type": "page",
      "popularity": 1,
      "info": "Use the New Relic Insights Query page to create and edit NRQL queries, favorite them for later use, and add query results to dashboards. ",
      "body": "New Relic Insights' Query page is one place you can run NRQL queries of your data. To get started: Go to insights.newrelic.com > Query, then use any of the available NRQL syntax and functions. Use the Query page to: Create and run queries of your data. View your query history. View favorite queries. Use the NRQL query to create, view, organize, and share Insights dashboards. For a library of educational videos about how to use New Relic Insights, visit learn.newrelic.com. Use NRQL query history To view up to twenty of your most recent queries, select the History tab directly below the query command line interface. Use the query history to adjust and improve recent queries. If you want to... Do this... Run recent queries Select a recent query from the history list. The query will appear on the command line, where it can be edited. Delete queries Mouse over a query in the history list so the delete [trash] icon appears. The query history only retains the twenty most recent queries, so it can be useful to delete unwanted queries to make room for queries you like. Favorite queries Mouse over a query in the history list and the favorite star icon appears. Then, to view and use your favorite queries, select the Favorites tab. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.69549,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Query page: Create and edit <em>NRQL</em> queries",
        "sections": "Explore <em>data</em>",
        "info": "Use the New Relic Insights Query page to create and edit <em>NRQL</em> queries, favorite them for later use, and add query results to dashboards. ",
        "category_2": "Explore <em>data</em>",
        "body": "New Relic Insights&#x27; Query page is one place you can run <em>NRQL</em> queries of your <em>data</em>. To get started: Go to insights.newrelic.com &gt; Query, then use any of the available <em>NRQL</em> <em>syntax</em> and functions. Use the Query page to: Create and run queries of your <em>data</em>. View your query history. View favorite queries",
        "breadcrumb": "Contents &#x2F; Insights &#x2F; Use Insights UI &#x2F; Explore <em>data</em>"
      },
      "id": "59425a3c8e9c0f6937f1cda9"
    },
    {
      "category_2": "Get started",
      "nodeid": 11431,
      "sections": [
        "NRQL: New Relic Query Language",
        "Get started",
        "NRQL query tools",
        "NRQL query tutorials",
        "Introduction to NRQL, New Relic's query language",
        "What is NRQL?",
        "Where can you use NRQL?",
        "What data can you query with NRQL?",
        "Start using NRQL",
        "NRQL query examples",
        "NRQL syntax",
        "For more help"
      ],
      "title": "Introduction to NRQL, New Relic's query language",
      "category_0": "Query your data",
      "type": "docs",
      "category_1": "NRQL: New Relic Query Language",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language",
      "external_id": "d44be2c7df7addda8679b4c842015223cfcbd1a3",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-view-chart-nrql-query_0.png",
      "url": "https://docs.newrelic.com/docs/query-your-data/nrql-new-relic-query-language/get-started/introduction-nrql-new-relics-query-language",
      "published_at": "2020-09-13T23:25:54Z",
      "updated_at": "2020-08-05T14:08:07Z",
      "breadcrumb": "Contents / Query your data / NRQL: New Relic Query Language / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "An introduction to New Relic Query Language (NRQL) and how to use it.",
      "body": "One way to query your New Relic data is with the New Relic Query Language (NRQL). This document will introduce you to what NRQL is, why you'd use it, and basic syntax rules. What is NRQL? NRQL is New Relic's SQL-like query language. You can use NRQL to retrieve detailed New Relic data and get insight into your applications, hosts, and business-important activity. Reasons to use NRQL include: To answer a question for the purpose of troubleshooting or business analysis To create a new chart To make API queries of New Relic data (for example, using our NerdGraph API) NRQL is used behind the scenes to generate some New Relic charts: Some New Relic charts are built using NRQL. One way to start using NRQL is to view a chart's query and then edit it to make your own custom chart. Where can you use NRQL? You can use NRQL in these places: New Relic One query builder: Advanced mode is a NRQL query interface Basic mode provides a simplified query experience that doesn't require knowledge of NRQL but that uses NRQL to generate results New Relic Insights NerdGraph: our GraphQL-format API, which includes options for making NRQL queries one.newrelic.com > Query your data: You can run a NRQL query in both New Relic One and New Relic Insights. This NRQL query shows a count of distributed tracing spans faceted by their entity names. NRQL is one of several ways to query New Relic data. For more on all query options, see Query your data. What data can you query with NRQL? NRQL allows you to query these New Relic data types: Event data from all New Relic products, including: APM events, like Transaction New Relic Browser events, like PageView New Relic Mobile events, like Mobile Infrastructure events, like ProcessSample Synthetics events, like SyntheticCheck Custom events, like those reported by the Event API Metric timeslice data (metrics reported by New Relic APM, Browser, and Mobile) The Metric data type (metrics reported by the Metric API and data sources that use that API) The Span data type (distributed tracing data) The Log data type (data from New Relic Logs) Some data, like relationships between monitored entities, is not available via NRQL but is available using our NerdGraph API. Start using NRQL One way to start using NRQL and to understand what data you have available is to go to a NRQL interface (for example, the New Relic One query builder), type FROM, and press space. The interface will suggest available types of data: To see the attributes available for a specific data type, type FROM DATA_TYPE SELECT and press space. The interface will suggest available attributes. For example: To see the complete JSON associated with a data type, including all of its attributes, use the keyset() attribute. For example: FROM Transaction SELECT keyset() NRQL is used behind the scenes to build some New Relic charts and dashboards. One way to learn NRQL is to find one of these NRQL-generated charts and start playing with the NRQL to create new, customized queries and charts: Charts built with NRQL will have View query as an option. You can then edit and customize that query to see how your changes affect the resulting visualization. To explore your data without having to use NRQL, use the basic mode of New Relic One query builder. NRQL query examples Here's an example NRQL query of Transaction data, which is reported by New Relic APM. FROM Transaction SELECT average(duration) FACET appName TIMESERIES auto This would generate a chart that looks like: Here are some more query examples: Basic NRQL query of Browser data Here's a NRQL query of PageView data, which is reported by New Relic Browser. SELECT uniqueCount(user) FROM PageView WHERE userAgentOS = 'Mac' FACET countryCode SINCE 1 day ago LIMIT 20 Attribute name with a space in it If a custom attribute name has a space in it, use backticks around the attribute name: SELECT count(*) FROM Transaction FACET `Logged-in user` Querying multiple data sources To return data from two data sources, separate their data types with a comma. For example, this query returns a count of all APM transactions and Browser events over the last three days:​ SELECT count(*) FROM Transaction, PageView SINCE 3 days ago Query returning multiple columns To return multiple columns from a dataset, separate the aggregator arguments with a comma: SELECT function(attribute), function(attribute) ... FROM ... This query returns the minimum, average, and maximum duration for New Relic Browser PageView events over the last week: SELECT min(duration), max(duration), average(duration) FROM PageView SINCE 1 week ago See more NRQL query examples. NRQL syntax The syntax of a NRQL query is similar to standard SQL queries. Here is a breakdown of the structure of a NRQL query: SELECT function(attribute) [AS 'label'][, ...] FROM data type [WHERE attribute [comparison] [AND|OR ...]][AS 'label'][, ...] [FACET attribute | function(attribute)] [LIMIT number] [SINCE time] [UNTIL time] [WITH TIMEZONE timezone] [COMPARE WITH time] [TIMESERIES time] Basic rules include: NRQL condition Details Required values The SELECT statement and FROM clause are required. All other clauses are optional. You can start your query with either SELECT or FROM. Query string size The query string must be less than 4 KB. Case sensitivity The data type names and attribute names are case sensitive. NRQL clauses and functions are not case sensitive. Syntax for strings NRQL uses single quotes to designate strings. For example: ... where traceId = '030a573f0df02c57' Attribute names with spaces Use backticks `` to quote a custom attribute name that has a space in it. For example: ... FACET `Logged-in user` Data type coercion Insights does not support data type \"coercion.\" For more information, see Data type conversion. Use of math functions Basic and advanced math functions are supported in the SELECT statement. JOIN functions NRQL does not have the equivalent of the SQL JOIN function, but you can simulate a JOIN with custom attributes. Read more about NRQL syntax and functions. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 72.06787,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>NRQL</em>, New Relic&#x27;s query language",
        "sections": "What <em>data</em> can you query with <em>NRQL</em>?",
        "info": "An introduction to New Relic Query Language (<em>NRQL</em>) and how to use it.",
        "category_0": "Query your <em>data</em>",
        "category_1": "<em>NRQL</em>: New Relic Query Language",
        "translation_ja_url": "https:&#x2F;&#x2F;docs.newrelic.co.jp&#x2F;docs&#x2F;query-your-<em>data</em>&#x2F;<em>nrql</em>-new-relic-query-language&#x2F;get-started&#x2F;introduction-<em>nrql</em>-new-relics-query-language",
        "body": "One way to query your New Relic <em>data</em> is with the New Relic Query Language (<em>NRQL</em>). This document will introduce you to what <em>NRQL</em> is, why you&#x27;d use it, and basic <em>syntax</em> rules. What is <em>NRQL</em>? <em>NRQL</em> is New Relic&#x27;s SQL-like query language. You can use <em>NRQL</em> to retrieve detailed New Relic <em>data</em> and get",
        "breadcrumb": "Contents &#x2F; Query your <em>data</em> &#x2F; <em>NRQL</em>: New Relic Query Language &#x2F; Get started"
      },
      "id": "5f2abd47196a67747343fbe1"
    },
    {
      "category_2": "Get started",
      "nodeid": 14376,
      "sections": [
        "Infrastructure integrations",
        "Get started",
        "Cloud integrations",
        "On-host integrations",
        "Use integration data in New Relic dashboards",
        "Get started with integration data",
        "Example NRQL queries",
        "Tips for using different data types",
        "For more help"
      ],
      "title": "Use integration data in New Relic dashboards",
      "category_0": "Integrations",
      "type": "docs",
      "category_1": "Infrastructure integrations",
      "external_id": "7d849ce5ea91c59a7fa3b7b6966fa511a711f2e2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/infrastructure-integrations/get-started/use-integration-data-new-relic-dashboards",
      "published_at": "2020-09-13T20:53:48Z",
      "updated_at": "2020-08-06T03:42:28Z",
      "breadcrumb": "Contents / Integrations / Infrastructure integrations / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "For infrastructure integrations: an explanation of how to find and use integration data in New Relic, with sample queries.",
      "body": "Most data generated by integrations is available in New Relic One dashboards, where you can query your data using NRQL and build custom dashboards. The following tips and sample queries were created for New Relic-built integrations, but most will also apply to integrations built with the Integrations SDK. For a general look at how to find and use integration data, see Understand integration data. Get started with integration data Here are some tips for finding and exploring your integration data in New Relic: From the one.newrelic.com > Infrastructure > Third-party services page, select an integration dashboard. There, you can view the NRQL queries that generated a chart. For examples of NRQL queries for integration data, see the example queries. Use the data explorer or the dashboards to explore and understand the available data. Read the documentation for a specific integration to learn about the reported data. When you create a useful query you'd like to add to your Insights dashboard, select Add to dashboard. Example NRQL queries Here are some examples of NRQL queries that use integration data: AWS EBS query example Here's a NRQL query for the AWS EBS service, showing the total write time metric over the past day, faceted by displayName: select average('provider.volumeTotalWriteTime.Sum') from BlockDeviceSample WHERE provider = 'EbsVolume' AND providerAccountId = '72' facet displayName TIMESERIES SINCE 1 day ago Azure Service Bus query example Here's an Insights NRQL query for the number of messages in an Azure Service Bus topic queue, faceted by name: SELECT average(activeMessages) from AzureServiceBusTopicSample TIMESERIES 5 minutes since 6 hours ago FACET displayName Azure Functions query example Here's an Insights NRQL query for Azure Functions, showing the count of executed functions over the past six hours: SELECT sum('functionExecutionCount.Total') FROM AzureFunctionsAppSample WHERE providerAccountId = '125' SINCE 6 hour ago TIMESERIES auto FACET displayName Azure VMs query example Here's an Insights NRQL query for Azure VMs that compares the count of VM events over the past thirty minutes with the same time a week ago: SELECT count(*) FROM AzureVirtualMachineSample SINCE 30 MINUTES AGO COMPARE WITH 1 WEEK AGO WHERE provider = 'AzureVirtualMachine' TIMESERIES NGINX query example Here's an example of a query that you might run on your NGINX integration data and place in an Insights dashboard. This query creates a chart showing the average value of NGINX requests per second over time: SELECT average('requestsPerSecond') as 'Requests' FROM NginxSample TIMESERIES until 1 minutes ago For more on how to create queries, see NRQL syntax. MySQL query example Here's an example of a query that you might run on your MySQL integration data. This query generates a chart showing active MySQL connections over time: SELECT average('connectionsActive') as 'Active Connections' FROM MysqlSample TIMESERIES until 1 minutes ago For more on how to create queries, see NRQL syntax. Inventory change query example Here's an example of a query that groups inventory change events from the last day by the type of change: SELECT count(*) from InfrastructureEvent where format='inventoryChange' facet changeType since 1 day ago You can also perform these queries using dimensional metrics. Tips for using different data types Integrations can generate metric, event, and inventory data, all of which are available for querying in New Relic Insights. Here are some tips for using the different types of integration data in Insights: Metric data tips Tips for finding and using integration metric data in Insights: All integration data is attached to a data type known as an event (not to be confused with events reported by integrations, which represent important activity in your host/service). This means that all integration data can be found via the data explorer. For more about these two basic New Relic data types, see New Relic data collection. Metric values are treated as attributes: key-value pairs attached to an event. For example, the MySQL integration has an 'active connections' metric; this would be found by querying the connectionsActive attribute of the MysqlSample event. For general information about metrics, see Integration metric data. Event data tips Here are some tips for finding and using integration event data in Insights: Most integration events are inventory change events. When inventory is changed, it generates an InfrastructureEvent with a format value of inventoryChange. Integration data can be found via the data explorer. For general information about events, see Integration event data. Inventory data tips Here are some tips for finding and using integration inventory data in Insights: For general information about inventory data, see Integration inventory data. Some inventory data is added as attributes (key-value pairs) to Insights data. For example, the AWS EC2 integration collects awsRegion as inventory data; this would be found in Insights by querying the awsRegion attribute of the ComputeSample event type and provider Ec2Instance. When inventory data changes, an Insights InfrastructureEvent event type is generated with a format value of inventoryChange. See the query examples for an example of querying this data. For more on using NRQL queries, see Intro to NRQL. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 69.855835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use integration <em>data</em> in New Relic dashboards",
        "sections": "Use integration <em>data</em> in New Relic dashboards",
        "info": "For infrastructure integrations: an explanation of how to find and use integration <em>data</em> in New Relic, with sample queries.",
        "body": " integration <em>data</em> and place in an Insights dashboard. This query creates a chart showing the average value of NGINX requests per second over time: SELECT average(&#x27;requestsPerSecond&#x27;) as &#x27;Requests&#x27; FROM NginxSample TIMESERIES until 1 minutes ago For more on how to create queries, see <em>NRQL</em> <em>syntax</em>. MySQL"
      },
      "id": "5f2b7c24196a67d3e5fbd704"
    }
  ],
  "/build-apps/add-nerdgraphquery-guide": [
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-16T01:51:15Z",
      "title": "Build apps",
      "updated_at": "2020-09-16T01:51:15Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 714.5575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Add the <em>NerdGraphQuery</em> <em>component</em> to an <em>application</em>",
        "body": "   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 20 minutes Add the <em>NerdGraphQuery</em> <em>component</em> to an application The <em>NerdGraphQuery</em> <em>component</em> allows you to <em>query</em> <em>data</em> from"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Map page views by region in a custom app",
        "Before you begin",
        "New Relic terminology",
        "Build a custom app with a table chart",
        "Query your browser data",
        "Create and serve a new Nerdpack",
        "Review your app files and view your app locally",
        "Hard code your account ID",
        "Import the TableChart component",
        "Add a table with a single row",
        "Customize the look of your table (optional)",
        "Get your data into that table",
        "Make your app interactive with a text field",
        "Import the TextField component",
        "Add a row for your text field",
        "Build the text field object",
        "Get your data on a map",
        "Install Leaflet",
        "Add a webpack config file for Leaflet",
        "Import modules from Leaflet",
        "Import additional modules from New Relic One",
        "Get data for the map",
        "Customize the map marker colors",
        "Set your map's default center point",
        "Add a row for your map",
        "Replace \"Hello\" with the Leaflet code"
      ],
      "title": "Map page views by region in a custom app",
      "type": "developer",
      "tags": [
        "custom app",
        "map",
        "page views",
        "region",
        "nerdpack"
      ],
      "external_id": "6ff5d696556512bb8d8b33fb31732f22bab455cb",
      "image": "https://developer.newrelic.com/static/d87a72e8ee14c52fdfcb91895567d268/0086b/pageview.png",
      "url": "https://developer.newrelic.com/build-apps/map-pageviews-by-region/",
      "published_at": "2020-09-16T01:51:15Z",
      "updated_at": "2020-08-14T01:45:09Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Build a New Relic app showing page view data on a world map.",
      "body": "Map page views by region in a custom app 30 min New Relic has powerful and flexible tools for building custom apps and populating them with data. This guide shows you how to build a custom app and populate it with page view data using New Relic's Query Language (NRQL - pronounced 'nurkle'). Then you make your data interactive. And last, if you have a little more time and want to install a third-party React library, you can display the page view data you collect on a map of the world. In this guide, you build an app to display page view data in two ways: In a table On a map Please review the Before you begin section to make sure you have everything you need and don't get stuck halfway through. Before you begin In order to get the most out of this guide, you must have: A New Relic developer account, API key, and the command-line tool. If you don't have these yet, see the steps in Setting up your development environment New Relic Browser page view data to populate the app. Without this data, you won't be able to complete this guide. To add your data to a world map in the second half of the guide: npm, which you'll use during this section of the guide to install Leaflet, a third-party JavaScript React library used to build interactive maps. If you're new to React and npm, you can go here to install Node.js and npm. New Relic terminology The following are some terms used in this guide: New Relic application: The finished product where data is rendered in New Relic One. This might look like a series of interactive charts or a map of the world. Nerdpack: New Relic's standard collection of JavaScript, JSON, CSS, and other files that control the functionality and look of your application. For more information, see Nerdpack file structure. Launcher: The button on New Relic One that launches your application. Nerdlets: New Relic React components used to build your application. The three default files are index.js, nr1.json, and styles.scss, but you can customize and add your own. Build a custom app with a table chart Step 1 of 8 Query your browser data Use Query builder to write a NRQL query to see your page view data, as follows. On New Relic One, select Query your data (in the top right corner). That puts you in NRQL mode. You'll use NRQL to test your query before dropping the data into your table. Copy and paste this query into a clear query field, and then select Run. FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000 Copy If you have PageView data, this query shows a week of average page views broken down by country and limited to a thousand items. The table will be full width and use the \"chart\" class defined in the CSS. If you don't have any results at this point, ensure your query doesn't have any errors. If your query is correct, you might not have the Browser agent installed. Step 2 of 8 Create and serve a new Nerdpack To get started, create a new Nerdpack, and serve it up to New Relic from your local development environment: Create a new Nerdpack for this app: nr1 create --type nerdpack --name pageviews-app Copy Serve the project up to New Relic: cd pageviews-app && nr1 nerdpack:serve Copy Step 3 of 8 Review your app files and view your app locally Navigate to your pageviews-app to see how it's structured. It contains a launcher folder, where you can customize the description and icon that will be displayed on the app's launcher in New Relic One. It also contains nerdlets, which each contain three default files: index.js, nr1.json, and styles.scss. You'll edit some of these files as part of this guide. For more information, see Nerdpack file structure. Now in your browser, open https://one.newrelic.com/?nerdpacks=local, and then click Apps to see the pageview-apps Nerdpack that you served up. When you select the launcher, you see a Hello message. Step 4 of 8 Hard code your account ID For the purposes of this exercise and for your convenience, hard code your account ID. In the pageview-app-nerdlet directory, in the index.js file, add this code between the import and export lines. (Read about finding your account ID here). const accountId = [Replace with your account ID]; Copy Step 5 of 8 Import the TableChart component To show your data in a table chart, import the TableChart component from New Relic One. To do so, in index.js, add this code under import React. import { TableChart } from `nr1`; Copy Step 6 of 8 Add a table with a single row To add a table with a single row, in the index.js file, replace this line: return <h1>Hello, pageview-app-nerdlet Nerdlet!</h1>; Copy with this export code: export default class PageViewApp extends React.Component { render() { return ( <div className=\"container\"> <div className=\"row\"></div> </div> ); } } Copy Step 7 of 8 Customize the look of your table (optional) You can use standard CSS to customize the look of your components. In the styles.scss file, add this CSS. Feel free to customize this CSS to your taste. .container { width: 100%; height: 99vh; display: flex; flex-direction: column; .row { margin: 10px; display: flex; flex-direction: row; } .chart { height: 250px; } } Copy Step 8 of 8 Get your data into that table Now that you've got a table, you can drop a TableChart populated with data from the NRQL query you wrote at the very beginning of this guide. Put this code into the row div. <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" />; Copy Go to New Relic One and click your app to see your data in the table. (You might need to serve your app to New Relic again.) Congratulations! You made your app! Continue on to make it interactive and show your data on a map. Make your app interactive with a text field Once you confirm that data is getting to New Relic from your app, you can start customizing it and making it interactive. To do this, you add a text field to filter your data. Later, you use a third-party library called Leaflet to show that data on a world map. Step 1 of 3 Import the TextField component Like you did with the TableChart component, you need to import a TextField component from New Relic One. import { TextField } from 'nr1'; Copy Step 2 of 3 Add a row for your text field To add a text field filter above the table, put this code above the TableChart div. The text field will have a default value of \"US\". <div className=\"row\"> <TextField placeholder=\"US\" onChange={(event) => { this.setState({ countryCode: event.target.value }); }} /> </div>; Copy Step 3 of 3 Build the text field object Above the render() function, add a constructor to build the text field object. constructor(props) { super(props); this.state = { countryCode: null } } Copy Then, add a constructor to your render() function. Above return, add: const { countryCode } = this.state; Copy Now add countryCode to your table chart query. <TableChart accountId={accountId} query={`FROM PageView SELECT count(*), average(duration) WHERE appName = 'WebPortal' ${ countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : '' } FACET countryCode, regionCode SINCE 1 week ago LIMIT 1000`} fullWidth className=\"chart\" />; Copy Reload your app to try out the text field. Get your data on a map To create the map, you use npm to install Leaflet. Step 1 of 9 Install Leaflet In your terminal, type: npm install --save leaflet react-leaflet Copy In your nerdlets styles.scss file, import the Leaflet CSS: @import `~leaflet/dist/leaflet.css`; Copy While you're in styles.scss, fix the width and height of your map: .containerMap { width: 100%; z-index: 0; height: 70vh; } Copy Step 2 of 9 Add a webpack config file for Leaflet Add a webpack configuration file .extended-webpackrc.js to the top-level folder in your nerdpack. This supports your use of map tiling information data from Leaflet. module.exports = { module: { rules: [ { test: /\\.(png|jpe?g|gif)$/, use: [ { loader: 'file-loader', options: {}, }, { loader: 'url-loader', options: { limit: 25000 }, }, ], }, ], }, }; Copy Step 3 of 9 Import modules from Leaflet In index.js, import modules from Leaflet. import { Map, CircleMarker, TileLayer } from 'react-leaflet'; Copy Step 4 of 9 Import additional modules from New Relic One You need several more modules from New Relic One to make the Leaflet map work well. Import them with this code: import { NerdGraphQuery, Spinner, Button, BlockText } from 'nr1'; Copy NerdGraphQuery lets you make multiple NRQL queries at once and is what will populate the map with data. Spinner adds a loading spinner. Button gives you button components. BlockText give you block text components. Step 5 of 9 Get data for the map Using latitude and longitude with country codes, you can put New Relic data on a map. mapData() { const { countryCode } = this.state; const query = `{ actor { account(id: 1606862) { mapData: nrql(query: \"SELECT count(*) as x, average(duration) as y, sum(asnLatitude)/count(*) as lat, sum(asnLongitude)/count(*) as lng FROM PageView FACET regionCode, countryCode WHERE appName = 'WebPortal' ${countryCode ? ` WHERE countryCode like '%${countryCode}%' ` : ''} LIMIT 1000 \") { results nrql } } } }`; return query; }; Copy Step 6 of 9 Customize the map marker colors Above the mapData function, add this code to customize the map marker colors. getMarkerColor(measure, apdexTarget = 1.7) { if (measure <= apdexTarget) { return '#11A600'; } else if (measure >= apdexTarget && measure <= apdexTarget * 4) { return '#FFD966'; } else { return '#BF0016'; } }; Copy Feel free to change the HTML color code values to your taste. In this example, #11A600 is green, #FFD966 is sort of yellow, and #BF0016 is red. Step 7 of 9 Set your map's default center point Set a default center point for your map using latitude and longitude. const defaultMapCenter = [10.5731, -7.5898]; Copy Step 8 of 9 Add a row for your map Between the text field row and the table chart row, insert a new row for the map content using NerdGraphQuery. <div className=\"row\"> <NerdGraphQuery query={this.mapData()}> {({ loading, error, data }) => { if (loading) { return <Spinner fillContainer />; } if (error) { return 'Error'; } const { results } = data.actor.account.mapData; console.debug(results); return 'Hello'; }} </NerdGraphQuery> </div>; Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace \"Hello\" with the Leaflet code Replace return \"Hello\"; with: return ( <Map className=\"containerMap\" center={defaultMapCenter} zoom={2} zoomControl> <TileLayer attribution='&amp;copy <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors' url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\" /> {results.map((pt, i) => { const center = [pt.lat, pt.lng]; return ( <CircleMarker key={`circle-${i}`} center={center} color={this.getMarkerColor(pt.y)} radius={Math.log(pt.x) * 3} onClick={() => { alert(JSON.stringify(pt)); }} /> ); })} </Map> ); Copy This code creates a world map centered on the latitude and longitude you chose using OpenStreetMap data and your marker colors. Reload your app to see the pageview data on the map!",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 299.95416,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Map page views by region in a custom <em>app</em>",
        "sections": "<em>Query</em> your browser <em>data</em>",
        "info": "Build a New Relic <em>app</em> showing page view <em>data</em> on a world map.",
        "tags": "custom <em>app</em>",
        "body": " &lt;Spinner fillContainer &#x2F;&gt;; } if (error) { return &#x27;Error&#x27;; } const { results } = <em>data.actor.account.mapData</em>; console.debug(results); return &#x27;Hello&#x27;; }} &lt;&#x2F;<em>NerdGraphQuery</em>&gt; &lt;&#x2F;div&gt;; Copy Reload your application in New Relic One to test that it works. Step 9 of 9 Replace &quot;Hello&quot; with the Leaflet code Replace"
      },
      "id": "5efa993c196a67066b766469"
    },
    {
      "category_2": "Enable and configure",
      "nodeid": 38171,
      "sections": [
        "Distributed tracing",
        "Get started",
        "Enable and configure",
        "Other requirements",
        "UI and data",
        "Trace API",
        "Troubleshooting",
        "Integrations: Enable distributed tracing",
        "Step 1. Install the integration",
        "Step 2. (Infinite Tracing) Find or create a trace observer endpoint",
        "Step 3. (Infinite Tracing) Configure the integration",
        "Step 4. View traces",
        "For more help"
      ],
      "title": "Integrations: Enable distributed tracing",
      "category_0": "Understand dependencies",
      "type": "docs",
      "category_1": "Distributed tracing",
      "external_id": "6fd698d8077aa70b61b867bec09cac86be69214c",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/Infinite_Tracing_GraphiQL_URL_Results_0_0.png",
      "url": "https://docs.newrelic.com/docs/understand-dependencies/distributed-tracing/enable-configure/integrations-enable-distributed-tracing",
      "published_at": "2020-09-13T17:01:33Z",
      "updated_at": "2020-09-13T17:01:33Z",
      "breadcrumb": "Contents / Understand dependencies / Distributed tracing / Enable and configure",
      "document_type": "page",
      "popularity": 1,
      "info": "These are instructions for enabling distributed tracing for New Relic integrations with Istio, Open Census, and OpenTelemetry.",
      "body": "If you have telemetry data from Istio, Kamon, OpenCensus, and OpenTelemetry, you can view it in the New Relic UI by sending it through one of our telemetry integrations. To integrate your AWS X-Ray telemetry data, use the infrastructure integration. Since distributed systems can generate a lot of trace data, telemetry tools rely on data sampling (filtering) to find useful data. Our telemetry integrations offer you two sampling options: Use your tool’s native sampling (default): The default installation assumes you are relying on your telemetry tool to sample the data before the integration passes the data to our Trace API. Even though your tool may be sampling data, our Trace API may randomly sample out traces that exceed your rate limit. Use Infinite Tracing (limited release): This approach assumes you turn off sampling in your telemetry tool and then send all your data to a New Relic trace observer in AWS. The trace observer selects the most important and actionable traces using tail-based sampling and then sends your traces to our Trace API. To use this approach, complete the default installation but then configure a new endpoint for a trace observer. To start using Infinite Tracing, please go to our sign-up page. Here's an overview of the steps to enable distributed tracing: Install the integration (Infinite Tracing) Provision a trace observer on New Relic Edge (Infinite Tracing) Configure your open source integration View your traces in New Relic One Step 1. Install the integration If you haven't already installed one of these integrations in your services, follow the link for your integration and complete the installation. After the installation, if you are not enabling Infinite Tracing, skip to Step 4. View traces in New Relic One. Istio adapter Kamon reporter OpenCensus Go language exporter Python language exporter OpenTelemetry Go language exporter Java language exporter .NET language exporter Step 2. (Infinite Tracing) Find or create a trace observer endpoint Infinite Tracing collects your span data in a trace observer, which runs in a cluster of services in AWS called New Relic Edge. Integrations send all your spans to the trace observer so they can be assembled into traces for you to view in New Relic. If you send your data to a trace observer in one of our EU provider regions, you'll still need a US-based New Relic account because the tail-based sampling data is reported to data centers in the United States. If you have questions, contact your account representative. You can use GraphQL to see if someone has already created a trace observer endpoint for your account. If you can't find one, you need to create a new endpoint. Complete the following trace observer steps: 2a. Open NerdGraph API explorer Prepare to execute some GraphQL: Open NerdGraph API explorer. In the API key dropdown next to Tools, select your personal API key for your account under one of these options: Select an existing API Key Create a new API Key 2b. See if anyone in your organization has already created a trace observer endpoint The following steps show you how to execute a GraphQL query to find out if you can use an existing trace observer in your AWS region. If one isn't available, you can go to Step 2c. Create a new one. Copy the following query into the middle pane of the NerdGraph API explorer and replace YOUR_ACCOUNT_ID with your account ID (the number next to your account name in NerdGraph API explorer): { actor { account(id: YOUR_ACCOUNT_ID) { edge { tracing { traceObservers { errors { message type } traceObservers { endpoints { agent { host port } endpointType https { host port url } status } id name providerRegion } } } } } } } Click the triangle button to execute the query or press Ctrl+Enter. Check the right pane showing the results: In traceObservers, if you see an AWS region (providerRegion) appropriate for your location, copy its associated endpoint values. Here's an example of what to copy: (Required) https: host (save to use later as YOUR_TRACE_OBSERVER_HOST in Configure the integration) (Required)https: port (save to use later as YOUR_TRACE_OBSERVER_PORT in Configure the integration) (Optional) https: url (save to use later as YOUR_TRACE_OBSERVER_URL in Send test data to the trace observer) If you don't see any values in traceObservers as shown below, continue to Step 2c. Create a new one. 2c. If you can't find an existing trace observer endpoint, create a new one If you didn't find a trace observer after running the query in the previous section, you need to create one. To do this, you execute a GraphQL mutation that passes your configuration details. Copy the following into the middle pane of the NerdGraph API explorer. mutation { edgeCreateTraceObserver(accountId: YOUR_ACCOUNT_ID, traceObserverConfigs: {name: \"YOUR_DESCRIPTIVE_NAME\", providerRegion: YOUR_PROVIDER_REGION}) { responses { errors { message type } traceObserver { endpoints { agent { host port } endpointType https { host port url } status } id name providerRegion } } } } Insert your own values into the mutation: Value Description YOUR_ACCOUNT_ID Replace this with your account ID (the number next to your account name in NerdGraph API explorer). YOUR_DESCRIPTIVE_NAME Replace this with a name that describes the services that report to this trace observer (for example, production or query services). YOUR_PROVIDER_REGION Replace this with the provider region enum value for your location: AWS_EU_WEST_1 AWS_US_EAST_1 AWS_US_WEST_2 Click the triangle button to execute the mutation or press Ctrl+Enter. In the right pane showing the results, copy the following endpoint values to a text file so you can use them later: (Required) https: host (save to use later as YOUR_TRACE_OBSERVER_HOST in Configure the integration) (Required)https: port (save to use later as YOUR_TRACE_OBSERVER_PORT in Configure the integration) (Optional) https: url (save to use later as YOUR_TRACE_OBSERVER_URL in Send test data to the trace observer) 2d. (Optional) Send test data to the trace observer This test includes a sample payload with one trace and two spans from the same service: Test Service A. Follow these steps to send a test request: Get or generate your Insert API key so you can use it later in the test. Copy the following curl request into a text editor: curl request curl -i -H \"Content-Type: application/json\" \\ -H \"Api-Key: YOUR_INSERT_API_KEY\" \\ -H 'Data-Format: newrelic' \\ -H 'Data-Format-Version: 1' \\ -X POST \\ -d '[ { \"common\": { \"attributes\": { \"environment\": \"staging\" } }, \"spans\": [ { \"trace.id\": \"123456\", \"id\": \"ABC\", \"attributes\": { \"duration.ms\": 12.53, \"host\": \"host123.test.com\", \"name\": \"/home\", \"service.name\": \"Test Service A\" } }, { \"trace.id\": \"123456\", \"id\": \"DEF\", \"attributes\": { \"duration.ms\": 2.97, \"host\": \"host456.test.com\", \"error.message\": \"Invalid credentials\", \"name\": \"/auth\", \"parent.id\": \"ABC\", \"service.name\": \"Test Service B\" } } ] } ]' \\ 'YOUR_TRACE_OBSERVER_URL' Insert your own values into the curl request: Value Description YOUR_INSERT_API_KEY Replace this with your Insert API key (not the same as your personal API key for NerdGraph API explorer) YOUR_TRACE_OBSERVER_URL Replace this with the value under https: url from above. Copy the content of the text editor into a terminal, and then execute the request. If the test does not return HTTP/1.1 202 Accepted indicating success, check the following and try again: Confirm that you substituted the url (not host) value for YOUR_TRACE_OBSERVER_URL. Confirm that you only have single quotes around the value you inserted for YOUR_TRACE_OBSERVER_URL. Check that you are using the Insert API Key (not a license). If your test returned HTTP/1.1 202 Accepted, go to New Relic One to see a query of your test data using the span attribute service.name = Test Service A. Because the sample payload contains an error attribute, the error sampler will mark it for keeping. If you modify the payload to remove the error attributes, the random sampler may not choose to keep this particular trace. Traces may take up to one minute to be processed by both the trace observer and the Trace API. Step 3. (Infinite Tracing) Configure the integration To enable Infinite Tracing, configure your integration to send the telemetry data to the trace observer by using the results from Step 2. Find or create a trace observer endpoint. Find the section below describing these steps for your integration: Istio adapter Set the spansHost value with YOUR_TRACE_OBSERVER_URL when deploying the Helm chart. Kamon reporter Set the span-ingest-uri value with YOUR_TRACE_OBSERVER_URL in your kamon.newrelic configuration block. OpenCensus (Go language exporter) Set the SpansURLOverride field on the Config object with YOUR_TRACE_OBSERVER_URL when creating the Exporter. OpenCensus (Python language exporter) Pass the host and port parameters to the Trace Exporter using YOUR_TRACE_OBSERVER_HOST and YOUR_TRACE_OBSERVER_PORT. OpenTelemetry (Go language exporter) Set the SpansURLOverride field on the Config object with YOUR_TRACE_OBSERVER_URL when creating the Exporter. OpenTelemetry (Java language exporter) Complete the following: Create a java.net.URI with YOUR_TRACE_OBSERVER_URL. Pass the URI to com.newrelic.telemetry.opentelemetry.export.NewRelicSpanExporter builder’s uriOverride method. See an example where a NewRelicSpanExporter is created. OpenTelemetry (.NET language exporter) Configure the TraceUrlOverride parameter with YOUR_TRACE_OBSERVER_URL. Step 4. View traces After you configure your integration to send data to New Relic, you are ready to view traces. Here are two alternatives: View traces that include a specific service The Entity explorer helps you navigate to a specific service so you can see traces that include that service. Go to one.newrelic.com. Click Entity explorer in the top menu bar. Filter to the service you enabled for Infinite Tracing by typing the service name, and then press Enter. In the left navigation's Monitor section, click Distributed tracing. View traces across accounts This option allows you to search all traces across all New Relic accounts in your organization that you have access to. Go to one.newrelic.com. Click Apps in the top menu bar. Under Favorites click Distributed tracing. In the Find traces... search, type a search clause to find the service. For example, to query service.name or trace.id: service.name = YOUR_SERVICE_NAME trace.id = YOUR_TRACE_ID For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 291.67227,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "UI and <em>data</em>",
        "body": " the <em>query</em> in the previous section, you need to create one. To do this, you execute a <em>Graph</em>QL mutation that passes your configuration details. Copy the following into the middle pane of the <em>NerdGraph</em> API explorer. mutation { edgeCreateTraceObserver(<em>account</em>Id: YOUR_<em>ACCOUNT</em>_ID, traceObserverConfigs"
      },
      "id": "5ea0617064441ff137912311"
    },
    {
      "category_2": "Enable and configure",
      "nodeid": 17021,
      "sections": [
        "Distributed tracing",
        "Get started",
        "Enable and configure",
        "Other requirements",
        "UI and data",
        "Trace API",
        "Troubleshooting",
        "Language agents: Enable distributed tracing",
        "Step 1. Prerequisites",
        "Step 2. (Infinite Tracing) Find or create a trace observer endpoint",
        "Step 3. Configure the agents",
        "Step 4. View traces",
        "Manual instrumentation (If automatic instrumentation doesn't work)",
        "For more help"
      ],
      "title": "Language agents: Enable distributed tracing",
      "category_0": "Understand dependencies",
      "type": "docs",
      "category_1": "Distributed tracing",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/understand-dependencies/distributed-tracing/enable-configure/language-agents-enable-distributed-tracing",
      "external_id": "92f81f3ba78006bec29baec46891cf6cfb1c9468",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/Infinite_Tracing_GraphiQL_URL_Results_0_0.png",
      "url": "https://docs.newrelic.com/docs/understand-dependencies/distributed-tracing/enable-configure/language-agents-enable-distributed-tracing",
      "published_at": "2020-09-13T20:40:52Z",
      "updated_at": "2020-09-13T20:40:52Z",
      "breadcrumb": "Contents / Understand dependencies / Distributed tracing / Enable and configure",
      "document_type": "page",
      "popularity": 1,
      "info": "How to enable distributed tracing or Infinite Tracing for APM agents.",
      "body": "Here's what you need to know for enabling standard distributed tracing or Infinite Tracing with our language agents. If you prefer to get more background before getting started, check out these topics: How span sampling works explains distributed tracing options. Impacts to APM tells you what to expect if you are a current APM user. The process of enabling distributed tracing takes you through these steps: Meet the prerequisites (Infinite Tracing): Find or create a trace observer endpoint Configure your agents View traces Step 1. Prerequisites Check the following sections to confirm that the distributed tracing options you want are available for your environment. Your main options are: Standard distributed tracing: Head-based sampling Infinite Tracing: (limited release): Tail-based sampling Support for W3C Trace Context: Available in all Infinite Tracing agents and in standard distributed tracing agents as noted To start using Infinite Tracing, please go to our sign-up page. Once you find the agent version with the features you want, follow the links for help installing or updating your agent. For best results, update existing agents to the latest version. C SDK Install (compile) or update to the required C SDK version. For best results, update to the latest C SDK version. Option C SDK version Standard distributed tracing 1.1.0 or higher (W3C Trace Context not available) Infinite Tracing Not available Go Install or update to the required Go agent version. For best results, update to the latest Go agent version. Option Go agent version Standard distributed tracing 2.1.0 or higher With W3C Trace Context: 3.1.0 or higher Infinite Tracing v3.5.0 (includes W3C Trace Context) Supported environments: Go 1.9 or higher Java Install or update to the required Java agent version. For best results, update to the latest Java agent version. Type Java agent version Standard distributed tracing 4.3.0 or higher With W3C Trace Context: 5.10 or higher Infinite Tracing 5.12.1 or higher (includes W3C Trace Context) Supported environments: Java 8: Update 252 or higher All versions of Java 9 or higher For special considerations, see Infinite Tracing: Configuring SSL for Java 7 and 8. .NET Install or update to the required .NET agent version. For best results, update to the latest .NET agent version. Option .NET agent version Standard distributed tracing 8.6.45.0 or higher With W3C Trace Context: 8.27.139.0 or higher Infinite Tracing 8.30.0 (includes W3C Trace Context) Supported environments: .NET Framework 4.5 or higher .NET Core 2.0 or higher Node.js Install or update to the required Node.js agent version. For best results, update to the latest Node.js agent version. Option Node.js agent version Standard distributed tracing 4.7.0 or higher With W3C Trace Context: 6.4 or higher Infinite Tracing 6.7.0 (includes W3C Trace Context) Supported environments: Node version 10.10.0 or higher PHP Install or update to the required PHP agent version. For best results, update to the latest PHP agent version. Option PHP agent version Standard distributed tracing 8.4 or higher With W3C Trace Context: 9.8 or higher Infinite Tracing 9.12.0.268 or higher Python Install or update to the required Python agent version. For best results, update to the latest Python agent version. Option Python agent version Standard distributed tracing 4.2.0.100 or higher With W3C Trace Context: 5.6 or higher Infinite Tracing 5.12.0.140 (includes W3C Trace Context) Supported environments: CPython only (pypy is unsupported) Ruby Install or update to the required Ruby agent version. For best results, update to the latest Ruby agent version. Also install the additional Ruby agent gem for Infinite Tracing. Option Ruby agent version Standard distributed tracing newrelic_rpm 5.3.0.346 or higher With W3C Trace Context: newrelic_rpm 6.9 or higher Infinite Tracing newrelic_rpm 6.11.0.365 or higher (includes W3C Trace Context) newrelic-infinite_tracing 6.11.0.375 or higher Step 2. (Infinite Tracing) Find or create a trace observer endpoint This section only applies to Infinite Tracing. If you are enabling standard distributed tracing, continue to Configure the agents. Infinite Tracing collects your span data in a trace observer, which runs in a cluster of services in AWS called New Relic Edge. Agents send all your spans to the trace observer so they can be assembled into traces for you to view in New Relic. If you send your data to a trace observer in one of our EU provider regions, you'll still need a US-based New Relic account because the tail-based sampling data is reported to data centers in the United States. If you have questions, contact your account representative. You can use GraphQL to see if someone has already created a trace observer endpoint for your account. If you can't find one, you need to create a new endpoint. Complete the following trace observer steps in order: 2a. Open NerdGraph API explorer Prepare to execute some GraphQL: Open NerdGraph API explorer. In the API key dropdown next to Tools, select your personal API key for your account under one of these options: Select an existing API key Create a new API key 2b. See if anyone in your organization has already created a trace observer endpoint The following steps show you how to execute a GraphQL query to find out if you can use an existing trace observer in your AWS region. If one isn't available, then you can go to Step 2c. Create a new one. Copy the following query into the middle pane of the NerdGraph API explorer and replace YOUR_ACCOUNT_ID with your account ID (the number next to your account name in NerdGraph API explorer): { actor { account(id: YOUR_ACCOUNT_ID) { edge { tracing { traceObservers { errors { message type } traceObservers { endpoints { agent { host port } endpointType https { host port url } status } id name providerRegion } } } } } } } Click the triangle button to execute the query, or press Ctrl+Enter. Check the right pane showing the results: In traceObservers, if you see an AWS region (providerRegion) appropriate for your location, copy its associated endpoint values. Here's an example of what to copy: (Required)agent: host (Save to use later as YOUR_TRACE_OBSERVER_HOST in Step 3. Configure the agents) (Optional)https: url (Save to use later as YOUR_TRACE_OBSERVER_URL in Step 2d. Send test data to the trace observer) If you don't see any results in traceObservers as shown in the following example, continue to 2c. Create a new one. 2c. If you don't find an existing trace observer endpoint, create a new one If you didn't find a trace observer endpoint after running the query in the previous section, you need to create one. To do this, execute a GraphQL mutation that passes your configuration details. Copy the following into the middle pane of the NerdGraph API explorer. mutation { edgeCreateTraceObserver(accountId: YOUR_ACCOUNT_ID, traceObserverConfigs: {name: \"YOUR_DESCRIPTIVE_NAME\", providerRegion: YOUR_PROVIDER_REGION}) { responses { errors { message type } traceObserver { endpoints { agent { host port } endpointType https { host port url } status } id name providerRegion } } } } Insert your own values into the mutation: Value Description YOUR_ACCOUNT_ID Replace this with your account ID (the number next to your account name in NerdGraph API explorer). YOUR_DESCRIPTIVE_NAME Replace this with a name that describes the services that report to this trace observer (for example, production or query services). YOUR_PROVIDER_REGION Replace this with the provider region enum value for your location: AWS_EU_WEST_1 AWS_US_EAST_1 AWS_US_WEST_2 Click the triangle button to execute the mutation, or press Ctrl+Enter. In the right pane showing the results, copy the following endpoints to a text file so you can use them later: (Required) agent: host (Save to use later as YOUR_TRACE_OBSERVER_HOST in Step 3. Configure the agents) (Optional) https: url (Save to use later as YOUR_TRACE_OBSERVER_URL in 2d. Send test data to the trace observer) 2d. (Optional) Send test data to the trace observer This optional test includes a sample payload with one trace and two spans from the same service: Test Service A. Follow these steps to send a test request: Get or generate your Insert API key so you can use it later in the configuration (Note that the Insert API key is not your license). Copy the following curl request into a text editor: curl request curl -i -H \"Content-Type: application/json\" \\ -H \"Api-Key: YOUR_INSERT_API_KEY\" \\ -H 'Data-Format: newrelic' \\ -H 'Data-Format-Version: 1' \\ -X POST \\ -d '[ { \"common\": { \"attributes\": { \"environment\": \"staging\" } }, \"spans\": [ { \"trace.id\": \"123456\", \"id\": \"ABC\", \"attributes\": { \"duration.ms\": 12.53, \"host\": \"host123.test.com\", \"name\": \"/home\", \"service.name\": \"Test Service A\" } }, { \"trace.id\": \"123456\", \"id\": \"DEF\", \"attributes\": { \"duration.ms\": 2.97, \"host\": \"host456.test.com\", \"error.message\": \"Invalid credentials\", \"name\": \"/auth\", \"parent.id\": \"ABC\", \"service.name\": \"Test Service B\" } } ] } ]' \\ 'YOUR_TRACE_OBSERVER_URL' Insert your own values into the curl request: Value Description YOUR_INSERT_API_KEY Replace this with your Insert API key (not your New Relic license key). YOUR_TRACE_OBSERVER_URL Replace this with the value under https: url from the previous step. Copy the content of the text editor into a terminal and execute the request. If the test does not return HTTP/1.1 202 Accepted indicating success, check the following and try again: Confirm that you substituted the url (not host) value for YOUR_TRACE_OBSERVER_URL. Confirm that you only have single quotes around the value you inserted for YOUR_TRACE_OBSERVER_URL. Check that you are using the Insert API key (not a license key). If your test returned HTTP/1.1 202 Accepted, go to New Relic One to see a query of your test data using the span attribute service.name = Test Service A. Because the sample payload contains an error attribute, the error sampler will mark it for keeping. If you modify the payload to remove the error attributes, the random sampler may not choose to keep this particular trace. Traces may take up to one minute to be processed by both the trace observer and the Trace API. Step 3. Configure the agents Distributed tracing is enabled through configuration settings. The settings you need to change for distributed tracing depend on the type you want: Standard distributed tracing Infinite Tracing (requires YOUR_TRACE_OBSERVER_HOST from step 2) Review the following section for your agent to see the required configuration settings. For more information, see Configure the agent. Server-side configuration is not available for Infinite Tracing. C SDK Here's an overview of the settings. For more help with configuration, see Enable distributed tracing for your C applications. Type Required configuration Standard distributed tracing Configuration examples: newrelic_app_config_t structure: newrelic_app_config_t* config; config = newrelic_create_app_config(app_name, license_key); config->distributed_tracing.enabled = true; Infinite Tracing Not available Go Here's an overview of the settings. For more help with configuration, see Enable distributed tracing for your Go applications. Type Required configuration Standard distributed tracing Configuration examples: ConfigOption structure: newrelic.NewApplication( newrelic.ConfigAppName(\"Example App\"), newrelic.ConfigLicense(os.Getenv(\"NEW_RELIC_LICENSE_KEY\")), newrelic.ConfigDistributedTracerEnabled(true), ) Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Infinite Tracing Configuration examples: newrelic.Config structure: app, err := newrelic.NewApplication( newrelic.ConfigAppName(YOUR_APP_NAME), newrelic.ConfigLicense(YOUR_LICENSE_KEY), func(cfg *newrelic.Config) { cfg.DistributedTracer.Enabled = true cfg.InfiniteTracing.TraceObserver.Host = YOUR_TRACE_OBSERVER_HOST }, ) Environment variables: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=YOUR_TRACE_OBSERVER_HOST Java Here's an overview of the settings. For more help with configuration, see Java agent configuration: Config file. Type Required configuration Standard distributed tracing Configuration examples: Configuration file (newrelic.yml) (indented 2 spaces under the common stanza): distributed_tracing: enabled: true Java system property: -Dnewrelic.config.distributed_tracing.enabled=true Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Infinite Tracing Configuration examples: Configuration file (newrelic.yml) (indented 2 spaces under the common stanza): distributed_tracing: enabled: true infinite_tracing: trace_observer: host: \"YOUR_TRACE_OBSERVER_HOST\" Java system property: -Dnewrelic.config.distributed_tracing.enabled=true -Dnewrelic.config.infinite_tracing.trace_observer.host=\"YOUR_TRACE_OBSERVER_HOST\" Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=\"YOUR_TRACE_OBSERVER_HOST\" .NET Here's an overview of the settings. For more help with configuration, see .NET agent configuration. Type Required configuration Standard distributed tracing Configuration examples: Configuration file (newrelic.config): <configuration . . . > <distributedTracing enabled=\"true\" /> </configuration> Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Infinite Tracing Configuration examples: Configuration file (newrelic.config): <configuration . . . > <distributedTracing enabled=\"true\" /> <infiniteTracing> <trace_observer host=\"YOUR_TRACE_OBSERVER_HOST\" /> </infiniteTracing> </configuration> Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=\"YOUR_TRACE_OBSERVER_HOST\" Node.js Here's an overview of the settings. For more help with configuration, see Node.js agent configuration. Type Required configuration Standard distributed tracing Configuration examples: Configuration file (newrelic.js): distributed_tracing: { enabled: true } Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Infinite Tracing Configuration examples: Configuration file (newrelic.js): distributed_tracing: { enabled: true } infinite_tracing: { trace_observer: { host: 'YOUR_TRACE_OBSERVER_HOST' } } Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=\"YOUR_TRACE_OBSERVER_HOST\" PHP Here's an overview of the settings. For more help with configuration, see Distributed tracing for the PHP agent Type Required configuration Standard distributed tracing Configuration examples: Configuration file (newrelic.ini): newrelic.distributed_tracing_enabled = true Infinite Tracing Configuration examples: Configuration file (newrelic.ini): newrelic.distributed_tracing_enabled = true newrelic.span_events_enabled = true newrelic.infinite_tracing.trace_observer_host= YOUR_TRACE_OBSERVER_HOST Python Here's an overview of the settings. For more help with configuration, see Python agent configuration Type Required configuration Standard distributed tracing Configuration file (newrelic.ini): distributed_tracing.enabled = true Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Infinite Tracing Use the following installation command: pip install newrelic[infinite-tracing] Configuration file (newrelic.ini): distributed_tracing.enabled = true infinite_tracing.trace_observer_host= YOUR_TRACE_OBSERVER_HOST Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=\"YOUR_TRACE_OBSERVER_HOST\" Ruby Here's an overview of the settings. For more help with configuration, see Ruby agent configuration. Type Required configuration Standard distributed tracing Configuration examples: Configuration file (newrelic.yml): distributed_tracing: enabled: true Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Infinite Tracing Configuration examples: Configuration file (newrelic.yml): distributed_tracing: enabled: true infinite_tracing: trace_observer: host: 'YOUR_TRACE_OBSERVER_HOST' Environment variable: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST=\"YOUR_TRACE_OBSERVER_HOST\" Step 4. View traces After you upgrade and configure your APM agents to send data to your trace observer, you are ready to view traces. Here are two alternatives: View traces that include a specific service The Entity explorer helps you navigate to a specific service so you can see traces that include that service. Go to one.newrelic.com. Click Entity explorer in the top menu bar. Filter to the service you enabled for Infinite Tracing by typing the service name, and then press Enter. In the left navigation's Monitor section, click Distributed tracing. View traces across accounts This option allows you to search all traces across all New Relic accounts in your organization that you have access to. Go to one.newrelic.com. Click Apps in the top menu bar. Under Favorites click Distributed tracing. In the Find traces... search, type a search clause to find the service. For example, to query service.name or trace.id: service.name = YOUR_SERVICE_NAME trace.id = YOUR_TRACE_ID Manual instrumentation (If automatic instrumentation doesn't work) Recommendation: Before performing any custom instrumentation, read: How distributed tracing works Troubleshoot missing data If a service is not passing the trace header to other services, you can use the distributed tracing payload APIs to instrument the calling service and the called service. The calling service uses an API call to generate a payload, which is accepted by the called service. Instrument the calling service To instrument the calling service: Ensure the version of the APM agent that monitors the calling service supports distributed tracing. Invoke the agent API call for generating a distributed trace payload: C SDK | Go | Java | .NET | Node.js | PHP | Python | Ruby. To maintain proper ordering of spans in a trace, ensure you generate the payload in the context of the span that sends it. Add that payload to the call made to the destination service (for example, in a header). (Optional) Identify the call as an external call: C SDK Go Java .NET: n/a Node.js PHP: n/a Python Ruby Instrument the called service To instrument the called service: Ensure the version of the APM agent that monitors the called service supports distributed tracing. If the New Relic agent on the called service does not identify a New Relic transaction, use the agent API to declare a transaction: C SDK One way to tell that a transaction is not in progress: when newrelic_create_distributed_trace_payload() is called, a NULL pointer is returned. To solve this problem, follow the procedures to create a transaction with the C SDK. Go One way to tell that a transaction is not in progress: when Transaction.InsertDistributedTraceHeaders(h http.Header) is called, no headers are inserted. To create a transaction, see Instrument Go transactions. Java One way to tell that a transaction is not in progress: when createDistributedTracePayload() is called, an empty string is returned. To create a transaction, see Java agent transaction-related APIs. .NET One way to tell that a transaction is not in progress: CreateDistributedTracePayload() returns an empty payload. To create a transaction, see Introduction to .NET custom instrumentation. Node.js One way to tell that a transaction is not in progress: the Node.js agent logs will report an error similar to this: No transaction found when calling Transaction.acceptDistributedTracePayload. Use startWebTransaction to create a web transaction or startBackgroundTransaction to capture a non-web transaction. PHP One way to tell that a transaction is not in progress: newrelic_insert_distributed_trace_headers() returns false. To create a transaction, see newrelic_start_transaction. Python To tell that a transaction is not in progress: when transaction = current_transaction() is run, transaction is None. Or, if result = accept_distributed_trace_payload(payload) is run, then the result is False. Use background_task to report a non-web transaction. For more on Python instrumentation, see Monitor transactions and segments. Ruby If you are using a Rack-based web framework and have enabled New Relic's Rack instrumentation, the Ruby agent will handle starting a transaction for you. For other use cases, see the add_transaction_tracer API method. Extract the payload from the call that you received (for example, in a header). Invoke the call for accepting the payload: C SDK | Go | Java | .NET | PHP | Node.js | Python | Ruby. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 271.50708,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "UI and <em>data</em>",
        "body": ", then you can go to Step 2c. Create a new one. Copy the following <em>query</em> into the middle pane of the <em>NerdGraph</em> API explorer and replace YOUR_<em>ACCOUNT</em>_ID with your <em>account</em> ID (the number next to your <em>account</em> name in <em>NerdGraph</em> API explorer): { actor { <em>account</em>(id: YOUR_<em>ACCOUNT</em>_ID) { edge { tracing"
      },
      "id": "5eb2c480e7b9d2bc7afa4921"
    },
    {
      "sections": [
        "Query and store data",
        "Components overview",
        "Query components",
        "Mutation components",
        "Static methods",
        "NrqlQuery"
      ],
      "title": "Query and store data",
      "type": "developer",
      "tags": [
        "nerdgraph query components",
        "mutation components",
        "static methods"
      ],
      "external_id": "cbbf363393edeefbc4c08f9754b43d38fd911026",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/query-and-store-data/",
      "published_at": "2020-09-16T01:53:48Z",
      "updated_at": "2020-08-01T01:42:02Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Reference guide for SDK query components using NerdGraph",
      "body": "Query and store data 10 min To help you build a New Relic One application, we provide you with the New Relic One SDK. Here you can learn how to use the SDK query components, which allow you to make queries and mutations via NerdGraph, our GraphQL endpoint. Query-related React components can be identified by the Query suffix. Mutation-related components can be identified by the Mutation prefix. Components overview Our data components are based on React Apollo. The most basic component is NerdGraphQuery, which accepts any GraphQL (or GraphQL AST generated by the graphql-tag library as the query parameter, and a set of query variables passed as variables. Over this query, we have created an additional set of queries, which can be divided into four groups: User queries: These allow you to query the current user and its associated accounts. Components in this category: UserStorageQuery and AccountsQuery. Entities queries: Because New Relic One is entity-centric, we use queries to make access to your entities easier. You can count, search, list, query, and favorite them. Components in this category: EntityCountQuery, EntitySearchQuery, EntitiesByDomainTypeQuery, EntitiesByGuidsQuery, EntityByGuidQuery, EntityByNameQuery. Storage queries: New Relic One provides a simple storage mechanism that we call NerdStorage. This can be used by Nerdpack creators to store application configuration setting data, user-specific data, and other small pieces of data. Components in this category: UserStorageQuery, AccountStorageQuery, EntityStorageQuery, UserStorageMutation, AccountStorageMutation, and EntityStorageMutation. For details, see NerdStorage. NRQL queries: To be able to query your New Relic data via NRQL (New Relic Query Language), we provide a NrqlQuery component. This component can return data in different formats, so that you can use it for charting and not only for querying. Query components All query components accept a function as a children prop where the different statuses can be passed. This callback receives an object with the following properties: loading: Boolean that is set to true when data fetching is happening. Our components use the cache-and-network strategy, meaning that after the data has loaded, subsequent data reloads might be triggered first with stale data, then refreshed when the most recent data has arrived. data: Root property where the data requested is retrieved. The structure matches a root structure based on the NerdGraph schema. This is true even for highly nested data structures, which means you’ll have to traverse down to find the desired data. error: Contains an Error instance when the query fails. Set to undefined when data is loading or the fetch was successful. fetchMore: Callback function that can be called when the query is being loaded in chunks. The function will only be present when it’s feasible to do so, more data is available, and no fetchMore has already been triggered. Data is loaded in batches of 200 by default. Other components provided by the platform (like the Dropdown or the List) are capable of accepting fetchMore, meaning you can combine them easily. Mutation components Mutation components also accept a children as a function, like the query ones. The mutation can be preconfigured at the component level, and a function is passed back that you can use in your component. This is the standard React Apollo approach for performing mutations, but you might find it easier to use our static mutation method added to the component. More on this topic below. Static methods All of the described components also expose a static method so that they can be used imperatively rather than declaratively. All Query components have a static Query method, and all Mutation components have a mutation method. These static methods accept the same props as their query component, but passed as an object. For example: // Declarative way (using components). function renderAccountList() { return ( <ul> <AccountsQuery> ({data, error}) => { if (error) { return <li>Failed to retrieve list: {error.message}</li>; } return data.map((account) => { <li key={account.id}>{account.name}</li> }); }} </AccountsQuery> </ul> ); } // Imperative way (using promises). async function getAccountList() { let data = {}; try { data = await AccountsQuery.query(); } catch (error) { console.log('Failed to retrieve list: ' + error.message); return; } return data.actor.accounts.map((account) => { return account.name; }); } Copy Similarly, a mutation can happen either way; either declaratively or imperatively. NrqlQuery NrqlQuery deserves additional explanation, because there are multiple formats in which you can return data from it. To provide maximum functionality, all three are exposed through a formatType property. You can find its different values under NrqlQuery.formatType: NERD_GRAPH: Returns the format in which it arrives from NerdGraph. RAW: The format exposed by default in Insights and dashboards when being plotted as JSON. This format is useful if you have a pre-existing script in this format that you're willing to migrate to or incorporate with. CHART: The format used by the charting engine that we also expose. You can find a more detailed explanation of how to manipulate this format in the guide to chart components, and some examples. If you are willing to push data, we currently do not expose NrqlMutation. To do that, see the Event API for how to add custom events.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 265.81946,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Query</em> and store <em>data</em>",
        "sections": "<em>Components</em> <em>overview</em>",
        "info": "Reference guide for SDK <em>query</em> <em>components</em> using <em>NerdGraph</em>",
        "tags": "<em>nerdgraph</em> <em>query</em> <em>components</em>",
        "body": " be identified by the <em>Query</em> suffix. Mutation-related components can be identified by the Mutation prefix. Components <em>overview</em> Our <em>data</em> components are based on React Apollo. The most basic <em>component</em> is <em>NerdGraphQuery</em>, which accepts any <em>Graph</em>QL (or <em>Graph</em>QL AST generated by the graphql-tag library as the <em>query</em>"
      },
      "id": "5efa989e28ccbc2f15307deb"
    }
  ],
  "/explore-docs/intro-to-sdk": [
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-16T01:48:56Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 897.06384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use NerdStorage in your <em>apps</em>",
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> <em>apps</em>",
        "body": "Intro to Nerd<em>Storage</em> 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> <em>SDK</em>. On this page, you’ll learn how to use Nerd<em>Storage</em> <em>SDK</em> <em>components</em>. Use Nerd<em>Storage</em> in your <em>apps</em> Nerd<em>Storage</em> is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/build-apps/",
      "sections": [
        "Build apps",
        "Guides to build apps",
        "Create a \"Hello, World!\" application",
        "Permissions for managing applications",
        "Set up your development environment",
        "Add the NerdGraphQuery component to an application",
        "Add, query, and mutate data using NerdStorage",
        "Add a time picker to your app",
        "Add a table to your app",
        "Create a custom map view",
        "Publish and deploy apps"
      ],
      "published_at": "2020-09-16T01:51:15Z",
      "title": "Build apps",
      "updated_at": "2020-09-16T01:51:15Z",
      "type": "developer",
      "external_id": "abafbb8457d02084a1ca06f3bc68f7ca823edf1d",
      "document_type": "page",
      "popularity": 1,
      "body": "Build apps You know better than anyone what information is crucial to your business, and how best to visualize it. Sometimes, this means going beyond dashboards to creating your own app. With React and GraphQL, you can create custom views tailored to your business. These guides are designed to help you start building apps, and dive into our library of components. We also have a growing number of open source apps that you can use to get started. The rest is up to you. Guides to build apps 15 min Create a \"Hello, World!\" application Build a \"Hello, World!\" app and publish it to New Relic One   Permissions for managing applications Learn about permissions for subscribing to apps 20 min Set up your development environment Prepare to build apps and contribute to this site 20 minutes Add the NerdGraphQuery component to an application The NerdGraphQuery component allows you to query data from your account and add it to a dropdown menu in an application 45 min Add, query, and mutate data using NerdStorage NerdStorage is a document database accessible within New Relic One. It allows you to modify, save, and retrieve documents from one session to the next. 20 min Add a time picker to your app Add a time picker to a sample application 30 min Add a table to your app Add a table to your New Relic One app 30 min Create a custom map view Build an app to show page view data on a map 30 min Publish and deploy apps Start sharing the apps you build",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 861.2367,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Build <em>apps</em>",
        "sections": "Publish <em>and</em> deploy <em>apps</em>",
        "body": " you start building <em>apps</em>, and dive into our library of <em>components</em>. We also have a growing number of open source <em>apps</em> that you can use to get started. The rest is up to you. Guides to build <em>apps</em> 15 min Create a &quot;Hello, World!&quot; application Build a &quot;Hello, World!&quot; <em>app</em> and publish it to <em>New</em> <em>Relic</em> <em>One</em>"
      },
      "id": "5efa999d64441fc0f75f7e21"
    },
    {
      "sections": [
        "Add tables to your New Relic One application",
        "Before you begin",
        "Clone and set up the example application",
        "Work with table components",
        "Next steps"
      ],
      "title": "Add tables to your New Relic One application",
      "type": "developer",
      "tags": [
        "table in app",
        "Table component",
        "TableHeaderc omponent",
        "TableHeaderCell component",
        "TableRow component",
        "TableRowCell component"
      ],
      "external_id": "7ff7a8426eb1758a08ec360835d9085fae829936",
      "image": "https://developer.newrelic.com/static/e637c7eb75a9dc01740db8fecc4d85bf/1d6ec/table-new-cells.png",
      "url": "https://developer.newrelic.com/build-apps/howto-use-nrone-table-components/",
      "published_at": "2020-09-16T01:52:28Z",
      "updated_at": "2020-08-30T01:43:57Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Add a table to your New Relic One app.",
      "body": "Add tables to your New Relic One application 30 min Tables are a popular way of displaying data in New Relic applications. For example, with the query builder you can create tables from NRQL queries. Whether you need to have more control over tables or you're importing third-party data, you can build your own tables into your New Relic One application. In this guide, you are going to build a sample table using various New Relic One components. Before you begin If you haven't already installed the New Relic One CLI, step through the quick start in New Relic One. This process also gets you an API key. In addition, to complete the steps in this guide, you need a GitHub account and Node.js installed on your machine. See Setting up your development environment for more info. Clone and set up the example application Step 1 of 4 Clone the nr1-how-to example application from GitHub to your local machine. Then, navigate to the app directory. The example app lets you experiment with tables. git clone https://github.com/newrelic/nr1-how-to.git` cd nr1-how-to/create-a-table/nerdlets/create-a-table-nerdlet` Copy Step 2 of 4 Edit the index.json file and set this.accountId to your Account ID as shown in the example. export default class Nr1HowtoAddTimePicker extends React.Component { constructor(props){ super(props) this.accountId = YOUR_ACCOUNT_ID; } ... } Copy Step 3 of 4 Run the demo application Change the directory back to nr1-how-to/create-a-table. Before you can load the demo application, you need to update its unique id by invoking the New Relic One CLI. Once you've assigned a new UUID to the app, install the dependencies and serve the demo app locally, so that you can test any change live in your browser. nr1 nerdpack:uuid -gf # Update the app unique ID npm install # Install dependencies nr1 nerdpack:serve # Serve the demo app locally Copy Step 4 of 4 Open one.newrelic.com/?nerdpacks=local in your browser. Click Apps, and then in the Your apps section, you should see a Create a table launcher. That's the demo application you're going to work on. Go ahead and select it. Have a good look at the demo app. There's a TableChart on the left side named Transaction Overview, with an AreaChart next to it. You'll use Table components to add a new table in the second row. Work with table components Step 1 of 10 Navigate to the `nerdlets/create-a-table-nerdlet` subdirectory and open the `index.js` file. Add the following components to the import statement at the top of the file so that it looks like the example: Table TableHeader TableHeaderCell TableRow TableRowCell import { Table, TableHeader, TableHeaderCell, TableRow, TableRowCell, PlatformStateContext, Grid, GridItem, HeadingText, AreaChart, TableChart, } from 'nr1'; Copy Step 2 of 10 Add a basic Table component Locate the empty GridItem in index.js: This is where you start building the table. Add the initial <Table> component. The items property collects the data by calling _getItems(), which contains sample values. <GridItem className=\"primary-content-container\" columnSpan={12}> <Table items={this._getItems()}></Table> </GridItem>; Copy Step 3 of 10 Add the header and rows As the Table component renders a fixed number of header cells and rows, your next step is adding header components, as well as a function that returns the required table rows. Inside of the Table component, add the TableHeader and then a TableHeaderCell child for each heading. Since you don't know how many rows you'll need, your best bet is to call a function to build as many TableRows as items returned by _getItems(). <TableHeader> <TableHeaderCell>Application</TableHeaderCell> <TableHeaderCell>Size</TableHeaderCell> <TableHeaderCell>Company</TableHeaderCell> <TableHeaderCell>Team</TableHeaderCell> <TableHeaderCell>Commit</TableHeaderCell> </TableHeader>; { ({ item }) => ( <TableRow> <TableRowCell>{item.name}</TableRowCell> <TableRowCell>{item.value}</TableRowCell> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 4 of 10 Take a look at the application running in New Relic One: you should see something similar to the screenshot below. Step 5 of 10 Replace standard table cells with smart cells The New Relic One library includes cell components that can automatically format certain data types, like users, metrics, and entity names. The table you've just created contains columns that can benefit from those components: Application (an entity name) and Size (a metric). Before you can use EntityTitleTableRowCell and MetricTableRowCell, you have to add them to the import statement first. import { EntityTitleTableRowCell, MetricTableRowCell, ... /* All previous components */ } from 'nr1'; Copy Step 6 of 10 Update your table rows by replacing the first and second TableRowCells with entity and metric cells. Notice that EntityTitleTableRowCell and MetricTableRowCell are self-closing tags. { ({ item }) => ( <TableRow> <EntityTitleTableRowCell value={item} /> <MetricTableRowCell type={MetricTableRowCell.TYPE.APDEX} value={item.value} /> <TableRowCell>{item.company}</TableRowCell> <TableRowCell>{item.team}</TableRowCell> <TableRowCell>{item.commit}</TableRowCell> </TableRow> ); } Copy Step 7 of 10 Time to give your table a second look: The cell components you've added take care of properly formatting the data. Step 8 of 10 Add some action to your table! Tables are great, but interactive tables can be better: As a last update, you are going to allow users to act on each data row. Add the _getActions() method to your index.js file, right before _getItems(). As you may have guessed from the code, _getActions() spawns an alert box when you click Team or Commit cells. _getActions() { return [ { label: 'Alert Team', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__ALERT, onClick: (evt, { item, index }) => { alert(`Alert Team: ${item.team}`); }, }, { label: 'Rollback Version', iconType: TableRow.ACTIONS_ICON_TYPE.INTERFACE__OPERATIONS__UNDO, onClick: (evt, { item, index }) => { alert(`Rollback from: ${item.commit}`); }, }, ]; } Copy Step 9 of 10 Find the TableRow component in your return statement and point the actions property to _getActions(). The TableRow actions property defines a set of actions that appear when the user hovers over a table row. Actions have a mandatory text and an onClick callback, but can also display an icon or be disabled if needed. <TableRow actions={this._getActions()}> Copy Step 10 of 10 Go back to your application and try hovering over any of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You've built a table into a New Relic One application, using components to format data automatically and provide contextual actions. Well done! Keep exploring the Table components, their properties, and how to use them, in our SDK documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 567.28,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add tables to your <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "sections": "Add tables to your <em>New</em> <em>Relic</em> <em>One</em> <em>application</em>",
        "info": "Add a table to your <em>New</em> <em>Relic</em> <em>One</em> <em>app</em>.",
        "tags": "table in <em>app</em>",
        "body": " of the rows: Notice how the two available actions appear. When you click them, a function triggers with the selected row data as an argument, and an alert displays in your browser. Next steps You&#x27;ve built a table into a <em>New</em> <em>Relic</em> <em>One</em> application, using <em>components</em> to format data automatically and provide contextual actions. Well done! Keep exploring the Table <em>components</em>, their properties, and how to use them, in our <em>SDK</em> documentation."
      },
      "id": "5efa989ee7b9d2ad567bab51"
    },
    {
      "nodeid": 16416,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Plan your cloud adoption",
        "Optimize your cloud native environment",
        "Establish objectives and baselines: define team SLOs",
        "Service level components",
        "Resources",
        "1. Build an inventory of services requiring SLOs",
        "2. Research customer expectations for SLOs",
        "3. Define SLOs",
        "4. Determine what can be instrumented",
        "5. Review the default metrics",
        "6. Set up custom instrumentation",
        "7. Create Insights dashboards to track SLIs",
        "For more help"
      ],
      "title": "Establish objectives and baselines: define team SLOs",
      "type": "docs",
      "external_id": "c51fb6972a0e1d7cd72eaea21310026ec5ddb6a4",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/catalyst-establish-objectives-2.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/measure-devops-success/establish-objectives-baselines-define-team-slos",
      "published_at": "2020-09-14T22:11:43Z",
      "updated_at": "2020-09-10T10:32:39Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Measure DevOps success",
      "document_type": "page",
      "popularity": 1,
      "info": "Service level objectives (SLOs) provide a powerful mechanism to codify the goals of a DevOps team in a way that can be measured and shared.",
      "body": "A DevOps transformation requires a cultural shift so that teams can build new skills and motivations for the type of cross-team work required in a true DevOps practice. The transformation can be difficult when the people involved do not see the benefits of change as a clear objective. Service level objectives (SLOs) provide a powerful mechanism to codify the goals of a DevOps team in a way that can be measured and shared. They also provide clear boundaries on service expectations that help teams achieve greater velocity and freedom in experimenting with new approaches. This tutorial defines SLOs for successful service delivery objectives and utilize New Relic instrumentation to surface the current performance metrics relative to those objectives. Measurable SLOs and visibility into your current progress against those SLOs ensure that you will be able to properly assess future optimization efforts. Service level components An SLO is an agreed upon means of measuring the performance of your service. The SLO defines a target value of a specified quantitative measure, which is called a service level indicator (SLI); for example: Average response time Response time percentile Application availability SLOs clarify a target value for SLIs; for example: Average response time should be less than 200 ms 95% of requests should be completed within 250 ms Availability of the service should be 99.99% Logically group SLOs together to provide an overall boolean indicator of whether or not the service is meeting expectations. For example, a helpful SLO for alerting purposes could be: 95% of requests completed within 250 ms AND availability is 99.99% Service level components Example values SLI (Indicator) HTTP status codes SLO (Objective) < 1% HTTP 500s over 30 days SLA (Agreement) For every additional .1% of HTTP 500s, 5% refund of total contract Resources Value stream mapping can be a useful exercise to work through before setting SLOs. Work with your teams to clarify key components of your service and the appropriate metrics. Use these inputs as starting points for this tutorial. In addition: Learn about SLOs, SLIs, and SLAs from the Google Cloud Platform blog. Learn how New Relic has applied SLOs and SLIs into its reliability practices form this SREcon18 Americas presentation (approximately 21 minutes). 1. Build an inventory of services requiring SLOs Start defining SLOs for your application by first taking an inventory of the services that your application provides to both your internal and external customers. Draft a list of services. Make the scope of services you consider as comprehensive as possible. Engage your team members and other stakeholders to validate the list for completeness. Segment your application stack to understand the potential components that might require SLOs. For example, most applications can be segmented as: Application (backend/microservices) Dependency services (such as the message queue) Database Website Underlying servers This example lists components that would benefit from SLOs: Customer type Component name Owner Language stack Operating system External Service 1 John D. Java RHEL 6 Internal Service 2 Jane A. .NET Win2003 R2 Internal ActiveMQ John D. Java AIX External Website Jane A. Classic ASP Win2000 Internal MS SQL Dave Z. n/a Win2003 R2 Building a definitive list of services that require an SLO can be challenging, because an application often consists of many endpoints with complex interdependencies. Begin your SLO journey with pragmatism. Start by defining a broader, simpler set of SLOs that are driven by what your customers care about most and what your team can control. As your teams better align around SLOs, you can then begin to fine-tune and add more complexity. 2. Research customer expectations for SLOs Once you have an inventory of services, begin to gather the information you need to define the SLOs for those services. Interviews with customers that depend on your services are often valuable for understanding service expectations. For example, to define SLOs for internal teams, New Relic, ask questions such as: If possible, can you broadly categorize the types of requests we can expect from you and your service? To what extent do you or your service depend on timely responses to requests? Are there requests for which response time is not critical? How does your service handle unavailable dependencies or data? What is the maximum amount of unavailable data that your service can handle? At what threshold does your service fail if a request takes too long? What are acceptable rates of errors? What would a SLA look like between our product and yours? Existing usage data can also be a helpful research input. 3. Define SLOs Using the research on customer expectations that you gathered, draft a focused set of SLOs. New Relic recommends setting SLOs against one or more of the following SLIs: Application availability percentage Average response time Response percentile Error rate Apdex value Also, consider instrumenting and tracking the following SLIs: Throughput (peak and trough) Database call count and duration DNS and SSL timing DOM processing and page rendering Mean-time-to-detection (MTTD) For a more comprehensive list of potential areas to measure, see Measuring DevOps. Recommendation: To determine if your application is performing to customer expectations: Consider combining multiple SLIs (for example, availability and response time) into one SLO. Aim to define a consistent set of conditions across all of the services in your list. Consult your team and stakeholders to validate that the SLOs you set are reasonable, consistently attainable (even if you are not currently meeting them), and aligned to customer expectations. After you finish this step, you should have a set of well-defined SLOs and SLIs. 4. Determine what can be instrumented Now you are ready to deploy agents or monitors to establish a performance baseline for the SLIs you created. With proper instrumentation in place, you will have visibility into the performance indicators that matter for your team and your customers. In addition, you will also have a clear understanding of how to meet your SLOs. Identify the service components your team will optimize. Verify which application tiers meet New Relic monitoring requirements. To ensure you have robust baselines from which to work, determine the level of instrumentation that is possible (or allowed) within your organization. There may be situations where instrumentation of the current on-premise environment is not viable. For example, firewalls with certain settings may not permit New Relic agents to transmit data. Recommendation: If the application has a web front end in these situations, use New Relic Synthetics. Synthetics offers non-agent monitoring while still providing the ability to establish a baseline. To instrument the example applications and components in this tutorial, use these New Relic products: New Relic products Customer type Component name Tier owner Language stack Server OS New Relic products External Service 1 John D. Java RHEL 6 APM, Infrastructure, Synthetics Internal Service 2 Jane A. .Net Win2003 R2 APM, Infrastructure Internal ActiveMQ John D. Java AIX APM, Plugins External Website Jane A. Classic ASP Win2000 Synthetics Internal MS SQL Dave Z. NA Win2003 R2 Infrastructure, On-host integration APM installation After reviewing the compatibility and requirements for New Relic APM, install the APM agent on your application stack. Steps for installing APM agents vary based on language agent type. Follow the installation procedures for specific APM agents. Infrastructure installation After reviewing the requirements for New Relic Infrastructure, follow the installation procedures to install the Infrastructure agent on instances that host your applications. The New Relic Infrastructure agent requires the following host permissions: Linux: To install and run the agent, you must have root privileges. Windows: To install and run the agent, you must have Administrator privileges. Infrastructure on-host integrations To gain extended visibility into applications that your code depends on, deploy on-host integrations based on their availability. New Relic supports several commonly used application components, including MySQL, Apache, NGINX, and more. For more information, see New Relic's on-host integrations documentation. Synthetics New Relic Synthetics is a suite of automated, scriptable tools to monitor your websites, critical business transactions, and API endpoints. Follow the procedures to create a simple browser check. Be sure to verify that your website URL is accessible from the Synthetics public network locations. Browser New Relic Browser provides deep insights into how your users are interacting with your application or website. Browser complements Synthetics with data based on actual user experiences, which is useful in discerning how DevOps efforts are ultimately improving the experience for the customer. For more information, see the compatibility and requirements, then install the New Relic Browser agent. Mobile The growing role of mobile apps in customer experience often spurs new performance data needs. Installation of New Relic Mobile lets DevOps teams instrument iOS and Android applications to gain a fuller understanding of service delivery quality. Plugins Developers can use the New Relic Plugins product to create plugins that monitor numerical metrics provided by external services, hosts, or equipment. You can install existing plugins from Plugin Central, or plan, develop, test, and create your own plugins. 5. Review the default metrics After you deploy the agents and monitors, use service maps to review the default metrics that New Relic captures. For example, a typical service map show many of the common SLIs that application teams rely on, including response time, Apdex, throughput, and error rate metrics from APM. It also shows page load time, Ajax response, throughput, and error rate from Browser. rpm.newrelic.com > Service maps: To explore detailed granularity for any area, use the service map's nodes. 6. Set up custom instrumentation To close any remaining gaps in visibility for your SLIs, use custom instrumentation. New Relic provides several avenues for adding custom instrumentation, including: Making API calls to agents from inside your source code Packaging XML-based custom instrumentation modules with deployed applications Adding UI-based instrumentation without a code deploy In addition, you can add custom attributes to each transaction event that match application performance factors to critical business information. Then you can track those attributes in Insights dashboards. For more information, see the custom instrumentation documentation for your application: APM Browser Infrastructure Insights Mobile Synthetics 7. Create Insights dashboards to track SLIs Once you implement the appropriate instrumentation, it is easy to visualize your service level indicators with New Relic Insights dashboards. Insights provides a single location to query and view all the data that New Relic products gather. For example, Insights helps visualize the following data gathered from New Relic products: Infrastructure: Use default Infrastructure events and attributes for your systems, processes, events, storage, and network; Infrastructure integrations; and custom attributes. APM: Use Transaction and TransactionError event types. Browser: Use PageView and PageAction event types. Mobile: Use several Mobile event types. Synthetics: Use SyntheticCheck, SyntheticRequest, and SyntheticPrivateMinion event types. Each event has an event type, a timestamp, and one or more key attributes. For more information about the data that New Relic receives from your app, see Data collection. To query and view the data from the SLIs you selected for baselining: Use the Insights Data explorer to create widgets for your dashboards. Create dashboards that include widgets for the SLI baseline data. Use these widgets and dashboards to establish team dashboards that you can share and use to conduct operations reviews. insights.newrelic.com > (select a dashboard): Query your SLI baseline data, create dashboards with widgets to visualize the data, then share with your team and stakeholders.​ The metrics you capture will become your application's baseline. Share your Insights dashboard with your application team and stakeholders to provide visibility into what is happening with your application and to monitor future performance. For more help",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 567.0143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Establish objectives <em>and</em> baselines: define team SLOs",
        "sections": "<em>New</em> <em>Relic</em> solutions",
        "info": "Service level objectives (SLOs) provide a powerful mechanism to codify the goals of a DevOps team in a way that can be measured <em>and</em> shared.",
        "body": ". Each event has an event type, a timestamp, and <em>one</em> or more key attributes. For more information about the data that <em>New</em> <em>Relic</em> receives from your <em>app</em>, see Data collection. To <em>query</em> and view the data from the SLIs you selected for baselining: Use the Insights Data explorer to create widgets for your",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; Measure DevOps success"
      },
      "id": "5f5b215064441f4c48e06825"
    },
    {
      "nodeid": 32786,
      "sections": [
        "New Relic solutions",
        "Measure DevOps success",
        "Plan your cloud adoption",
        "Optimize your cloud native environment",
        "Migrate to microservices",
        "1. Deploy instrumentation on all application tiers and components",
        "2. Use key metrics to identify components that you can migrate to microservices",
        "3. Use deployment markers to establish app performance baselines",
        "4. Implement the new microservice-based architecture, and measure the success of your application development processes",
        "5. Create a dashboard to monitor KPIs",
        "6. Create a new baseline to use for comparisons",
        "For more help"
      ],
      "title": "Migrate to microservices ",
      "type": "docs",
      "external_id": "b8b8cd8f4c66a7b2d0af83e118b5c43bccfbd4a4",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new_processes.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/optimize-your-cloud-native-environment/migrate-microservices",
      "published_at": "2020-09-14T02:09:51Z",
      "updated_at": "2020-09-09T01:48:46Z",
      "breadcrumb": "Contents / New Relic solutions / New Relic solutions / Optimize your cloud native environment",
      "document_type": "page",
      "popularity": 1,
      "info": "Use microservices to optimize applications. With microservices, app developers can resolve issues faster and deliver an enhanced end-user experience.",
      "body": "As IT departments seek to optimize their cloud applications, they are decomposing application monoliths into microservices. A microservice architecture is an approach that delivers a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms. Following a service-oriented architecture (SOA) model, each service should offer public API interfaces to any other service in the environment. Fragmenting applications into their most basic services enables the continuous delivery/deployment of large, complex applications by removing barriers and silos that previously lengthened the application release cycle. It also enables an organization to evolve its technology stack for modern cloud environments and to operate at internet-scale. With microservices, app developers can build, manage, scale, and reuse services independently, resolve issues faster, increase the rate of deployments, and ultimately deliver an enhanced end-user experience. This quest to use microservices to optimize applications is an iterative process. We recommend the following six steps, using the New Relic platform, to ensure an effective migration path to microservices. 1. Deploy instrumentation on all application tiers and components In order to determine which components of an application can be broken into microservices, you need to deploy instrumentation on all tiers and components of the target application. This will allow you to determine baseline application performance, quantify transaction volumes, and gather other key metrics that will determine where you begin your microservice journey. Specifically, you should: Monitor your web apps with APM. See Compatibility and requirements for New Relic agents and products to learn precise compatibility details for each supported language, and then install the APM agent on your application stack. Steps for installing APM agents vary based on language. Monitor your compute resources with Infrastructure. See Compatibility and requirements for Infrastructure for supported operating systems and environments. You can also instrument other products and services with on-host integrations. In some cases, it may be helpful to use custom instrumentation to gather detailed performance metrics that aren’t necessarily required in the course of normal application monitoring. For example, you may want to add custom instrumentation to key controllers that are candidates for decomposition to gather very granular response time and throughput information. 2. Use key metrics to identify components that you can migrate to microservices Once you have instrumented your application, you can begin to identify which components are strong candidates to migrate to microservices. It is important to consult with colleagues who have written, designed, and/or maintained the application, to supplement the context that your baseline data provides. Their experience and recommendations will help to guide the decomposition effort. In addition, you should analyze objective metrics such as transaction call volume and response time. These metrics will point to components in your monolithic application that are heavily called and/or are responding slowly, which means that they are adding disproportionate load to the monolith, possibly degrading application performance and end-user experience. As microservices, it will be easier to regularly improve and optimize these components. As a result, you will be able to break away and eliminate the most pressing bottlenecks from your monolithic application. one.newrelic.com > APM > Transactions: Identify which components are slowing you down. 3. Use deployment markers to establish app performance baselines Breaking down monolithic applications into a microservice architecture is typically an iterative project. You will be continually identifying monolithic components that can be decomposed into microservices, and then optimizing them as business and technology requirements dictate. Deployment tracking lets you quickly see, in a side-by-side comparative view, how architectural and code changes impact your application’s performance. You can then use this information to direct future development efforts and to demonstrate return on investment to the business. You should make deployment markers an integral part of the development process by adding them into your build/deployment process automation. You can view instructions on setting up deployment markers on the Deployments page in APM. one.newrelic.com > APM > Events > Deployments: Understand how deployments affect your performance. 4. Implement the new microservice-based architecture, and measure the success of your application development processes Your developers should now have marching orders for which application components to migrate to microservices. It’s important for these teams to embrace modern software development practices to support your overarching business and technology initiatives. Measuring process improvements is vital to driving alignment and velocity. You should instrument your build/test pipeline using custom events. This will allow you to gather data about: The rate at which new code is moving through the pipeline Quality metrics (for example, what percent of the code is passing tests, if there is automated testing involved) The rate of new deployments via deployment markers These quantitative data points will allow development and operations teams to visualize the adoption of new processes, measure development team productivity, and assess whether these new processes are moving the needle positively or negatively. one.newrelic.com > Dashboards: Visualize the adoption of new processes with dashboards. 5. Create a dashboard to monitor KPIs Once you have determined that the application and its microservices components are (somewhat) production-ready, compare the performance of your new, modern application to the monolithic application (either today or how it performed pre-migration). This will allow you to demonstrate success and to highlight areas for improvement. Key KPIs to monitor and compare include Response Time, Error Rate, Transaction Call Volume, Operational Cost, Availability, and Apdex. one.newrelic.com > Dashboards: Build KPI dashboards to view all your indicators in one place. 6. Create a new baseline to use for comparisons At this point, you have migrated components of your monolithic application to microservices, and you are now empowered with up-to-date data on how your new application is performing compared to your legacy application. Now you have a new launching point for evaluating which other components of your application can be decomposed into microservices, or which microservice components require more performance tuning. For more help",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 555.9905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "1. Deploy instrumentation on all <em>application</em> tiers <em>and</em> <em>components</em>",
        "info": "Use microservices to optimize <em>applications</em>. With microservices, <em>app</em> developers can resolve issues faster <em>and</em> deliver an enhanced end-user experience.",
        "body": ", resolve issues faster, increase the rate of deployments, and ultimately deliver an enhanced end-user experience. This quest to use microservices to optimize applications is an iterative process. We recommend the following six steps, using the <em>New</em> <em>Relic</em> <em>platform</em>, to ensure an effective migration path",
        "breadcrumb": "Contents &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; <em>New</em> <em>Relic</em> solutions &#x2F; Optimize your cloud native environment"
      },
      "id": "5f58347e64441f8c45e0684c"
    }
  ],
  "/explore-docs/nr1-subscription": [
    {
      "sections": [
        "New Relic One CLI reference",
        "Installing the New Relic One CLI",
        "Tip",
        "New Relic One CLI Commands",
        "Get started",
        "Configure your CLI preferences",
        "Set up your Nerdpacks",
        "Manage your Nerdpack subscriptions",
        "Install and manage plugins",
        "Manage catalog information"
      ],
      "title": "New Relic One CLI reference",
      "type": "developer",
      "tags": [
        "New Relic One app",
        "nerdpack commands"
      ],
      "external_id": "858339a44ead21c83257778ce60b4c352cd30d3b",
      "image": "https://developer.newrelic.com/static/2c6d337608b38a3312b4fc740afe6167/7272b/developercenter.png",
      "url": "https://developer.newrelic.com/explore-docs/nr1-cli/",
      "published_at": "2020-09-16T01:53:49Z",
      "updated_at": "2020-08-18T01:50:36Z",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of the CLI to help you build, deploy, and manage New Relic apps.",
      "body": "New Relic One CLI reference To build a New Relic One app, you must install the New Relic One CLI. The CLI helps you build, publish, and manage your New Relic app. We provide a variety of tools for building apps, including the New Relic One CLI (command line interface). This page explains how to use CLI commands to: Generate Nerdpack/Nerdlet templates Locally serve Nerdpacks (when developing) Publish and deploy Subscribe to Nerdpacks Add screenshots and metadata to the catalog Installing the New Relic One CLI In New Relic, click Apps and then in the New Relic One catalog area, click the Build your own application launcher and follow the quick start instructions. The quick start automatically generates an API key for the account you select, and gives you the pre-populated commands to create a profile, generate your first \"Hello World\" app, and serve it locally. Tip Use the NR1 VS Code extension to build your apps. New Relic One CLI Commands This table provides descriptions for the New Relic One commands. For more context, including usage and option details, click any individual command or the command category. For details on user permissions, see Authentication and permissions. For more on how to serve and publish your application, see our guide on Deploying your New Relic One app. Get started nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). Configure your CLI preferences nr1 config:set Sets a specific configuration value. nr1 config:get Shows a specific configuration. nr1 config:list Lists your configuration choices. nr1 config:delete Removes the value of a specific configuration. Set up your Nerdpacks nr1 nerdpack:clone Clones an open source Nerdpack from our GitHub repository. nr1 nerdpack:serve Serves your Nerdpack for testing and development purposes. nr1 nerdpack:uuid Shows or regenerates the UUID of a Nerdpack. nr1 nerdpack:publish Publishes your Nerdpack to New Relic. nr1 nerdpack:deploy Deploys a Nerdpack version to a specific channel. nr1 nerdpack:undeploy Undeploys a Nerdpack version from a specific channel. Manage your Nerdpack subscriptions nr1 subscription:set Subscribes your account to a Nerdpack and channel. nr1 subscription:list Lists all the Nerdpacks your account is subscribed to. nr1 subscription:unset Unsubscribes your account from a Nerdpack. Install and manage plugins nr1 plugins:install Installs a plugin into the CLI. nr1 plugins:link Links a plugin into the CLI for development. nr1 plugins:update Updates your installed plugins. nr1 plugins:uninstall Removes a plugin from the CLI. Manage catalog information nr1 catalog:info Shows the Nerdpack info stored in the catalog. nr1 catalog:submit Gathers and submits the catalog info on the current folder.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.4049,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> reference",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em>",
        "info": "An overview of the <em>CLI</em> to help you build, deploy, and manage <em>New</em> <em>Relic</em> apps.",
        "tags": "<em>New</em> <em>Relic</em> <em>One</em> app",
        "body": " extension to build your apps. <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> <em>Commands</em> This table provides descriptions for the <em>New</em> <em>Relic</em> <em>One</em> <em>commands</em>. For more context, including usage and option details, click any individual <em>command</em> or the <em>command</em> category. For details on user permissions, see Authentication and permissions"
      },
      "id": "5efa989e28ccbc535a307dd0"
    },
    {
      "sections": [
        "New Relic CLI Reference",
        "New Relic CLI commands",
        "Options",
        "Commands"
      ],
      "title": "New Relic CLI Reference",
      "type": "developer",
      "tags": "new relic cli",
      "external_id": "471ed214caaf80c70e14903ec71411e2a1c03888",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/newrelic-cli/",
      "published_at": "2020-09-16T01:48:57Z",
      "updated_at": "2020-08-14T01:47:12Z",
      "document_type": "page",
      "popularity": 1,
      "info": "The command line tools for performing tasks against New Relic APIs",
      "body": "New Relic CLI Reference The New Relic CLI enables the integration of New Relic into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding New Relic into your CI/CD pipeline. New Relic CLI commands Find details for the New Relic CLI command docs in GitHub. Options --format string output text format [YAML, JSON, Text] (default \"JSON\") -h, --help help for newrelic --plain output compact text Copy Commands newrelic apm - Interact with New Relic APM newrelic completion - Generates shell completion functions newrelic config - Manage the configuration of the New Relic CLI newrelic documentation - Generate CLI documentation newrelic entity - Interact with New Relic entities newrelic nerdgraph - Execute GraphQL requests to the NerdGraph API newrelic nerdstorage - Read, write, and delete NerdStorage documents and collections. newrelic nrql - Commands for interacting with the New Relic Database newrelic profile - Manage the authentication profiles for this tool newrelic version - Show the version of the New Relic CLI newrelic workload - Interact with New Relic One workloads",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.56609,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference",
        "sections": "<em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em>",
        "info": "The <em>command</em> line tools for performing tasks against <em>New</em> <em>Relic</em> APIs",
        "tags": "<em>new</em> <em>relic</em> <em>cli</em>",
        "body": "<em>New</em> <em>Relic</em> <em>CLI</em> Reference The <em>New</em> <em>Relic</em> <em>CLI</em> enables the integration of <em>New</em> <em>Relic</em> into your existing workflows. Be it fetching data from your laptop while troubleshooting an issue, or adding <em>New</em> <em>Relic</em> into your CI&#x2F;CD pipeline. <em>New</em> <em>Relic</em> <em>CLI</em> <em>commands</em> Find details for the <em>New</em> <em>Relic</em> <em>CLI</em> <em>command</em> docs"
      },
      "id": "5efa989ee7b9d2024b7bab97"
    },
    {
      "sections": [
        "Intro to NerdStorage",
        "Use NerdStorage in your apps",
        "Data model",
        "Limits",
        "Data access",
        "Permissions for working with NerdStorage"
      ],
      "title": "Intro to NerdStorage",
      "type": "developer",
      "tags": [
        "nerdstorage",
        "nerdstorage components",
        "new relic one apps",
        "data access"
      ],
      "external_id": "709e06c25376d98b2191ca369b4d139e5084bd62",
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nerdstorage/",
      "published_at": "2020-09-16T01:48:56Z",
      "updated_at": "2020-09-08T01:50:19Z",
      "document_type": "page",
      "popularity": 1,
      "info": "Intro to NerdStorage on New Relic One",
      "body": "Intro to NerdStorage 30 min To help you build a New Relic One application, we provide you with the New Relic One SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users's configuration settings and preferences (like favorites), or any other small data sets. This storage is unique per Nerdpack, and can't be shared with any other Nerdpack. NerdStorage can be classified into three categories: User storage: Data that is attached to a particular user. If you’re authenticated as the user the data is attached to, you can read it and write it. Account storage: Data that is attached to a particular account. If you’re authenticated and can access the account, you can read and write to account scoped NerdStorage. Visibility of account data is also determined by master/subaccount rules: If a user has access to the master account, then they also have access to data in all subaccounts. Entity storage: Data that is attached to a particular entity. If you can see the corresponding entity, you can read and write data on that entity. Data model You can imagine NerdStorage as a nested key-value map. Data is inside documents, which are nested inside collections: { 'YourNerdpackUuid': { 'collection-1': { 'document-1-of-collection-1': '{\"lastNumber\": 42, \"another\": [1]}', 'document-2-of-collection-1': '\"userToken\"', // ... }, 'another-collection': { 'fruits': '[\"pear\", \"apple\"]', // ... }, // ... }, } Copy Each NerdStorage level has different properties and purpose: Collections: From a Nerdpack, you can create multiple collections by naming each of them. Inside a collection you can put one or more documents. Think of a collection as key-value storage, where each document is a key-value pair. Documents: A document is formed by an identifier (documentId) and a set of data associated with it. Data associated with a document: NerdStorage accepts any sort of data associated to a documentId. Query and mutation components that are provided work by serializing and deserializing JSON. Limits A Nerdpack can hold up to 1,000 collections and 10,000 documents, plus storage type. A collection can hold up to 1,500 documents, plus storage type. Each document can have a maximum length of 1024 KiB when serialized. Data access To access NerdStorage, you can run NerdGraph queries, or use the provided storage queries. Depending on which storage you want to access, you can use a different set of SDK components: User access: UserStorageQuery and UserStorageMutation Account access: AccountStorageQuery and AccountStorageMutation Entity access: EntityStorageQuery and EntityStorageMutation Each of these components can operate declaratively (for example, as part of your React rendering methods) or imperatively (by using the static methods for query and mutation). For more information on this, see Data querying and mutations. Permissions for working with NerdStorage In order to persist changes on NerdStorage, such as creating, updating, and deleting account and entity storage, you must have a user role with permission to persist changes.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.30423,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "info": "Intro to NerdStorage on <em>New</em> <em>Relic</em> <em>One</em>",
        "tags": "<em>new</em> <em>relic</em> <em>one</em> apps",
        "body": "Intro to NerdStorage 30 min To help you build a <em>New</em> <em>Relic</em> <em>One</em> application, we provide you with the <em>New</em> <em>Relic</em> <em>One</em> SDK. On this page, you’ll learn how to use NerdStorage SDK components. Use NerdStorage in your apps NerdStorage is used to store and retrieve simple sets of data, including users"
      },
      "id": "5efa989ee7b9d2048e7bab92"
    },
    {
      "image": "",
      "url": "https://developer.newrelic.com/explore-docs/nr1-common/",
      "sections": [
        "New Relic One CLI common commands",
        "Command details",
        "nr1 help",
        "See commands and get details",
        "Usage",
        "Arguments",
        "Examples",
        "nr1 update",
        "Update your CLI",
        "nr1 create",
        "Create a new component",
        "Options",
        "nr1 profiles",
        "Manage your profiles keychain",
        "Commands",
        "nr1 autocomplete",
        "See autocomplete installation instructions",
        "nr1 nrql",
        "Query using NRQL"
      ],
      "published_at": "2020-09-16T01:49:54Z",
      "title": "New Relic One CLI common commands",
      "updated_at": "2020-08-14T01:48:10Z",
      "type": "developer",
      "external_id": "503e515e1095418f8d19329517344ab209d143a4",
      "document_type": "page",
      "popularity": 1,
      "info": "An overview of common commands you can use with the New Relic One CLI.",
      "body": "New Relic One CLI common commands Here's a list of common commands to get you started with the New Relic One CLI. You can click any command to see its usage options and additional details about the command. Command Description nr1 help Shows all nr1 commands or details about each command. nr1 update Updates to the latest version of the CLI. nr1 create Creates a new component from a template (Nerdpack, Nerdlet, launcher, or catalog). nr1 profiles Manages the profiles you use to run CLI commands. nr1 autocomplete Displays autocomplete installation instructions. nr1 nrql Fetches data using NRQL (New Relic query language). See our other New Relic One CLI docs for commands specific to Nerdpack set-up, Nerdpack subscriptions, CLI configuration, plugins, or catalogs. Command details nr1 help See commands and get details Shows all nr1 commands by default. To get details about a specific command, run nr1 help COMMAND_NAME. Usage $ nr1 help Arguments COMMAND_NAME The name of a particular command. Examples $ nr1 help $ nr1 help nerdpack $ nr1 help nerdpack:deploy nr1 update Update your CLI Updates to latest version of the CLI. You can specify which channel to update if you'd like. Usage $ nr1 update Arguments CHANNEL The name of a particular channel. Examples $ nr1 update $ nr1 update somechannel nr1 create Create a new component Creates a new component from our template (either a Nerdpack, Nerdlet, launcher, or catalog). The CLI will walk you through this process. To learn more about Nerdpacks and their file structure, see Nerdpack file structure. For more on how to set up your Nerdpacks, see our Nerdpack CLI commands. Usage $ nr1 create Options -f, --force If present, overrides existing files without asking. -n, --name=NAME Names the component. -t, --type=TYPE Specifies the component type. --path=PATH The route to the component. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output. nr1 profiles Manage your profiles keychain Displays a list of commands you can use to manage your profiles. Run nr1 help profiles:COMMAND for more on their specific usages. You can have more than one profile, which is helpful for executing commands on multiple New Relic accounts. To learn more about setting up profiles, see our Github workshop. Usage $ nr1 profiles:COMMAND Commands profiles:add Adds a new profile to your profiles keychain. profiles:default Chooses which profile should be default. profiles:list Lists the profiles on your keychain. profiles:remove Removes a profile from your keychain. nr1 autocomplete See autocomplete installation instructions Displays the autocomplete installation instructions. By default, the command displays the autocomplete instructions for zsh. If you want instructions for bash, run nr1 autocomplete bash. Usage $ nr1 autocomplete Arguments SHELL The shell type you want instructions for. Options -r, --refresh-cache Refreshes cache (ignores displaying instructions). Examples $ nr1 autocomplete $ nr1 autocomplete zsh $ nr1 autocomplete bash $ nr1 autocomplete --refresh-cache nr1 nrql Query using NRQL Fetches data from databases using a NRQL query. To learn more about NRQL and how to use it, see our NRQL docs. Usage $ nr1 nrql OPTION ... Options -a, --account=ACCOUNT The user account ID. required -q, --query=QUERY The NRQL query to run. required -u, --ugly Displays the content without tabs or spaces. --profile=PROFILE The authentication profile you want to use. --verbose Adds extra information to the output.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.12961,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "sections": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em>",
        "info": "An overview of common <em>commands</em> you can use with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>.",
        "body": "<em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em> common <em>commands</em> Here&#x27;s a list of common <em>commands</em> to get you started with the <em>New</em> <em>Relic</em> <em>One</em> <em>CLI</em>. You can click any <em>command</em> to see its usage options and additional details about the <em>command</em>. <em>Command</em> Description nr1 help Shows all nr1 <em>commands</em> or details about each <em>command</em>. nr1"
      },
      "id": "5f28bd6ae7b9d267996ade94"
    },
    {
      "category_2": "Get started",
      "nodeid": 27692,
      "sections": [
        "AWS Lambda monitoring",
        "Get started",
        "UI and data",
        "Troubleshooting",
        "Enable serverless monitoring for AWS Lambda",
        "How Lambda monitoring works",
        "Enable procedure overview",
        "Step 1. Install the newrelic-lambda-cli tool",
        "CLI requirements:",
        "CLI installation:",
        "Step 2. Connect AWS to New Relic",
        "Use CLI tool",
        "Manual procedures",
        "Step 3. Enable Lambda instrumentation",
        "Step 4. Configure CloudWatch logs to stream to New Relic Lambda",
        "What's next?",
        "Optional: Stream all logs to New Relic",
        "For more help"
      ],
      "title": "Enable serverless monitoring for AWS Lambda",
      "category_0": "Serverless function monitoring",
      "type": "docs",
      "category_1": "AWS Lambda monitoring",
      "translation_ja_url": "https://docs.newrelic.co.jp/docs/serverless-function-monitoring/aws-lambda-monitoring/get-started/enable-serverless-monitoring-aws-lambda",
      "external_id": "c74a212be895f2cc4e5b22d74ab3c0f1e77abf94",
      "image": "https://docs.newrelic.com/sites/default/files/thumbnails/image/new-relic-lambda-monitoring-architecture.png",
      "url": "https://docs.newrelic.com/docs/serverless-function-monitoring/aws-lambda-monitoring/get-started/enable-serverless-monitoring-aws-lambda",
      "published_at": "2020-09-14T03:07:22Z",
      "updated_at": "2020-09-10T23:47:01Z",
      "breadcrumb": "Contents / Serverless function monitoring / AWS Lambda monitoring / Get started",
      "document_type": "page",
      "popularity": 1,
      "info": "Read about how to install and enable New Relic monitoring for Amazon AWS Lambda. ",
      "body": "Serverless monitoring for AWS Lambda offers in-depth performance monitoring for your Lambda functions. Read on to learn how to enable this feature and get started using it. Using this feature may result in AWS charges. For more information, see the Lambda monitoring requirements.​​​ How Lambda monitoring works Before enabling Lambda monitoring, understanding how data flows from your Lambda functions to New Relic may be helpful: Diagram showing how data flows from a Lambda function to New Relic. When our Lambda monitoring is enabled, this is how data moves from your Lambda function to New Relic: The Lambda function is instrumented with our code. When the Lambda is invoked, log data is sent to CloudWatch. CloudWatch collects Lambda log data and sends it to our log-ingestion Lambda. The log-ingestion Lambda sends that data to New Relic. Enable procedure overview If you already have a New Relic account and use Node.js or Python, we recommend you use our automated installer. If you do not use the automated installer, complete these steps to set up monitoring: Install our CLI tool (recommended) Connect AWS and New Relic (required) Enable instrumentation of your Lambda (required) Stream CloudWatch logs to New Relic (required) Step 1. Install the newrelic-lambda-cli tool We provide a command line interface (CLI) tool that's used in steps 2 through 4. We recommend the CLI because it simplifies some of the work, but you can also perform those steps manually. If you want to understand what it does before you install it, see the manual procedures that the CLI tool performs in Step 2, Step 3 (option 2), and Step 4. You can also see the CLI documentation on GitHub. If you prefer a manual install, skip to Step 2. Connect AWS to New Relic. CLI requirements: To use the CLI too, you need: Python 3.3 or higher The AWS CLI You must be a user or admin with an infrastructure manager Add-on role. Your AWS account needs permissions for creating IAM resources (Role and Policy) and Lambda functions. These resources are created using CloudFormation stacks, so you'll need permissions to create those. For more on permissions, including setting custom policies, expand this collapser: AWS permissions details Resource: * Actions: \"cloudformation:CreateChangeSet\", \"cloudformation:CreateStack\", \"cloudformation:DescribeStacks\", \"cloudformation:ExecuteChangeSets\", \"iam:AttachRolePolicy\", \"iam:CreateRole\", \"iam:GetRole\", \"iam:PassRole\", \"lambda:AddPermission\", \"lambda:CreateFunction\", \"lambda:GetFunction\", \"logs:DeleteSubscriptionFilter\", \"logs:DescribeSubscriptionFilters\", \"logs:PutSubscriptionFilter\" \"s3:GetObject\" \"serverlessrepo:CreateCloudFormationChangeSet\" Resource: \"arn:aws:serverlessrepo:us-east-1:463657938898:applications/NewRelic-log-ingestion\" Actions: \"serverlessrepo:CreateCloudFormationTemplate\" \"serverlessrepo:GetCloudFormationTemplate\" Be sure that the AWS account you use to execute the CLI has all of these permissions. If your AWS account permissions are restrictive and you're unable to use the CLI, you can optionally use a manually managed custom IAM policy. This policy would require, at minimum, the following permissions: Resource: \"*\" Action: \"cloudwatch:GetMetricStatistics\" \"cloudwatch:ListMetrics\" \"cloudwatch:GetMetricData\" \"lambda:GetAccountSettings\" \"lambda:ListFunctions\" \"lambda:ListAliases\" \"lambda:ListTags\" \"lambda:ListEventSourceMappings\" These permissions are the minimum required. We recommend granting a managed ReadOnlyAccess policy as described in Connect AWS to infrastructure monitoring. CLI installation: To install the CLI tool: Ensure you have the required permissions for both your New Relic and AWS account. From the command line, run: pip install newrelic-lambda-cli You may need to use pip3 in the command above if you have Python 2.7 installed. The CLI requires Python >=3.3. Step 2. Connect AWS to New Relic You must complete this step, and steps 3 and 4, to enable our Lambda monitoring. This step connects AWS to New Relic and creates a newrelic-log-ingestion Lambda function that sends your instrumented data to New Relic. You can either use the CLI tool or do the steps manually. Use CLI tool When you use the CLI, you have one optional step and one required step: Optional: If you're using multiple AWS profiles or multiple regions, you may want to configure the AWS environment variables: AWS environment variable instructions Setting the region To configure your region, use this environment variable to override the default region: export AWS_DEFAULT_REGION=MY_REGION # us-west-2, for example The CLI tool also allows passing this per-command using --aws-region. Setting profiles If you have multiple AWS profiles and don't want to use the default, use AWS_PROFILE environment variable to set another profile name. Ensure the profile is properly configured (including the default region). Example: export AWS_PROFILE=MY_PROFILE Run the following command using the CLI tool: newrelic-lambda integrations install --nr-account-id YOUR_ACCOUNT_ID \\ --linked-account-name YOUR_LINKED_ACCOUNT_NAME \\ --nr-api-key YOUR_NR_API_KEY This command: Connects your AWS account to New Relic. Installs a newrelic-log-ingestion Lambda that will send your instrumented data to New Relic. More details: This defaults to U.S. region. If your account is in the EU region, add this argument: --nr-region \"eu\". If you're instrumenting functions in multiple AWS regions, this command must be run for each region using the --aws-region argument. YOUR_LINKED_ACCOUNT_NAME is either a new AWS account you want to link to New Relic, or it's the name of the AWS account that you linked to when setting up the AWS Lambda monitoring integration. YOUR_NR_API_KEY refers to your personal API key (not your REST API key). For more on the API key and other arguments, see our Lambda monitoring GitHub repo. Manual procedures Here are the manual procedures performed by the CLI tool: Connect AWS to New Relic The newrelic-lambda integration command connects the AWS account containing your Lambdas to New Relic. If you've already installed one of our AWS integrations, your accounts should be linked to New Relic and you can skip this section. To manually establish this connection, follow the instructions for connecting AWS to Infrastructure monitoring. Configure our log-ingestion Lambda The newrelic-lambda integration command sets up a newrelic-log-ingestion Lambda. This Lambda takes the logs generated by your Lambda functions and pushes those logs to New Relic. If you're configuring this manually, you must configure our Lambda for the regions you want. The CLI, by default, establishes our Lambda in all regions. To manually configure our Lambda, go to the AWS Serverless Application Repository, which is where the newrelic-log-ingestion Lambda is stored. This repo is a collection of serverless applications published by developers, companies, and partners in the serverless community. It allows developers to share their Lambda functions code with customers, who can then find and deploy the corresponding application Lambda function. Each application is packaged with an AWS Serverless Application Model (SAM) template that defines the AWS resources used. To manually configure our Lambda with the AWS Serverless Application Repository: From the AWS console, go to the Lambda section, select Create function, and select Serverless Application Repository. Search for newrelic and find the newrelic-log-ingestion Lambda. Follow the instructions in the Lambda's documentation to deploy it. A SAM template will build the Lambda. In the environment variable section in AWS console, set the LICENSE_KEY environment variable to your New Relic license key. Note: If you have multiple accounts or a master and sub-account hierarchy, make sure the license key you're using matches the same account connected to AWS. Optional: If you want to stream all your logs to New Relic, set the LOGGING_ENABLED environment variable to true. For more on this, see Stream all logs. Step 3. Enable Lambda instrumentation This step enables instrumentation of your Lambda function, which allows detailed monitoring and alerting functionality. Our instrumentation is designed to have minimal impact on your Lambda performance. If you're using Node.js or Python, we recommend the first two options. Option #1: Use Serverless Framework plugin (Node.js and Python) Requirements Available only for Node.js and Python. For other languages, see Manual instrumentation. Serverless Framework version 1.34.0 or higher. Features If you meet the requirements (above), you can use our Serverless Framework plugin, which allows you to add our AWS Lambda Layer to your functions without requiring a code change. Supports Node.js and Python runtimes No code change required to enable Lambda instrumentation Enables our APM agent functionality using a single layer Configures CloudWatch subscription filters automatically Gets the layer into your code base which is useful for redeploys Install To install our Serverless Framework plugin: Choose an install option: NPM: npm install --save-dev serverless-newrelic-lambda-layers yarn: yarn add --dev serverless-newrelic-lambda-layers Add the plugin to your serverless.yml: plugins: - serverless-newrelic-lambda-layers Get your account ID and put it in the serverless.yml: custom: newRelic: accountId: YOUR_ACCOUNT_ID Deploy it: sls deploy You can skip Step 4. Setting up CloudWatch Logs. This is automatically completed on deploy by our Serverless Framework plugin. For the next step, go to What's next? Option #2: Add Lambda Layer with our CLI (Node.js and Python) Available only for Node.js and Python. For other languages, see Manual instrumentation. If you don’t have Serverless Framework and don't intend to redeploy your function frequently, you can use the CLI to add our Lambda Layer: If you haven't already done so, install the CLI: pip install newrelic-lambda-cli List available functions: newrelic-lambda functions list Pass the option -f not-installed to see which functions have not yet been instrumented. Add the layer to your function: newrelic-lambda layers install --function FUNCTION_NAME --nr-account-id NEW_RELIC_ACCOUNT_ID Next, you will configure CloudWatch to send logs to New Relic. Option #3: Manually add our Lambda Layer (Node.js and Python) Available only for Node.js and Python. For other languages, see Manual instrumentation. If you don’t have Serverless Framework, you can manually add our Lambda Layer: Find the layer that matches your runtime and region. Copy the Amazon Resource Name (ARN) of the most recent version and add it in the AWS Lambda console for your function. Update your functions handler to point to the newly attached layer in the console for your function: Python: newrelic_lambda_wrapper.handler Node: newrelic-lambda-wrapper.handler Add these environment variables to your Lambda console: NEW_RELIC_ACCOUNT_ID: Your account ID NEW_RELIC_LAMBDA_HANDLER: Path to your initial handler. If you have Node 8 and get a Lambda can't find file error message, expand this collapser: Node 8 \"can't find file\" error troubleshooting If you have Node 8 and receive a Lambda can't find the file newrelic-lambda-wrapper.js message, it's likely that the Node runtime isn't resolving NPM_PATH for the newrelic-lambda module in /opt/nodejs/node_modules. These steps should fix this problem: Create a newrelic-wrapper-helper.js script in your project's root. The script's contents should be module.exports = require('newrelic-lambda-wrapper');. (That is all that needs to be in that script.) Update the handler for your layer declaration to newrelic-lambda-wrapper.handler. Next, you will configure CloudWatch to send logs to New Relic. Option #4: Manually instrument Lambda code for Go, Java, .NET Core, Node.js, and Python If none of the previous options work for you, you can manually instrument your Lambda code. Choose your language: Go To instrument your Go-language Lambda: Download our Go agent package and place it in the same directory as your function. Install the agent: go get -u github.com/newrelic/go-agent. In your Lambda code, import our components, create an application, and update how you start your Lambda. See our GitHub repo for an example of an instrumented Lambda. Optional: Add custom events that will be associated with your Lambda invocation by using the RecordCustomEvent API. For example: func handler(ctx context.Context) { if txn := newrelic.FromContext(ctx); nil != txn { txn.Application().RecordCustomEvent(\"MyEvent\", map[string]interface{}{ \"zip\": \"zap\", }) } fmt.Println(\"hello world!\") } Build and zip your Lambda function and upload it to AWS. Zip and upload recommendations Here are suggestions for zipping and uploading the Lambda: Build the binary for execution on Linux. This produces a binary file called main. You can use: $ GOOS=linux go build -o main Zip the binary into a deployment package using: $ zip deployment.zip main Upload the zip file to AWS using either the AWS Lambda console or the AWS CLI. Name the handler main (to match the name given during the binary build). The following environment variables are not required for Lambda monitoring to function but they are required if you want your Lambda functions to be included in distributed traces. To enable distributed tracing, set these environment variables in the AWS console: NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a sub-account, this is the account ID for the root/parent account. Optional: To configure logging, see Go agent logging. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next, you'll configure CloudWatch to send those logs to New Relic. Java Monitoring for AWS Lambda in Java doesn't use our APM Java agent. Instead, it uses these two OpenTracing dependencies: AWS Lambda OpenTracing Java SDK: OpenTracing instrumentation for AWS Lambda RequestHandler and RequestStreamHandler. Our AWS Lambda OpenTracing Tracer: An OpenTracing Tracer implementation designed to monitor AWS Lambda. It generates spans, error events, transaction events, error traces, and provides distributed tracing support. Supported OpenTracing Versions OpenTracing 0.31.0: Lambda Tracer: com.newrelic.opentracing:newrelic-java-lambda:1.1.1 Lambda SDK: com.newrelic.opentracing:java-aws-lambda:1.0.0 OpenTracing 0.32.0, 0.33.0: Lambda Tracer: com.newrelic.opentracing:newrelic-java-lambda:2.1.1 Lambda SDK: com.newrelic.opentracing:java-aws-lambda:2.1.0 To instrument your Java Lambda: In your project’s build.gradle file, include our OpenTracing AWS Lambda Tracer and the AWS Lambda OpenTracing SDK dependencies: dependencies { compile(\"com.newrelic.opentracing:java-aws-lambda:2.1.0\") compile(\"com.newrelic.opentracing:newrelic-java-lambda:2.1.1\") compile(\"io.opentracing:opentracing-util:0.33.0\") } Implement the AWS Lambda RequestHandler interface as shown in the Java Lambda example and override the doHandleRequest method. In the doHandleRequest method, call the LambdaTracing.instrument(...) API to create a root span to trace the lambda function's execution. This is also where you will define your business logic for the lambda function. Register a LambdaTracer.INSTANCE as the OpenTracing Global tracer, as shown in the Java Lambda example. Create a ZIP deployment package and upload it to AWS Lambda. Or deploy it via other means. In the AWS Lambda console, set the handler. For the example Java Lambda, the handler would be com.handler.example.MyLambdaHandler::handleRequest. Because handleRequest is assumed, you could also use com.handler.example.MyLambdaHandler. The following AWS console environment variables are required if you want your Lambda function to be included in distributed tracing. This is recommended. NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_PRIMARY_APPLICATION_ID. This is also your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a sub-account, this must be the account ID for the root/parent account. Optional: In the Lambda console, enable debug logging by adding this environment variable: NEW_RELIC_DEBUG is true. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next, you'll configure CloudWatch to send those logs to New Relic. Please see the AWS Lambda distributed tracing example for a complete project that illustrates common use cases such as: Distributed tracing between Lambda functions Manual span creation (aka custom instrumentation) Tracing external calls Adding custom attributes (aka Tags) to spans .NET Core Our monitoring of .NET Core-based AWS Lambda functions doesn't use our standard .NET Core APM agent. Instead, it uses a NuGet package. To instrument your .NET Core Lambda: In your Lambda Functions project, install the NewRelic.OpenTracing.AmazonLambda.Tracer NuGet package. Import the NuGet package and OpenTracing utils: using OpenTracing.Util; using NewRelic.OpenTracing.AmazonLambda; Instrument your function, as shown in this example: public class Function { static Function() { // Register The NewRelic Lambda Tracer Instance GlobalTracer.Register(NewRelic.OpenTracing.AmazonLambda.LambdaTracer.Instance); } public object FunctionWrapper(ILambdaContext context) { // Instantiate NewRelic TracingWrapper and pass your FunctionHandler as // an argument return new TracingRequestHandler().LambdaWrapper(FunctionHandler, context); } /// <summary> /// A simple function that takes a string and does a ToUpper /// </summary> /// <param name=\"input\"></param> /// <param name=\"context\"></param> /// <returns></returns> public object FunctionHandler(ILambdaContext context) { ... } } The arguments passed to FunctionWrapper must match the signature of FunctionHandler. If your handler function returns a Task, the Lambda wrapper will block on the return task until it completes, so that it can measure the duration and capture exceptions, if any are present. In addition, you may also inherit from the APIGatewayProxyFunction. For an example, see below: Async handler function public override Task<int> FunctionHandlerAsync(ILambdaContext lambdaContext) { // This call will block by calling task.Result Task<int> task = new TracingRequestHandler().LambdaWrapper( ActualFunctionHandlerAsync, lambdaContext); return task; } public Task<APIGatewayProxyResponse> ActualFunctionHandlerAsync(ILambdaContext lambdaContext) { // Function can make other async operations here ... } Inheriting from APIGatewayProxyFunction public class LambdaFunction : APIGatewayProxyFunction { static LambdaFunction() { // Register The NewRelic Lambda Tracer Instance OpenTracing.Util.GlobalTracer.Register(NewRelic.OpenTracing.AmazonLambda.LambdaTracer.Instance); } public override Task<APIGatewayProxyResponse> FunctionHandlerAsync(APIGatewayProxyRequest request, ILambdaContext lambdaContext) { Task<APIGatewayProxyResponse> task = new TracingRequestHandler().LambdaWrapper(ActualFunctionHandlerAsync, request, lambdaContext); return task; } public Task<APIGatewayProxyResponse> ActualFunctionHandlerAsync(APIGatewayProxyRequest request, ILambdaContext lambdaContext) { return base.FunctionHandlerAsync(request, lambdaContext); } } Optional for SQS and SNS: Starting in version 1.0 of our .NET Lambda Tracer, distributed tracing support has been added for SQS and SNS. To enable distributed tracing for SQS or SNS you will need to complete the items in this step as well as setup the environment variables in the step that follows this one. Enabling distributed tracing support for SQS and SNS will disable automatic instrumentation for both of SQS and SNS and require the use of these wrappers to instrument them. Set the NEW_RELIC_USE_DT_WRAPPER environment variable to true. To instrument SQS and SNS calls you will need to use the provided wrappers. Using the SQS Wrapper The SQS wrapper supports wrapping the following methods: Amazon.SQS.AmazonSQSClient.SendMessageAsync(...) Amazon.SQS.AmazonSQSClient.SendMessageBatchAsync(...) Examples // SQS Client AmazonSQSClient client = new AmazonSQSClient(\"AWS_SECRET_ACCESS_KEY\", AWS_REGION); // SendMessageRequest SendMessageRequest sendRequest = new SendMessageRequest(\"QUEUE_URI_STRING\", \"An SQS Message\"); Task<SendMessageResponse> responseOne = SQSWrapper.WrapRequest(client.SendMessageAsync, sendRequest); // String-based Task<SendMessageResponse> responseTwo = SQSWrapper.WrapRequest(client.SendMessageAsync, \"QUEUE_URI_STRING\", \"Another SQS Message\"); // SendMessageBatchRequest List<SendMessageBatchRequestEntry> batchEntries = new List<SendMessageBatchRequestEntry>(); batchEntries.Add(new SendMessageBatchRequestEntry(\"id1\", \"First SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id2\", \"Second SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id3\", \"Third SQS Message\")); SendMessageBatchRequest sendBatchRequest = new SendMessageBatchRequest(QUEUE_URI, batchEntries); Task<SendMessageBatchResponse> response = SQSWrapper.WrapRequest(client.SendMessageBatchAsync, sendBatchRequest); // SendMessageBatchRequestEntry List List<SendMessageBatchRequestEntry> moreBatchEntries = new List<SendMessageBatchRequestEntry>(); batchEntries.Add(new SendMessageBatchRequestEntry(\"id4\", \"Fourth SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id5\", \"Fifth SQS Message\")); batchEntries.Add(new SendMessageBatchRequestEntry(\"id6\", \"Sixth SQS Message\")); Task<SendMessageBatchResponse> response = SQSWrapper.WrapRequest(client.SendMessageBatchAsync, moreBatchEntries); Using the SNS Wrapper The SNS wrapper supports wrapping the following methods: Amazon.SimpleNotificationService.AmazonSimpleNotificationServiceClient.PublishAsync(...) Examples // SNS Client AmazonSimpleNotificationServiceClient client = new Amazon.SimpleNotificationService.AmazonSimpleNotificationServiceClient(\"AWS_SECRET_ACCESS_KEY\", AWS_REGION); // PublishRequest - Phone Number PublishRequest phonePublishRequest = new PublishRequest(); phonePublishRequest.PhoneNumber = +1XXX5555100; phonePublishRequest.Message = \"An SNS Message for phones\"; Task<PublishResponse> phoneResponse = SNSWrapper.WrapRequest(client.PublishAsync, phonePublishRequest); // PublishRequest - ARN PublishRequest publishRequest = new PublishRequest(\"TOPIC_ARN\", \"An SNS Message\"); Task<PublishResponse> publishResponse = SNSWrapper.WrapRequest(client.PublishAsync, publishRequest); // String-based without subject Task<PublishResponse> ResponseOne = SNSWrapper.WrapRequest(client.PublishAsync, \"TOPIC_ARN\", \"Another SNS Message\"); // String-based with subject Task<PublishResponse> ResponseTwo = SNSWrapper.WrapRequest(client.PublishAsync, \"TOPIC_ARN\", \"Yet Another SNS Message\", \"A Subject\"); The following environment variables are not required for Lambda monitoring to function but they are required if you want your Lambda functions to be included in distributed traces. To enable distributed tracing, set these environment variables in the AWS Lambda console: NEW_RELIC_ACCOUNT_ID: The account ID the Lambda is reporting to. NEW_RELIC_TRUSTED_ACCOUNT_KEY: This is also the account ID. If your account is a sub-account, this needs to be the account ID for the root/parent account. Ensure that the wrapper function (FunctionWrapper in above example) is set up as the function handler. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next you'll configure CloudWatch to send those logs to New Relic. Node.js To instrument your Node.js Lambda: Download our Node.js agent package and place it in the same directory as your function, ensuring the agent is installed as a dependency in the node_modules directory. Use the Node Package Manager: npm install newrelic --save Install our AWS SDK module alongside the Node.js agent: npm install @newrelic/aws-sdk --save In your Lambda code, require the agent module and the AWS SDK at the top of the file, and wrap the handler function. For example: const newrelic = require('newrelic'); require('@newrelic/aws-sdk'); <Other module loads go under the two require statements above> module.exports.handler = newrelic.setLambdaHandler((event, context, callback) => { // This is your handler function code console.log('Lambda executed'); callback(); }); Optional: You can also add custom events to your Lambda using the recordCustomEvent API. For example: module.exports.handler = newrelic.setLambdaHandler((event, context, callback) => { newrelic.recordCustomEvent(‘MyEventType’, {foo: ‘bar’}); console.log('Lambda executed'); callback(); }); Zip your Lambda function and the Node.js agent folder together. Requirements and recommendations: The New Relic files outside the New Relic agent folder don't need to be included. If your Lambda function file name is, for example, lambda_function.node, we recommend naming your zip file lambda_function.zip. Do not use a tarball. Your Lambda and its associated modules must all be in the zip file's root directory. This means that if you zip a folder that contains the files, it won't work. Upload the zipped file to your AWS Lambda account. In the AWS console, set these environment variables: NEW_RELIC_NO_CONFIG_FILE. Set to true if not using a configuration file. NEW_RELIC_APP_NAME: Your application name. NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a sub-account, this needs to be the account ID for the root/parent account. Optional: To run the agent in serverless mode outside of AWS in a local environment, set the environment variable NEW_RELIC_SERVERLESS_MODE_ENABLED to true. (When executing this in an AWS Lambda environment, the agent will automatically run in serverless mode. Do not use this variable if you're running in AWS.) Optional: To enable logging in serverless mode, set these environment variables: Set NEW_RELIC_LOG_ENABLED to true. Set NEW_RELIC_LOG to stdout for output to CloudWatch, or set to any writeable file location. The log level is set to info by default. See other log levels. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. Our wrapper gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next you'll configure CloudWatch to send those logs to New Relic. Python To instrument your Python Lambda: Download our Python agent package and place it in the same directory as your function. To do this, use pip: pip install -t . newrelic If you use Homebrew, you may get this error: DistutilsOptionError: must supply either home or prefix/exec-prefix -- not both. For details, see the Homebrew GitHub post. In your Lambda code, import the Python agent module and decorate the handler function using the New Relic decorator. The New Relic package must be imported first in your code. Here's an example: import newrelic.agent newrelic.agent.initialize() @newrelic.agent.lambda_handler() def handler(event, context): ... Optional: You can also add custom events to your Lambda using the record_custom_event API. Here's an example: @newrelic.agent.lambda_handler() def handler(event, context): newrelic.agent.record_custom_event('CustomEvent', {'foo': 'bar'}) … Zip your lambda_function.py and newrelic/ folder together using these guidelines: The New Relic files outside the newrelic/ folder don't need to be included. If your Lambda function file name is, for example, lambda_function.py, name your zip file lambda_function.zip. Do not use a tarball. Your Lambda and its associated modules must all be in the zip file's root directory. This means that if you zip a folder that contains the files, it won't work. Upload the zipped file to your AWS Lambda account. In the AWS console, set this environment variable: NEW_RELIC_SERVERLESS_MODE_ENABLED. Set to true The following environment variables are not required for Lambda monitoring to function but they are required if you want your Lambda functions to be included in distributed traces. To enable distributed tracing, set these environment variables in the AWS console: NEW_RELIC_DISTRIBUTED_TRACING_ENABLED. Set to true. NEW_RELIC_ACCOUNT_ID. Your account ID. NEW_RELIC_TRUSTED_ACCOUNT_KEY. This is also your account ID. If your account is a sub-account, this needs to be the account ID for the root/parent account. Optional: To configure logging, use the NEW_RELIC_LOG and NEW_RELIC_LOG_LEVEL environment variables in the AWS Console. Invoke the Lambda at least once. This creates a CloudWatch log group, which must be present for the next step to work. The New Relic decorator gathers data about the Lambda execution, generates a JSON message, and logs it to CloudWatch Logs. Next, configure CloudWatch to send those logs to New Relic. Step 4. Configure CloudWatch logs to stream to New Relic Lambda In this step, you'll link your Lambda function's CloudWatch Logs stream to the newrelic-log-ingestion Lambda that was configured in Step 2. For Node.js and Python: This step isn't necessary if you used the Serverless Framework plugin option in Step 3. This step can be done using the CLI tool or using manual procedures. Use CLI tool Run this command for every Lambda function you want to monitor: newrelic-lambda subscriptions install --function FUNCTION_NAME_#1 Or to set subscription filters for all supported functions run this command:: newrelic-lambda subscriptions install --function all Notes on this command: You should only need one newrelic-log-ingestion Lambda per AWS account and region. You can subscribe as many functions to it as you like. To see more detail about the arguments, including a region-specifying argument, see our GitHub documentation. You may receive a CloudWatch validation error. This doesn't affect data reporting. If you see data reporting in New Relic, disregard that error message. If you have our Logs and want to send all your log data to us (not just Lambda logs), see Stream all logs. Manual procedures Here are the manual procedures performed by the CLI tool: Manual process: Stream CloudWatch logs to New Relic Lambda In Step 2, you set up a newrelic-log-ingestion Lambda function. After you've instrumented your Lambda function (Step 3), the newrelic-lambda subscriptions command links that function's CloudWatch Logs stream to the newrelic-log-ingestion Lambda. To do this manually: Open CloudWatch and select Logs in the left-hand menu, and then select the log group for the function you are monitoring. Select Actions and choose Stream to AWS Lambda. Under Lambda function, select the newrelic-log-ingestion function. Set the Log format to JSON. Set the Subscription filter pattern to ?REPORT ?NR_LAMBDA_MONITORING ?\"Task timed out\". Alternatively, if you are using the LOGGING_ENABLED environment variable stream all your logs to our Logs, leave this field blank. See notes and caveats about this procedure. Make sure the newrelic-log-ingestion Lambda function you select in the method above is in the same AWS region as your Lambda function. What's next? After you complete these steps, here's what you can do next: See data reporting in the Lambda monitoring UI. If you're having trouble finding your data, see Lambda enable troubleshooting. Use configuration settings to fine-tune your data. Our newrelic-log-ingestion function is not updated automatically. For best results and access to latest features, we recommend you occasionally update our Lambda monitoring. Optional: Stream all logs to New Relic If you have log management enabled and want to report all your logs to New Relic, follow these instructions: Go to our newrelic-log-ingestion Lambda and set the LOGGING_ENABLED environment variable to true. It isn't possible to edit existing filter patterns, so they must be removed and re-added: Set the Subscription filter pattern to \"\". Go to the Log group for each monitored Lambda, and remove the newrelic-log-ingestion subscription. Add the subscription filter back, leaving the Subscription filter pattern field blank. For more help If you need more help, check out these support and learning resources: Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.45444,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Step 1. Install the <em>newrelic</em>-lambda-<em>cli</em> tool",
        "info": "Read about how to install and enable <em>New</em> <em>Relic</em> monitoring for Amazon AWS Lambda. ",
        "body": " CloudWatch logs to <em>New</em> <em>Relic</em> (required) Step 1. Install the newrelic-lambda-<em>cli</em> tool We provide a <em>command</em> line interface (<em>CLI</em>) tool that&#x27;s used in steps 2 through 4. We recommend the <em>CLI</em> because it simplifies some of the work, but you can also perform those steps manually. If you want to understand"
      },
      "id": "5f37be4864441f3242a0a626"
    }
  ]
}